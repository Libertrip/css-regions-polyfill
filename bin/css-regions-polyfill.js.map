{"version":3,"sources":["../src/core/polyfill-dom-console.js","../src/core/dom-events.js","../src/core/css-syntax.js","../src/core/polyfill-dom-requestAnimationFrame.js","../src/core/dom-experimental-event-streams.js","../src/core/dom-query-selector-live.js","../src/core/css-cascade.js","../src/core/css-break.js","../src/css-regions/lib/range-extensions.js","../src/css-regions/lib/helpers.js","../src/css-regions/lib/objectmodel.js","../src/css-regions/polyfill.js","../src/requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC/9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;AC/aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;AC/LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;AC5yBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC3bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;AC3cA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;ACnmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;AC1nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;AC3gCA;AACA;AACA;AACA;AACA;AACA,sC","file":"css-regions-polyfill.js","sourcesContent":["!(function(window, document) {\n  'use strict'\n\n  //\n  // some code for console polyfilling\n  //\n  if (!window.console) {\n    window.console = {\n      backlog: '',\n\n      log: function(x) {\n        this.backlog += x + '\\n'\n        if (window.debug) alert(x)\n      },\n\n      dir: function(x) {\n        try {\n          var elm = function(e) {\n            if (e.innerHTML) {\n              return {\n                tagName: e.tagName,\n                className: e.className,\n                id: e.id,\n                innerHTML: e.innerHTML.substr(0, 100)\n              }\n            } else {\n              return {\n                nodeName: e.nodeName,\n                nodeValue: e.nodeValue\n              }\n            }\n          }\n\n          var jsonify = function(o) {\n            var seen = []\n            var jso = JSON.stringify(o, function(k, v) {\n              if (typeof v == 'object') {\n                if (!seen.indexOf(v)) {\n                  return '__cycle__'\n                }\n                if (v instanceof window.Node) {\n                  return elm(v)\n                }\n                seen.push(v)\n              }\n              return v\n            })\n            return jso\n          }\n\n          this.log(jsonify(x))\n        } catch (ex) {\n          this.log(x)\n        }\n      },\n\n      warn: function(x) {\n        this.log(x)\n      },\n\n      error: function(x) {\n        this.log('ERROR:')\n        this.log(x)\n      }\n    }\n\n    if (!window.onerror) {\n      window.onerror = function() {\n        console.log([].slice.call(arguments, 0).join('\\n'))\n      }\n    }\n  }\n\n  //\n  // this special console is used as a proxy emulating the CSS console of browsers\n  //\n  window.cssConsole = {\n    enabled: !!window.debug,\n    warnEnabled: true,\n    log: function(x) {\n      if (this.enabled) console.log(x)\n    },\n    dir: function(x) {\n      if (this.enabled) console.dir(x)\n    },\n    warn: function(x) {\n      if (this.warnEnabled) console.warn(x)\n    },\n    error: function(x) {\n      console.error(x)\n    }\n  }\n})(window, document)\n\nrequire.define('src/core/polyfill-dom-console.js');","module.exports = (function(window, document) {\n  'use strict'\n\n  require('src/core/polyfill-dom-console.js')\n\n  //\n  // some other basic om code\n  //\n  var domEvents = {\n    //\n    // the following functions are about event cloning\n    //\n    cloneMouseEvent: function cloneMouseEvent(e) {\n      var evt = document.createEvent('MouseEvent')\n      evt.initMouseEvent(\n        e.type,\n        e.canBubble || e.bubbles,\n        e.cancelable,\n        e.view,\n        e.detail,\n        e.screenX,\n        e.screenY,\n        e.clientX,\n        e.clientY,\n        e.ctrlKey,\n        e.altKey,\n        e.shiftKey,\n        e.metaKey,\n        e.button,\n        e.relatedTarget\n      )\n      return evt\n    },\n\n    cloneKeyboardEvent: function cloneKeyboardEvent(e) {\n      // TODO: this doesn't work cross-browser...\n      // see https://gist.github.com/termi/4654819/ for the huge code\n      return domEvents.cloneCustomEvent(e)\n    },\n\n    cloneCustomEvent: function cloneCustomEvent(e) {\n      var ne = document.createEvent('CustomEvent')\n      ne.initCustomEvent(\n        e.type,\n        e.canBubble || e.bubbles,\n        e.cancelable,\n        'detail' in e ? e.detail : e\n      )\n      for (var prop in e) {\n        try {\n          if (e[prop] != ne[prop] && e[prop] != e.target) {\n            try {\n              ne[prop] = e[prop]\n            } catch (ex) {\n              Object.defineProperty(ne, prop, {\n                get: function() {\n                  return e[prop]\n                }\n              })\n            }\n          }\n        } catch (ex) {}\n      }\n      return ne\n    },\n\n    cloneEvent: function cloneEvent(e) {\n      if (e instanceof MouseEvent) {\n        return domEvents.cloneMouseEvent(e)\n      } else if (e instanceof KeyboardEvent) {\n        return domEvents.cloneKeyboardEvent(e)\n      } else {\n        return domEvents.cloneCustomEvent(e)\n      }\n    },\n\n    //\n    // allows you to drop event support to any class easily\n    //\n    EventTarget: {\n      implementsIn: function(eventClass, static_class) {\n        if (!static_class && typeof eventClass == 'function') eventClass = eventClass.prototype\n\n        eventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent\n        eventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener\n        eventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener\n      },\n      prototype: {}\n    }\n  }\n\n  domEvents.EventTarget.prototype.addEventListener = function(eventType, f) {\n    if (!this.eventListeners) this.eventListeners = []\n\n    var ls = this.eventListeners[eventType] || (this.eventListeners[eventType] = [])\n    if (ls.indexOf(f) == -1) {\n      ls.push(f)\n    }\n  }\n\n  domEvents.EventTarget.prototype.removeEventListener = function(eventType, f) {\n    if (!this.eventListeners) this.eventListeners = []\n\n    var ls = this.eventListeners[eventType] || (this.eventListeners[eventType] = []),\n      i\n    if ((i = ls.indexOf(f)) !== -1) {\n      ls.splice(i, 1)\n    }\n  }\n\n  domEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\n    if (!this.eventListeners) this.eventListeners = []\n\n    // abort quickly when no listener has been set up\n    if (typeof event_or_type == 'string') {\n      if (!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length == 0) {\n        return\n      }\n    } else {\n      if (\n        !this.eventListeners[event_or_type.type] ||\n        this.eventListeners[event_or_type.type].length == 0\n      ) {\n        return\n      }\n    }\n\n    // convert the event\n    var event = event_or_type\n    function setUpPropertyForwarding(e, ee, key) {\n      Object.defineProperty(ee, key, {\n        get: function() {\n          var v = e[key]\n          if (typeof v == 'function') {\n            return v.bind(e)\n          } else {\n            return v\n          }\n        },\n        set: function(v) {\n          e[key] = v\n        }\n      })\n    }\n    function setUpTarget(e, v) {\n      try {\n        Object.defineProperty(e, 'target', {\n          get: function() {\n            return v\n          }\n        })\n      } catch (ex) {\n      } finally {\n        if (e.target !== v) {\n          var ee = Object.create(Object.getPrototypeOf(e))\n          ee = setUpTarget(ee, v)\n          for (var key in e) {\n            if (key != 'target') setUpPropertyForwarding(e, ee, key)\n          }\n          return ee\n        } else {\n          return e\n        }\n      }\n    }\n\n    // try to set the target\n    if (typeof event == 'object') {\n      try {\n        event = setUpTarget(event, this)\n      } catch (ex) {}\n    } else if (typeof event == 'string') {\n      event = document.createEvent('CustomEvent')\n      event.initCustomEvent(\n        event_or_type,\n        /*canBubble:*/ true,\n        /*cancelable:*/ false,\n        /*detail:*/ this\n      )\n      try {\n        event = setUpTarget(event, this)\n      } catch (ex) {}\n    } else {\n      throw new Error('dispatchEvent expect an Event object or a string containing the event type')\n    }\n\n    // call all listeners\n    var ls = this.eventListeners[event.type] || (this.eventListeners[event.type] = [])\n    for (var i = ls.length; i--; ) {\n      try {\n        ls[i](event)\n      } catch (ex) {\n        setImmediate(function() {\n          throw ex\n        })\n      }\n    }\n\n    return event.isDefaultPrevented\n  }\n\n  return domEvents\n})(window, document)\n\nrequire.define('src/core/dom-events.js');","//\n// note: this file is based on Tab Atkins's CSS Parser\n// please include him (@tabatkins) if you open any issue for this file\n//\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  //\n  // exports\n  //\n  var cssSyntax = {\n    tokenize: function(string) {\n      /*filled later*/\n    },\n    parse: function(tokens) {\n      /*filled later*/\n    }\n  }\n\n  //\n  // css tokenizer\n  //\n\n  // Add support for token lists (superclass of array)\n  function TokenList() {\n    var array = []\n    array.toCSSString = TokenListToCSSString\n    return array\n  }\n  function TokenListToCSSString(sep) {\n    if (sep) {\n      return this.map(function(o) {\n        return o.toCSSString()\n      }).join(sep)\n    } else {\n      return (\n        this.asCSSString ||\n        (this.asCSSString = this.map(function(o) {\n          return o.toCSSString()\n        })\n          .join('/**/')\n          .replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g, ' ')\n          .replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g, ' ')\n          .replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g, '$1')\n          .replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g, '$1'))\n      )\n    }\n  }\n  cssSyntax.TokenList = TokenList\n  cssSyntax.TokenListToCSSString = TokenListToCSSString\n\n  function between(num, first, last) {\n    return num >= first && num <= last\n  }\n  function digit(code) {\n    return between(code, 0x30, 0x39)\n  }\n  function hexdigit(code) {\n    return digit(code) || between(code, 0x41, 0x46) || between(code, 0x61, 0x66)\n  }\n  function uppercaseletter(code) {\n    return between(code, 0x41, 0x5a)\n  }\n  function lowercaseletter(code) {\n    return between(code, 0x61, 0x7a)\n  }\n  function letter(code) {\n    return uppercaseletter(code) || lowercaseletter(code)\n  }\n  function nonascii(code) {\n    return code >= 0x80\n  }\n  function namestartchar(code) {\n    return letter(code) || nonascii(code) || code == 0x5f\n  }\n  function namechar(code) {\n    return namestartchar(code) || digit(code) || code == 0x2d\n  }\n  function nonprintable(code) {\n    return between(code, 0, 8) || code == 0xb || between(code, 0xe, 0x1f) || code == 0x7f\n  }\n  function newline(code) {\n    return code == 0xa\n  }\n  function whitespace(code) {\n    return newline(code) || code == 9 || code == 0x20\n  }\n  function badescape(code) {\n    return newline(code) || isNaN(code)\n  }\n\n  var maximumallowedcodepoint = 0x10ffff\n\n  function InvalidCharacterError(message) {\n    this.message = message\n  }\n  InvalidCharacterError.prototype = new Error()\n  InvalidCharacterError.prototype.name = 'InvalidCharacterError'\n\n  function preprocess(str) {\n    // Turn a string into an array of code points,\n    // following the preprocessing cleanup rules.\n    var codepoints = []\n    for (var i = 0; i < str.length; i++) {\n      var code = str.charCodeAt(i)\n      if (code == 0xd && str.charCodeAt(i + 1) == 0xa) {\n        code = 0xa\n        i++\n      }\n      if (code == 0xd || code == 0xc) code = 0xa\n      if (code == 0x0) code = 0xfffd\n      if (between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i + 1), 0xdc00, 0xdfff)) {\n        // Decode a surrogate pair into an astral codepoint.\n        var lead = code - 0xd800\n        var trail = str.charCodeAt(i + 1) - 0xdc00\n        code = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail\n      }\n      codepoints.push(code)\n    }\n    return codepoints\n  }\n\n  function stringFromCode(code) {\n    if (code <= 0xffff) return String.fromCharCode(code)\n    // Otherwise, encode astral char as surrogate pair.\n    code -= Math.pow(2, 21)\n    var lead = Math.floor(code / Math.pow(2, 10)) + 0xd800\n    var trail = code % Math.pow(2, 10)\n    ;+0xdc00\n    return String.fromCharCode(lead) + String.fromCharCode(trail)\n  }\n\n  function tokenize(str) {\n    str = preprocess(str)\n    var i = -1\n    var tokens = new TokenList()\n    var code\n\n    // Line number information.\n    var line = 0\n    var column = 0\n    // The only use of lastLineLength is in reconsume().\n    var lastLineLength = 0\n    var incrLineno = function() {\n      line += 1\n      lastLineLength = column\n      column = 0\n    }\n    var locStart = { line: line, column: column }\n\n    var codepoint = function(i) {\n      if (i >= str.length) {\n        return -1\n      }\n      return str[i]\n    }\n    var next = function(num) {\n      if (num === undefined) {\n        num = 1\n      }\n      if (num > 3) {\n        throw 'Spec Error: no more than three codepoints of lookahead.'\n      }\n      return codepoint(i + num)\n    }\n    var consume = function(num) {\n      if (num === undefined) num = 1\n      i += num\n      code = codepoint(i)\n      if (newline(code)) incrLineno()\n      else column += num\n      //console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n      return true\n    }\n    var reconsume = function() {\n      i -= 1\n      if (newline(code)) {\n        line -= 1\n        column = lastLineLength\n      } else {\n        column -= 1\n      }\n      locStart.line = line\n      locStart.column = column\n      return true\n    }\n    var eof = function(codepoint) {\n      if (codepoint === undefined) codepoint = code\n      return codepoint == -1\n    }\n    var donothing = function() {}\n    var tokenizeerror = function() {\n      console.log(\n        'Parse error at index ' + i + ', processing codepoint 0x' + code.toString(16) + '.'\n      )\n      return true\n    }\n\n    var consumeAToken = function() {\n      consumeComments()\n      consume()\n      if (whitespace(code)) {\n        while (whitespace(next())) consume()\n        return new WhitespaceToken()\n      } else if (code == 0x22) return consumeAStringToken()\n      else if (code == 0x23) {\n        if (namechar(next()) || areAValidEscape(next(1), next(2))) {\n          var token = new HashToken()\n          if (wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = 'id'\n          token.value = consumeAName()\n          return token\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x24) {\n        if (next() == 0x3d) {\n          consume()\n          return new SuffixMatchToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x27) return consumeAStringToken()\n      else if (code == 0x28) return new OpenParenToken()\n      else if (code == 0x29) return new CloseParenToken()\n      else if (code == 0x2a) {\n        if (next() == 0x3d) {\n          consume()\n          return new SubstringMatchToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x2b) {\n        if (startsWithANumber()) {\n          reconsume()\n          return consumeANumericToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x2c) return new CommaToken()\n      else if (code == 0x2d) {\n        if (startsWithANumber()) {\n          reconsume()\n          return consumeANumericToken()\n        } else if (next(1) == 0x2d && next(2) == 0x3e) {\n          consume(2)\n          return new CDCToken()\n        } else if (startsWithAnIdentifier()) {\n          reconsume()\n          return consumeAnIdentlikeToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x2e) {\n        if (startsWithANumber()) {\n          reconsume()\n          return consumeANumericToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x3a) return new ColonToken()\n      else if (code == 0x3b) return new SemicolonToken()\n      else if (code == 0x3c) {\n        if (next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n          consume(3)\n          return new CDOToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x40) {\n        if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n          return new AtKeywordToken(consumeAName())\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x5b) return new OpenSquareToken()\n      else if (code == 0x5c) {\n        if (startsWithAValidEscape()) {\n          reconsume()\n          return consumeAnIdentlikeToken()\n        } else {\n          tokenizeerror()\n          return new DelimToken(code)\n        }\n      } else if (code == 0x5d) return new CloseSquareToken()\n      else if (code == 0x5e) {\n        if (next() == 0x3d) {\n          consume()\n          return new PrefixMatchToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x7b) return new OpenCurlyToken()\n      else if (code == 0x7c) {\n        if (next() == 0x3d) {\n          consume()\n          return new DashMatchToken()\n        } else if (next() == 0x7c) {\n          consume()\n          return new ColumnToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (code == 0x7d) return new CloseCurlyToken()\n      else if (code == 0x7e) {\n        if (next() == 0x3d) {\n          consume()\n          return new IncludeMatchToken()\n        } else {\n          return new DelimToken(code)\n        }\n      } else if (digit(code)) {\n        reconsume()\n        return consumeANumericToken()\n      } else if (namestartchar(code)) {\n        reconsume()\n        return consumeAnIdentlikeToken()\n      } else if (eof()) return new EOFToken()\n      else return new DelimToken(code)\n    }\n\n    var consumeComments = function() {\n      while (next(1) == 0x2f && next(2) == 0x2a) {\n        consume(2)\n        while (true) {\n          consume()\n          if (code == 0x2a && next() == 0x2f) {\n            consume()\n            break\n          } else if (eof()) {\n            tokenizeerror()\n            return\n          }\n        }\n      }\n    }\n\n    var consumeANumericToken = function() {\n      var num = consumeANumber()\n      if (wouldStartAnIdentifier(next(1), next(2), next(3))) {\n        var token = new DimensionToken()\n        token.value = num.value\n        token.repr = num.repr\n        token.type = num.type\n        token.unit = consumeAName()\n        return token\n      } else if (next() == 0x25) {\n        consume()\n        var token = new PercentageToken()\n        token.value = num.value\n        token.repr = num.repr\n        return token\n      } else {\n        var token = new NumberToken()\n        token.value = num.value\n        token.repr = num.repr\n        token.type = num.type\n        return token\n      }\n    }\n\n    var consumeAnIdentlikeToken = function() {\n      var str = consumeAName()\n      if (str.toLowerCase() == 'url' && next() == 0x28) {\n        consume()\n        while (whitespace(next(1)) && whitespace(next(2))) consume()\n        if (next() == 0x22 || next() == 0x27) {\n          return new FunctionToken(str)\n        } else if (whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n          return new FunctionToken(str)\n        } else {\n          return consumeAURLToken()\n        }\n      } else if (next() == 0x28) {\n        consume()\n        return new FunctionToken(str)\n      } else {\n        return new IdentifierToken(str)\n      }\n    }\n\n    var consumeAStringToken = function(endingCodePoint) {\n      if (endingCodePoint === undefined) endingCodePoint = code\n      var string = ''\n      while (consume()) {\n        if (code == endingCodePoint || eof()) {\n          return new StringToken(string)\n        } else if (newline(code)) {\n          tokenizeerror()\n          reconsume()\n          return new BadStringToken()\n        } else if (code == 0x5c) {\n          if (eof(next())) {\n            donothing()\n          } else if (newline(next())) {\n            consume()\n          } else {\n            string += stringFromCode(consumeEscape())\n          }\n        } else {\n          string += stringFromCode(code)\n        }\n      }\n    }\n\n    var consumeAURLToken = function() {\n      var token = new URLToken('')\n      while (whitespace(next())) consume()\n      if (eof(next())) return token\n      while (consume()) {\n        if (code == 0x29 || eof()) {\n          return token\n        } else if (whitespace(code)) {\n          while (whitespace(next())) consume()\n          if (next() == 0x29 || eof(next())) {\n            consume()\n            return token\n          } else {\n            consumeTheRemnantsOfABadURL()\n            return new BadURLToken()\n          }\n        } else if (code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n          tokenizeerror()\n          consumeTheRemnantsOfABadURL()\n          return new BadURLToken()\n        } else if (code == 0x5c) {\n          if (startsWithAValidEscape()) {\n            token.value += stringFromCode(consumeEscape())\n          } else {\n            tokenizeerror()\n            consumeTheRemnantsOfABadURL()\n            return new BadURLToken()\n          }\n        } else {\n          token.value += stringFromCode(code)\n        }\n      }\n    }\n\n    var consumeEscape = function() {\n      // Assume the the current character is the \\\n      // and the next code point is not a newline.\n      consume()\n      if (hexdigit(code)) {\n        // Consume 1-6 hex digits\n        var digits = [code]\n        for (var total = 0; total < 5; total++) {\n          if (hexdigit(next())) {\n            consume()\n            digits.push(code)\n          } else {\n            break\n          }\n        }\n        if (whitespace(next())) consume()\n        var value = parseInt(\n          digits\n            .map(function(x) {\n              return String.fromCharCode(x)\n            })\n            .join(''),\n          16\n        )\n        if (value > maximumallowedcodepoint) value = 0xfffd\n        return value\n      } else if (eof()) {\n        return 0xfffd\n      } else {\n        return code\n      }\n    }\n\n    var areAValidEscape = function(c1, c2) {\n      if (c1 != 0x5c) return false\n      if (newline(c2)) return false\n      return true\n    }\n    var startsWithAValidEscape = function() {\n      return areAValidEscape(code, next())\n    }\n\n    var wouldStartAnIdentifier = function(c1, c2, c3) {\n      if (c1 == 0x2d) {\n        return namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3)\n      } else if (namestartchar(c1)) {\n        return true\n      } else if (c1 == 0x5c) {\n        return areAValidEscape(c1, c2)\n      } else {\n        return false\n      }\n    }\n    var startsWithAnIdentifier = function() {\n      return wouldStartAnIdentifier(code, next(1), next(2))\n    }\n\n    var wouldStartANumber = function(c1, c2, c3) {\n      if (c1 == 0x2b || c1 == 0x2d) {\n        if (digit(c2)) return true\n        if (c2 == 0x2e && digit(c3)) return true\n        return false\n      } else if (c1 == 0x2e) {\n        if (digit(c2)) return true\n        return false\n      } else if (digit(c1)) {\n        return true\n      } else {\n        return false\n      }\n    }\n    var startsWithANumber = function() {\n      return wouldStartANumber(code, next(1), next(2))\n    }\n\n    var consumeAName = function() {\n      var result = ''\n      while (consume()) {\n        if (namechar(code)) {\n          result += stringFromCode(code)\n        } else if (startsWithAValidEscape()) {\n          result += stringFromCode(consumeEscape())\n        } else {\n          reconsume()\n          return result\n        }\n      }\n    }\n\n    var consumeANumber = function() {\n      var repr = ''\n      var type = 'integer'\n      if (next() == 0x2b || next() == 0x2d) {\n        consume()\n        repr += stringFromCode(code)\n      }\n      while (digit(next())) {\n        consume()\n        repr += stringFromCode(code)\n      }\n      if (next(1) == 0x2e && digit(next(2))) {\n        consume()\n        repr += stringFromCode(code)\n        consume()\n        repr += stringFromCode(code)\n        type = 'number'\n        while (digit(next())) {\n          consume()\n          repr += stringFromCode(code)\n        }\n      }\n      var c1 = next(1),\n        c2 = next(2),\n        c3 = next(3)\n      if ((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n        consume()\n        repr += stringFromCode(code)\n        consume()\n        repr += stringFromCode(code)\n        type = 'number'\n        while (digit(next())) {\n          consume()\n          repr += stringFromCode(code)\n        }\n      } else if ((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n        consume()\n        repr += stringFromCode(code)\n        consume()\n        repr += stringFromCode(code)\n        consume()\n        repr += stringFromCode(code)\n        type = 'number'\n        while (digit(next())) {\n          consume()\n          repr += stringFromCode(code)\n        }\n      }\n      var value = convertAStringToANumber(repr)\n      return { type: type, value: value, repr: repr }\n    }\n\n    var convertAStringToANumber = function(string) {\n      // CSS's number rules are identical to JS, afaik.\n      return +string\n    }\n\n    var consumeTheRemnantsOfABadURL = function() {\n      while (consume()) {\n        if (code == 0x2d || eof()) {\n          return\n        } else if (startsWithAValidEscape()) {\n          consumeEscape()\n          donothing()\n        } else {\n          donothing()\n        }\n      }\n    }\n\n    var iterationCount = 0\n    while (!eof(next())) {\n      tokens.push(consumeAToken())\n      if (iterationCount++ > str.length * 2)\n        throw new Error('The CSS Tokenizer is infinite-looping')\n    }\n    return tokens\n  }\n\n  function CSSParserToken() {\n    return this\n  }\n  CSSParserToken.prototype.toJSON = function() {\n    return { token: this.tokenType }\n  }\n  CSSParserToken.prototype.toString = function() {\n    return this.tokenType\n  }\n  CSSParserToken.prototype.toCSSString = function() {\n    return '' + this\n  }\n\n  function BadStringToken() {\n    return this\n  }\n  BadStringToken.prototype = new CSSParserToken()\n  BadStringToken.prototype.tokenType = 'BADSTRING'\n  BadStringToken.prototype.toCSSString = function() {\n    return \"'\"\n  }\n\n  function BadURLToken() {\n    return this\n  }\n  BadURLToken.prototype = new CSSParserToken()\n  BadURLToken.prototype.tokenType = 'BADURL'\n  BadURLToken.prototype.toCSSString = function() {\n    return 'url('\n  }\n\n  function WhitespaceToken() {\n    return this\n  }\n  WhitespaceToken.prototype = new CSSParserToken()\n  WhitespaceToken.prototype.tokenType = 'WHITESPACE'\n  WhitespaceToken.prototype.toString = function() {\n    return 'WS'\n  }\n  WhitespaceToken.prototype.toCSSString = function() {\n    return ' '\n  }\n\n  function CDOToken() {\n    return this\n  }\n  CDOToken.prototype = new CSSParserToken()\n  CDOToken.prototype.tokenType = 'CDO'\n  CDOToken.prototype.toCSSString = function() {\n    return '<!--'\n  }\n\n  function CDCToken() {\n    return this\n  }\n  CDCToken.prototype = new CSSParserToken()\n  CDCToken.prototype.tokenType = 'CDC'\n  CDCToken.prototype.toCSSString = function() {\n    return '-->'\n  }\n\n  function ColonToken() {\n    return this\n  }\n  ColonToken.prototype = new CSSParserToken()\n  ColonToken.prototype.tokenType = ':'\n\n  function SemicolonToken() {\n    return this\n  }\n  SemicolonToken.prototype = new CSSParserToken()\n  SemicolonToken.prototype.tokenType = ';'\n\n  function CommaToken() {\n    return this\n  }\n  CommaToken.prototype = new CSSParserToken()\n  CommaToken.prototype.tokenType = ','\n  CommaToken.prototype.value = ';' // backwards-compat with DELIM token\n\n  function GroupingToken() {\n    return this\n  }\n  GroupingToken.prototype = new CSSParserToken()\n\n  function OpenCurlyToken() {\n    this.value = '{'\n    this.mirror = '}'\n    return this\n  }\n  OpenCurlyToken.prototype = new GroupingToken()\n  OpenCurlyToken.prototype.tokenType = '{'\n\n  function CloseCurlyToken() {\n    this.value = '}'\n    this.mirror = '{'\n    return this\n  }\n  CloseCurlyToken.prototype = new GroupingToken()\n  CloseCurlyToken.prototype.tokenType = '}'\n\n  function OpenSquareToken() {\n    this.value = '['\n    this.mirror = ']'\n    return this\n  }\n  OpenSquareToken.prototype = new GroupingToken()\n  OpenSquareToken.prototype.tokenType = '['\n\n  function CloseSquareToken() {\n    this.value = ']'\n    this.mirror = '['\n    return this\n  }\n  CloseSquareToken.prototype = new GroupingToken()\n  CloseSquareToken.prototype.tokenType = ']'\n\n  function OpenParenToken() {\n    this.value = '('\n    this.mirror = ')'\n    return this\n  }\n  OpenParenToken.prototype = new GroupingToken()\n  OpenParenToken.prototype.tokenType = '('\n\n  function CloseParenToken() {\n    this.value = ')'\n    this.mirror = '('\n    return this\n  }\n  CloseParenToken.prototype = new GroupingToken()\n  CloseParenToken.prototype.tokenType = ')'\n\n  function IncludeMatchToken() {\n    return this\n  }\n  IncludeMatchToken.prototype = new CSSParserToken()\n  IncludeMatchToken.prototype.tokenType = '~='\n\n  function DashMatchToken() {\n    return this\n  }\n  DashMatchToken.prototype = new CSSParserToken()\n  DashMatchToken.prototype.tokenType = '|='\n\n  function PrefixMatchToken() {\n    return this\n  }\n  PrefixMatchToken.prototype = new CSSParserToken()\n  PrefixMatchToken.prototype.tokenType = '^='\n\n  function SuffixMatchToken() {\n    return this\n  }\n  SuffixMatchToken.prototype = new CSSParserToken()\n  SuffixMatchToken.prototype.tokenType = '$='\n\n  function SubstringMatchToken() {\n    return this\n  }\n  SubstringMatchToken.prototype = new CSSParserToken()\n  SubstringMatchToken.prototype.tokenType = '*='\n\n  function ColumnToken() {\n    return this\n  }\n  ColumnToken.prototype = new CSSParserToken()\n  ColumnToken.prototype.tokenType = '||'\n\n  function EOFToken() {\n    return this\n  }\n  EOFToken.prototype = new CSSParserToken()\n  EOFToken.prototype.tokenType = 'EOF'\n  EOFToken.prototype.toCSSString = function() {\n    return ''\n  }\n\n  function DelimToken(code) {\n    this.value = stringFromCode(code)\n    return this\n  }\n  DelimToken.prototype = new CSSParserToken()\n  DelimToken.prototype.tokenType = 'DELIM'\n  DelimToken.prototype.toString = function() {\n    return 'DELIM(' + this.value + ')'\n  }\n  DelimToken.prototype.toCSSString = function() {\n    return this.value == '\\\\' ? '\\\\\\n' : this.value\n  }\n\n  function StringValuedToken() {\n    return this\n  }\n  StringValuedToken.prototype = new CSSParserToken()\n  StringValuedToken.prototype.ASCIIMatch = function(str) {\n    return this.value.toLowerCase() == str.toLowerCase()\n  }\n\n  function IdentifierToken(val) {\n    this.value = val\n  }\n  IdentifierToken.prototype = new StringValuedToken()\n  IdentifierToken.prototype.tokenType = 'IDENT'\n  IdentifierToken.prototype.toString = function() {\n    return 'IDENT(' + this.value + ')'\n  }\n  IdentifierToken.prototype.toCSSString = function() {\n    return escapeIdent(this.value)\n  }\n\n  function FunctionToken(val) {\n    this.value = val\n    this.mirror = ')'\n  }\n  FunctionToken.prototype = new StringValuedToken()\n  FunctionToken.prototype.tokenType = 'FUNCTION'\n  FunctionToken.prototype.toString = function() {\n    return 'FUNCTION(' + this.value + ')'\n  }\n  FunctionToken.prototype.toCSSString = function() {\n    return escapeIdent(this.value) + '('\n  }\n\n  function AtKeywordToken(val) {\n    this.value = val\n  }\n  AtKeywordToken.prototype = new StringValuedToken()\n  AtKeywordToken.prototype.tokenType = 'AT-KEYWORD'\n  AtKeywordToken.prototype.toString = function() {\n    return 'AT(' + this.value + ')'\n  }\n  AtKeywordToken.prototype.toCSSString = function() {\n    return '@' + escapeIdent(this.value)\n  }\n\n  function HashToken(val) {\n    this.value = val\n    this.type = 'unrestricted'\n  }\n  HashToken.prototype = new StringValuedToken()\n  HashToken.prototype.tokenType = 'HASH'\n  HashToken.prototype.toString = function() {\n    return 'HASH(' + this.value + ')'\n  }\n  HashToken.prototype.toCSSString = function() {\n    var escapeValue = this.type == 'id' ? escapeIdent : escapeHash\n    return '#' + escapeValue(this.value)\n  }\n\n  function StringToken(val) {\n    this.value = val\n  }\n  StringToken.prototype = new StringValuedToken()\n  StringToken.prototype.tokenType = 'STRING'\n  StringToken.prototype.toString = function() {\n    return '\"' + escapeString(this.value) + '\"'\n  }\n\n  function URLToken(val) {\n    this.value = val\n  }\n  URLToken.prototype = new StringValuedToken()\n  URLToken.prototype.tokenType = 'URL'\n  URLToken.prototype.toString = function() {\n    return 'URL(' + this.value + ')'\n  }\n  URLToken.prototype.toCSSString = function() {\n    return 'url(\"' + escapeString(this.value) + '\")'\n  }\n\n  function NumberToken() {\n    this.value = null\n    this.type = 'integer'\n    this.repr = ''\n  }\n  NumberToken.prototype = new CSSParserToken()\n  NumberToken.prototype.tokenType = 'NUMBER'\n  NumberToken.prototype.toString = function() {\n    if (this.type == 'integer') return 'INT(' + this.value + ')'\n    return 'NUMBER(' + this.value + ')'\n  }\n  NumberToken.prototype.toJSON = function() {\n    var json = this.constructor.prototype.constructor.prototype.toJSON.call(this)\n    json.value = this.value\n    json.type = this.type\n    json.repr = this.repr\n    return json\n  }\n  NumberToken.prototype.toCSSString = function() {\n    return this.repr\n  }\n\n  function PercentageToken() {\n    this.value = null\n    this.repr = ''\n  }\n  PercentageToken.prototype = new CSSParserToken()\n  PercentageToken.prototype.tokenType = 'PERCENTAGE'\n  PercentageToken.prototype.toString = function() {\n    return 'PERCENTAGE(' + this.value + ')'\n  }\n  PercentageToken.prototype.toCSSString = function() {\n    return this.repr + '%'\n  }\n\n  function DimensionToken() {\n    this.value = null\n    this.type = 'integer'\n    this.repr = ''\n    this.unit = ''\n  }\n  DimensionToken.prototype = new CSSParserToken()\n  DimensionToken.prototype.tokenType = 'DIMENSION'\n  DimensionToken.prototype.toString = function() {\n    return 'DIM(' + this.value + ',' + this.unit + ')'\n  }\n  DimensionToken.prototype.toCSSString = function() {\n    var source = this.repr\n    var unit = escapeIdent(this.unit)\n    if (\n      unit[0].toLowerCase() == 'e' &&\n      (unit[1] == '-' || between(unit.charCodeAt(1), 0x30, 0x39))\n    ) {\n      // Unit is ambiguous with scinot\n      // Remove the leading \"e\", replace with escape.\n      unit = '\\\\65 ' + unit.slice(1, unit.length)\n    }\n    return source + unit\n  }\n\n  function escapeIdent(string) {\n    string = '' + string\n    var result = ''\n    var firstcode = string.charCodeAt(0)\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i)\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.')\n      }\n\n      if (\n        between(code, 0x1, 0x1f) ||\n        code == 0x7f ||\n        (i == 0 && between(code, 0x30, 0x39)) ||\n        (i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\n      ) {\n        result += '\\\\' + code.toString(16) + ' '\n      } else if (\n        code >= 0x80 ||\n        code == 0x2d ||\n        code == 0x5f ||\n        between(code, 0x30, 0x39) ||\n        between(code, 0x41, 0x5a) ||\n        between(code, 0x61, 0x7a)\n      ) {\n        result += string[i]\n      } else {\n        result += '\\\\' + string[i]\n      }\n    }\n    return result\n  }\n\n  function escapeHash(string) {\n    // Escapes the contents of \"unrestricted\"-type hash tokens.\n    // Won't preserve the ID-ness of \"id\"-type hash tokens;\n    // use escapeIdent() for that.\n    string = '' + string\n    var result = ''\n    var firstcode = string.charCodeAt(0)\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i)\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.')\n      }\n\n      if (\n        code >= 0x80 ||\n        code == 0x2d ||\n        code == 0x5f ||\n        between(code, 0x30, 0x39) ||\n        between(code, 0x41, 0x5a) ||\n        between(code, 0x61, 0x7a)\n      ) {\n        result += string[i]\n      } else {\n        result += '\\\\' + code.toString(16) + ' '\n      }\n    }\n    return result\n  }\n\n  function escapeString(string) {\n    string = '' + string\n    var result = ''\n    for (var i = 0; i < string.length; i++) {\n      var code = string.charCodeAt(i)\n\n      if (code == 0x0) {\n        throw new InvalidCharacterError('Invalid character: the input contains U+0000.')\n      }\n\n      if (between(code, 0x1, 0x1f) || code == 0x7f) {\n        result += '\\\\' + code.toString(16) + ' '\n      } else if (code == 0x22 || code == 0x5c) {\n        result += '\\\\' + string[i]\n      } else {\n        result += string[i]\n      }\n    }\n    return result\n  }\n\n  // Exportation.\n  cssSyntax.tokenize = tokenize\n  cssSyntax.IdentToken = IdentifierToken\n  cssSyntax.IdentifierToken = IdentifierToken\n  cssSyntax.FunctionToken = FunctionToken\n  cssSyntax.AtKeywordToken = AtKeywordToken\n  cssSyntax.HashToken = HashToken\n  cssSyntax.StringToken = StringToken\n  cssSyntax.BadStringToken = BadStringToken\n  cssSyntax.URLToken = URLToken\n  cssSyntax.BadURLToken = BadURLToken\n  cssSyntax.DelimToken = DelimToken\n  cssSyntax.NumberToken = NumberToken\n  cssSyntax.PercentageToken = PercentageToken\n  cssSyntax.DimensionToken = DimensionToken\n  cssSyntax.IncludeMatchToken = IncludeMatchToken\n  cssSyntax.DashMatchToken = DashMatchToken\n  cssSyntax.PrefixMatchToken = PrefixMatchToken\n  cssSyntax.SuffixMatchToken = SuffixMatchToken\n  cssSyntax.SubstringMatchToken = SubstringMatchToken\n  cssSyntax.ColumnToken = ColumnToken\n  cssSyntax.WhitespaceToken = WhitespaceToken\n  cssSyntax.CDOToken = CDOToken\n  cssSyntax.CDCToken = CDCToken\n  cssSyntax.ColonToken = ColonToken\n  cssSyntax.SemicolonToken = SemicolonToken\n  cssSyntax.CommaToken = CommaToken\n  cssSyntax.OpenParenToken = OpenParenToken\n  cssSyntax.CloseParenToken = CloseParenToken\n  cssSyntax.OpenSquareToken = OpenSquareToken\n  cssSyntax.CloseSquareToken = CloseSquareToken\n  cssSyntax.OpenCurlyToken = OpenCurlyToken\n  cssSyntax.CloseCurlyToken = CloseCurlyToken\n  cssSyntax.EOFToken = EOFToken\n  cssSyntax.CSSParserToken = CSSParserToken\n  cssSyntax.GroupingToken = GroupingToken\n\n  //\n  // css parser\n  //\n\n  function TokenStream(tokens) {\n    // Assume that tokens is an array.\n    this.tokens = tokens\n    this.i = -1\n  }\n  TokenStream.prototype.tokenAt = function(i) {\n    if (i < this.tokens.length) return this.tokens[i]\n    return new EOFToken()\n  }\n  TokenStream.prototype.consume = function(num) {\n    if (num === undefined) num = 1\n    this.i += num\n    this.token = this.tokenAt(this.i)\n    //console.log(this.i, this.token);\n    return true\n  }\n  TokenStream.prototype.next = function() {\n    return this.tokenAt(this.i + 1)\n  }\n  TokenStream.prototype.reconsume = function() {\n    this.i--\n  }\n\n  function parseerror(s, msg) {\n    console.log('Parse error at token ' + s.i + ': ' + s.token + '.\\n' + msg)\n    return true\n  }\n  function donothing() {\n    return true\n  }\n\n  function consumeAListOfRules(s, topLevel) {\n    var rules = new TokenList()\n    var rule\n    while (s.consume()) {\n      if (s.token instanceof WhitespaceToken) {\n        continue\n      } else if (s.token instanceof EOFToken) {\n        return rules\n      } else if (s.token instanceof CDOToken || s.token instanceof CDCToken) {\n        if (topLevel == 'top-level') continue\n        s.reconsume()\n        if ((rule = consumeAStyleRule(s))) rules.push(rule)\n      } else if (s.token instanceof AtKeywordToken) {\n        s.reconsume()\n        if ((rule = consumeAnAtRule(s))) rules.push(rule)\n      } else {\n        s.reconsume()\n        if ((rule = consumeAStyleRule(s))) rules.push(rule)\n      }\n    }\n  }\n\n  function consumeAnAtRule(s) {\n    s.consume()\n    var rule = new AtRule(s.token.value)\n    while (s.consume()) {\n      if (s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\n        return rule\n      } else if (s.token instanceof OpenCurlyToken) {\n        rule.value = consumeASimpleBlock(s)\n        return rule\n      } else if (s.token instanceof SimpleBlock && s.token.name == '{') {\n        rule.value = s.token\n        return rule\n      } else {\n        s.reconsume()\n        rule.prelude.push(consumeAComponentValue(s))\n      }\n    }\n  }\n\n  function consumeAStyleRule(s) {\n    var rule = new StyleRule()\n    while (s.consume()) {\n      if (s.token instanceof EOFToken) {\n        parseerror(s, 'Hit EOF when trying to parse the prelude of a qualified rule.')\n        return\n      } else if (s.token instanceof OpenCurlyToken) {\n        rule.value = consumeASimpleBlock(s)\n        return rule\n      } else if (s.token instanceof SimpleBlock && s.token.name == '{') {\n        rule.value = s.token\n        return rule\n      } else {\n        s.reconsume()\n        rule.prelude.push(consumeAComponentValue(s))\n      }\n    }\n  }\n\n  function consumeAListOfDeclarations(s) {\n    var decls = new TokenList()\n    while (s.consume()) {\n      if (s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\n        donothing()\n      } else if (s.token instanceof EOFToken) {\n        return decls\n      } else if (s.token instanceof AtKeywordToken) {\n        s.reconsume()\n        decls.push(consumeAnAtRule(s))\n      } else if (s.token instanceof IdentifierToken) {\n        var temp = [s.token]\n        while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n          temp.push(consumeAComponentValue(s))\n        var decl\n        if ((decl = consumeADeclaration(new TokenStream(temp)))) decls.push(decl)\n      } else {\n        parseerror(s)\n        s.reconsume()\n        while (!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n          consumeAComponentValue(s)\n      }\n    }\n  }\n\n  function consumeADeclaration(s) {\n    // Assumes that the next input token will be an ident token.\n    s.consume()\n    var decl = new Declaration(s.token.value)\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (!(s.next() instanceof ColonToken)) {\n      parseerror(s)\n      return\n    } else {\n      s.consume()\n    }\n    while (!(s.next() instanceof EOFToken)) {\n      decl.value.push(consumeAComponentValue(s))\n    }\n    var foundImportant = false\n    for (var i = decl.value.length - 1; i >= 0; i--) {\n      if (decl.value[i] instanceof WhitespaceToken) {\n        continue\n      } else if (\n        decl.value[i] instanceof IdentifierToken &&\n        decl.value[i].ASCIIMatch('important')\n      ) {\n        foundImportant = true\n      } else if (\n        foundImportant &&\n        decl.value[i] instanceof DelimToken &&\n        decl.value[i].value == '!'\n      ) {\n        decl.value.splice(i, decl.value.length)\n        decl.important = true\n        break\n      } else {\n        break\n      }\n    }\n    return decl\n  }\n\n  function consumeAComponentValue(s) {\n    s.consume()\n    if (\n      s.token instanceof OpenCurlyToken ||\n      s.token instanceof OpenSquareToken ||\n      s.token instanceof OpenParenToken\n    )\n      return consumeASimpleBlock(s)\n    if (s.token instanceof FunctionToken) return consumeAFunction(s)\n    return s.token\n  }\n\n  function consumeASimpleBlock(s) {\n    var mirror = s.token.mirror\n    var block = new SimpleBlock(s.token.value)\n    while (s.consume()) {\n      if (\n        s.token instanceof EOFToken ||\n        (s.token instanceof GroupingToken && s.token.value == mirror)\n      )\n        return block\n      else {\n        s.reconsume()\n        block.value.push(consumeAComponentValue(s))\n      }\n    }\n  }\n\n  function consumeAFunction(s) {\n    var func = new Func(s.token.value)\n    while (s.consume()) {\n      if (s.token instanceof EOFToken || s.token instanceof CloseParenToken) return func\n      else {\n        s.reconsume()\n        func.value.push(consumeAComponentValue(s))\n      }\n    }\n  }\n\n  function normalizeInput(input) {\n    if (typeof input == 'string') return new TokenStream(tokenize(input))\n    if (input instanceof TokenStream) return input\n    if (input.length !== undefined) return new TokenStream(input)\n    else throw SyntaxError(input)\n  }\n\n  function parseAStylesheet(s) {\n    s = normalizeInput(s)\n    var sheet = new Stylesheet()\n    sheet.value = consumeAListOfRules(s, 'top-level')\n    return sheet\n  }\n\n  function parseAListOfRules(s) {\n    s = normalizeInput(s)\n    return consumeAListOfRules(s)\n  }\n\n  function parseARule(s) {\n    s = normalizeInput(s)\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (s.next() instanceof EOFToken) throw SyntaxError()\n    if (s.next() instanceof AtKeywordToken) {\n      var rule = consumeAnAtRule(s)\n    } else {\n      var rule = consumeAStyleRule(s)\n      if (!rule) throw SyntaxError()\n    }\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (s.next() instanceof EOFToken) return rule\n    throw SyntaxError()\n  }\n\n  function parseADeclaration(s) {\n    s = normalizeInput(s)\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (!(s.next() instanceof IdentifierToken)) throw SyntaxError()\n    var decl = consumeADeclaration(s)\n    if (!decl) {\n      throw new SyntaxError()\n    }\n    return decl\n  }\n\n  function parseAListOfDeclarations(s) {\n    s = normalizeInput(s)\n    return consumeAListOfDeclarations(s)\n  }\n\n  function parseAComponentValue(s) {\n    s = normalizeInput(s)\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (s.next() instanceof EOFToken) throw SyntaxError()\n    var val = consumeAComponentValue(s)\n    if (!val) throw SyntaxError()\n    while (s.next() instanceof WhitespaceToken) s.consume()\n    if (!(s.next() instanceof EOFToken)) throw new SyntaxError()\n    return val\n  }\n\n  function parseAListOfComponentValues(s) {\n    s = normalizeInput(s)\n    var vals = new TokenList()\n    while (true) {\n      var val = consumeAComponentValue(s)\n      if (val instanceof EOFToken) return vals\n      else vals.push(val)\n    }\n  }\n\n  function parseACommaSeparatedListOfComponentValues(s) {\n    s = normalizeInput(s)\n    var listOfCVLs = new TokenList()\n    while (true) {\n      var vals = new TokenList()\n      while (true) {\n        var val = consumeAComponentValue(s)\n        if (val instanceof EOFToken) {\n          listOfCVLs.push(vals)\n          return listOfCVLs\n        } else if (val instanceof CommaToken) {\n          listOfCVLs.push(vals)\n          break\n        } else {\n          vals.push(val)\n        }\n      }\n    }\n  }\n\n  function CSSParserRule() {\n    return this\n  }\n  CSSParserRule.prototype.toString = function(indent) {\n    return JSON.stringify(this, null, indent)\n  }\n\n  function Stylesheet() {\n    this.value = new TokenList()\n    return this\n  }\n  Stylesheet.prototype = new CSSParserRule()\n  Stylesheet.prototype.type = 'STYLESHEET'\n  Stylesheet.prototype.toCSSString = function() {\n    return this.value.toCSSString('\\n')\n  }\n\n  function AtRule(name) {\n    this.name = name\n    this.prelude = new TokenList()\n    this.value = null\n    return this\n  }\n  AtRule.prototype = new CSSParserRule()\n  AtRule.prototype.toCSSString = function() {\n    if (this.value) {\n      return (\n        '@' + escapeIdent(this.name) + ' ' + this.prelude.toCSSString() + this.value.toCSSString()\n      )\n    } else {\n      return '@' + escapeIdent(this.name) + ' ' + this.prelude.toCSSString() + '; '\n    }\n  }\n  AtRule.prototype.toStylesheet = function() {\n    return (\n      this.asStylesheet ||\n      (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet())\n    )\n  }\n\n  function StyleRule() {\n    this.prelude = new TokenList()\n    this.selector = this.prelude\n    this.value = null\n    return this\n  }\n  StyleRule.prototype = new CSSParserRule()\n  StyleRule.prototype.type = 'STYLE-RULE'\n  StyleRule.prototype.toCSSString = function() {\n    return this.prelude.toCSSString() + this.value.toCSSString()\n  }\n  StyleRule.prototype.getSelector = function() {\n    return this.prelude\n  }\n  StyleRule.prototype.getDeclarations = function() {\n    if (!(this.value instanceof SimpleBlock)) {\n      return new TokenList()\n    }\n    var value = this.value.value\n    return parseAListOfDeclarations(value)\n  }\n\n  function Declaration(name) {\n    this.name = name\n    this.value = new TokenList()\n    this.important = false\n    return this\n  }\n  Declaration.prototype = new CSSParserRule()\n  Declaration.prototype.type = 'DECLARATION'\n  Declaration.prototype.toCSSString = function() {\n    return this.name + ':' + this.value.toCSSString() + '; '\n  }\n\n  function SimpleBlock(type) {\n    this.name = type\n    this.value = new TokenList()\n    return this\n  }\n  SimpleBlock.prototype = new CSSParserRule()\n  SimpleBlock.prototype.type = 'BLOCK'\n  SimpleBlock.prototype.toCSSString = function() {\n    switch (this.name) {\n      case '(':\n        return '(' + this.value.toCSSString() + ')'\n\n      case '[':\n        return '[' + this.value.toCSSString() + ']'\n\n      case '{':\n        return '{' + this.value.toCSSString() + '}'\n\n      default:\n        //best guess\n        return this.name + this.value.toCSSString() + this.name\n    }\n  }\n\n  function Func(name) {\n    this.name = name\n    this.value = new TokenList()\n    return this\n  }\n  Func.prototype = new CSSParserRule()\n  Func.prototype.type = 'FUNCTION'\n  Func.prototype.toCSSString = function() {\n    return this.name + '(' + this.value.toCSSString() + ')'\n  }\n  Func.prototype.getArguments = function() {\n    var args = new TokenList()\n    var arg = new TokenList()\n    var value = this.value\n    for (var i = 0; i < value.length; i++) {\n      if (value[i].tokenType == ',') {\n        args.push(arg)\n        arg = new TokenList()\n      } else {\n        arg.push(value[i])\n      }\n    }\n    if (args.length > 0 || arg.length > 0) {\n      args.push(arg)\n    }\n    return args\n  }\n\n  function FuncArg() {\n    this.value = new TokenList()\n    return this\n  }\n  FuncArg.prototype = new CSSParserRule()\n  FuncArg.prototype.type = 'FUNCTION-ARG'\n  FuncArg.prototype.toCSSString = function() {\n    return this.value.toCSSString() + ', '\n  }\n\n  // Exportation.\n  cssSyntax.CSSParserRule = CSSParserRule\n  cssSyntax.Stylesheet = Stylesheet\n  cssSyntax.AtRule = AtRule\n  cssSyntax.StyleRule = StyleRule\n  cssSyntax.Declaration = Declaration\n  cssSyntax.SimpleBlock = SimpleBlock\n  cssSyntax.Func = Func\n  cssSyntax.parseAStylesheet = parseAStylesheet\n  cssSyntax.parseAListOfRules = parseAListOfRules\n  cssSyntax.parseARule = parseARule\n  cssSyntax.parseADeclaration = parseADeclaration\n  cssSyntax.parseAListOfDeclarations = parseAListOfDeclarations\n  cssSyntax.parseAComponentValue = parseAComponentValue\n  cssSyntax.parseAListOfComponentValues = parseAListOfComponentValues\n  cssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues\n  cssSyntax.parse = parseAStylesheet\n  cssSyntax.parseCSSValue = parseAListOfComponentValues\n\n  return cssSyntax\n})()\n\nrequire.define('src/core/css-syntax.js');","void (function() {\n  // request animation frame\n  var vendors = ['webkit', 'moz', 'ms', 'o']\n  for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n    var vp = vendors[i]\n    window.requestAnimationFrame = window[vp + 'RequestAnimationFrame']\n    window.cancelAnimationFrame =\n      window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame']\n  }\n  if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\n    // tick every 16ms\n    var listener_index = 0\n    var listeners = []\n    var tmp = []\n    var tick = function() {\n      var now = +new Date()\n      var callbacks = listeners\n      listeners = tmp\n      for (var i = 0; i < callbacks.length; i++) {\n        callbacks[i](now)\n      }\n      listener_index += callbacks.length\n      callbacks.length = 0\n      tmp = callbacks\n      setTimeout(tick, 16)\n    }\n    tick()\n\n    // add a listener\n    window.requestAnimationFrame = function(callback) {\n      return listener_index + listeners.push(callback)\n    }\n\n    // remove a listener\n    window.cancelAnimationFrame = function(index) {\n      index -= listener_index\n      if (index >= 0 && index < listeners.length) {\n        listeners[index] = function() {}\n      }\n    }\n  }\n\n  // setImmediate\n  if (!window.setImmediate) {\n    window.setImmediate = function(f) {\n      return setTimeout(f, 0)\n    }\n    window.cancelImmediate = clearTimeout\n  }\n})()\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                 prerequirements of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\n// TODO: improve event streams\n// - look for a few optimizations ideas in gecko/webkit\n// - use arrays in CompositeEventStream to avoid nested debouncings\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  ///\n  /// event stream implementation\n  /// please note this is required to 'live update' the qSA requests\n  ///\n  function EventStream(connect, disconnect, reconnect) {\n    var self = this\n\n    // validate arguments\n    if (!disconnect) disconnect = function() {}\n    if (!reconnect) reconnect = connect\n\n    // high-level states\n    var isConnected = false\n    var isDisconnected = false\n    var shouldDisconnect = false\n\n    // global variables\n    var callback = null\n    var yieldEvent = function() {\n      // call the callback function, and pend disposal\n      shouldDisconnect = true\n      try {\n        callback && callback(self)\n      } catch (ex) {\n        setImmediate(function() {\n          throw ex\n        })\n      }\n\n      // if no action was taken, dispose\n      if (shouldDisconnect) {\n        dispose()\n      }\n    }\n\n    // export the interface\n    var schedule = (this.schedule = function(newCallback) {\n      // do not allow to schedule on disconnected event streams\n      if (isDisconnected) {\n        throw new Error('Cannot schedule on a disconnected event stream')\n      }\n\n      // do not allow to schedule on already scheduled event streams\n      if (isConnected && !shouldDisconnect) {\n        throw new Error('Cannot schedule on an already-scheduled event stream')\n      }\n\n      // schedule the new callback\n      callback = newCallback\n      shouldDisconnect = false\n\n      // reconnect to the stream\n      if (isConnected) {\n        reconnect(yieldEvent)\n      } else {\n        connect(yieldEvent)\n        isConnected = true\n      }\n    })\n\n    var dispose = (this.dispose = function() {\n      // do not allow to dispose non-connected streams\n      if (isConnected) {\n        // disconnect & save resources\n        disconnect()\n        self = null\n        yieldEvent = null\n        callback = null\n        isConnected = false\n        isDisconnected = true\n        shouldDisconnect = false\n      }\n    })\n  }\n\n  ///\n  /// call a function every frame\n  ///\n  function AnimationFrameEventStream(options) {\n    // flag that says whether the observer is still needed or not\n    var rid = 0\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(yieldEvent) {\n        rid = requestAnimationFrame(yieldEvent)\n      },\n      function disconnect() {\n        cancelAnimationFrame(rid)\n      }\n    )\n  }\n\n  ///\n  /// call a function every timeout\n  ///\n  function TimeoutEventStream(options) {\n    // flag that says whether the observer is still needed or not\n    var rid = 0\n    var timeout =\n      typeof options == 'number' ? +options : 'timeout' in options ? +options.timeout : 333\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(yieldEvent) {\n        rid = setTimeout(yieldEvent, timeout)\n      },\n      function disconnect() {\n        clearTimeout(rid)\n      }\n    )\n  }\n\n  ///\n  /// call a function every time the mouse moves\n  ///\n  function MouseEventStream() {\n    var self = this\n    var pointermove =\n      'PointerEvent' in window\n        ? 'pointermove'\n        : 'MSPointerEvent' in window\n        ? 'MSPointerMove'\n        : 'mousemove'\n\n    // flag that says whether the event is still observed or not\n    var scheduled = false\n    var interval = 0\n\n    // handle the synchronous nature of mutation events\n    var yieldEvent = null\n    var yieldEventDelayed = function() {\n      if (scheduled) return\n      window.removeEventListener(pointermove, yieldEventDelayed, true)\n      scheduled = requestAnimationFrame(yieldEvent)\n    }\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        window.addEventListener(pointermove, yieldEventDelayed, true)\n      },\n      function disconnect() {\n        window.removeEventListener(pointermove, yieldEventDelayed, true)\n        cancelAnimationFrame(scheduled)\n        yieldEventDelayed = null\n        yieldEvent = null\n        scheduled = false\n      },\n      function reconnect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        scheduled = false\n        window.addEventListener(pointermove, yieldEventDelayed, true)\n      }\n    )\n  }\n\n  ///\n  /// call a function every time the mouse is clicked/unclicked\n  ///\n  function MouseButtonEventStream() {\n    var self = this\n    var pointerup =\n      'PointerEvent' in window\n        ? 'pointerup'\n        : 'MSPointerEvent' in window\n        ? 'MSPointerUp'\n        : 'mouseup'\n    var pointerdown =\n      'PointerEvent' in window\n        ? 'pointerdown'\n        : 'MSPointerEvent' in window\n        ? 'MSPointerDown'\n        : 'mousedown'\n\n    // flag that says whether the event is still observed or not\n    var scheduled = false\n    var interval = 0\n\n    // handle the synchronous nature of mutation events\n    var yieldEvent = null\n    var yieldEventDelayed = function() {\n      if (scheduled) return\n      window.removeEventListener(pointerup, yieldEventDelayed, true)\n      window.removeEventListener(pointerdown, yieldEventDelayed, true)\n      scheduled = requestAnimationFrame(yieldEvent)\n    }\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        window.addEventListener(pointerup, yieldEventDelayed, true)\n        window.addEventListener(pointerdown, yieldEventDelayed, true)\n      },\n      function disconnect() {\n        window.removeEventListener(pointerup, yieldEventDelayed, true)\n        window.removeEventListener(pointerdown, yieldEventDelayed, true)\n        cancelAnimationFrame(scheduled)\n        yieldEventDelayed = null\n        yieldEvent = null\n        scheduled = false\n      },\n      function reconnect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        scheduled = false\n        window.addEventListener(pointerup, yieldEventDelayed, true)\n        window.addEventListener(pointerdown, yieldEventDelayed, true)\n      }\n    )\n  }\n\n  ///\n  /// call a function whenever the DOM is modified\n  ///\n  var DOMUpdateEventStream\n  if ('MutationObserver' in window) {\n    DOMUpdateEventStream = function DOMUpdateEventStream(options) {\n      // configuration of the observer\n      if (options) {\n        var target = 'target' in options ? options.target : document.documentElement\n        var config = {\n          subtree: 'subtree' in options ? !!options.subtree : true,\n          attributes: 'attributes' in options ? !!options.attributes : true,\n          childList: 'childList' in options ? !!options.childList : true,\n          characterData: 'characterData' in options ? !!options.characterData : false\n        }\n      } else {\n        var target = document.documentElement\n        var config = {\n          subtree: true,\n          attributes: true,\n          childList: true,\n          characterData: false\n        }\n      }\n\n      // start the event stream\n      var observer = null\n      EventStream.call(\n        this,\n        function connect(yieldEvent) {\n          if (config) {\n            observer = new MutationObserver(yieldEvent)\n            observer.observe(target, config)\n            target = null\n            config = null\n          }\n        },\n        function disconnect() {\n          observer && observer.disconnect()\n          observer = null\n        },\n        function reconnect() {\n          observer.takeRecords()\n        }\n      )\n    }\n  } else if ('MutationEvent' in window) {\n    DOMUpdateEventStream = function DOMUpdateEventStream(options) {\n      var self = this\n\n      // flag that says whether the event is still observed or not\n      var scheduled = false\n\n      // configuration of the observer\n      if (options) {\n        var target = 'target' in options ? options.target : document.documentElement\n      } else {\n        var target = document.documentElement\n      }\n\n      // handle the synchronous nature of mutation events\n      var yieldEvent = null\n      var yieldEventDelayed = function() {\n        if (scheduled || !yieldEventDelayed) return\n        document.removeEventListener('DOMContentLoaded', yieldEventDelayed, false)\n        document.removeEventListener('DOMContentLoaded', yieldEventDelayed, false)\n        target.removeEventListener('DOMSubtreeModified', yieldEventDelayed, false)\n        scheduled = requestAnimationFrame(yieldEvent)\n      }\n\n      // start the event stream\n      EventStream.call(\n        this,\n        function connect(newYieldEvent) {\n          yieldEvent = newYieldEvent\n          document.addEventListener('DOMContentLoaded', yieldEventDelayed, false)\n          target.addEventListener('DOMSubtreeModified', yieldEventDelayed, false)\n        },\n        function disconnect() {\n          document.removeEventListener('DOMContentLoaded', yieldEventDelayed, false)\n          target.removeEventListener('DOMSubtreeModified', yieldEventDelayed, false)\n          cancelAnimationFrame(scheduled)\n          yieldEventDelayed = null\n          yieldEvent = null\n          scheduled = false\n        },\n        function reconnect(newYieldEvent) {\n          yieldEvent = newYieldEvent\n          scheduled = false\n          target.addEventListener('DOMSubtreeModified', yieldEventDelayed, false)\n        }\n      )\n    }\n  } else {\n    DOMUpdateEventStream = AnimationFrameEventStream\n  }\n\n  ///\n  /// call a function every time the focus shifts\n  ///\n  function FocusEventStream() {\n    var self = this\n\n    // handle the filtering nature of focus events\n    var yieldEvent = null\n    var previousActiveElement = null\n    var previousHasFocus = false\n    var rid = 0\n    var yieldEventDelayed = function() {\n      // if the focus didn't change\n      if (\n        previousActiveElement == document.activeElement &&\n        previousHasFocus == document.hasFocus()\n      ) {\n        // then do not generate an event\n        setTimeout(yieldEventDelayed, 333) // focus that didn't move is expected to stay\n      } else {\n        // else, generate one & save config\n        previousActiveElement = document.activeElement\n        previousHasFocus = document.hasFocus()\n        yieldEvent()\n      }\n    }\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        rid = setTimeout(yieldEventDelayed, 500) // let the document load\n      },\n      function disconnect() {\n        clearTimeout(rid)\n        yieldEventDelayed = null\n        yieldEvent = null\n        rid = 0\n      },\n      function reconnect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        rid = setTimeout(yieldEventDelayed, 100) // focus by tab navigation moves fast\n      }\n    )\n  }\n\n  ///\n  /// composite event stream\n  /// because sometimes you need more than one event source\n  ///\n  function CompositeEventStream(stream1, stream2) {\n    var self = this\n\n    // fields\n    var yieldEvent = null\n    var s1 = false,\n      s2 = false\n    var yieldEventWrapper = function(s) {\n      if (s == stream1) s1 = true\n      if (s == stream2) s2 = true\n      if (s1 && s2) return\n      yieldEvent(self)\n    }\n\n    // start the event stream\n    EventStream.call(\n      this,\n      function connect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        stream1.schedule(yieldEventWrapper)\n        stream2.schedule(yieldEventWrapper)\n      },\n      function disconnect() {\n        stream1.dispose()\n        stream2.dispose()\n      },\n      function reconnect(newYieldEvent) {\n        yieldEvent = newYieldEvent\n        s1 && stream1.schedule(yieldEventWrapper)\n        s2 && stream2.schedule(yieldEventWrapper)\n        s1 = s2 = false\n      }\n    )\n  }\n\n  return {\n    EventStream: EventStream,\n    AnimationFrameEventStream: AnimationFrameEventStream,\n    TimeoutEventStream: TimeoutEventStream,\n    MouseEventStream: MouseEventStream,\n    MouseButtonEventStream: MouseButtonEventStream,\n    DOMUpdateEventStream: DOMUpdateEventStream,\n    FocusEventStream: FocusEventStream,\n    CompositeEventStream: CompositeEventStream\n  }\n})(window, document)\n\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                  Implementation of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  // import dependencies\n  var eventStreams = require('src/core/dom-experimental-event-streams.js'),\n    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\n    AnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\n    CompositeEventStream = eventStreams.CompositeEventStream,\n    FocusEventStream = eventStreams.FocusEventStream,\n    MouseButtonEventStream = eventStreams.MouseButtonEventStream,\n    TimeoutEventStream = eventStreams.TimeoutEventStream,\n    MouseEventStream = eventStreams.MouseEventStream\n\n  ///\n  /// the live querySelectorAll implementation\n  ///\n  function querySelectorLive(selector, handler, root) {\n    // restrict the selector coverage to some part of the DOM only\n    var root = root || document\n\n    // TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\n\n    var currentElms = []\n    var loop = function loop(eventStream) {\n      // schedule next run\n      eventStream.schedule(loop)\n\n      // update elements matching the selector\n      var newElms = []\n      var oldElms = currentElms.slice(0)\n      var temps = root.querySelectorAll(selector)\n      for (var i = (newElms.length = temps.length); i; ) {\n        newElms.push(temps[--i])\n      }\n      currentElms = newElms.slice(0)\n      temps = null\n\n      // first let's clear all elements that have been removed from the document\n      oldElms = oldElms.filter(function(e) {\n        // check whether the current element is still there\n        var isStillInDocument =\n          e === document.documentElement || document.documentElement.contains(e)\n\n        if (isStillInDocument) {\n          // NEED_COMPARE: we will compare this element to the new list\n          return true\n        } else {\n          // DELETE: raise onremoved, pop old elements\n          try {\n            handler.onremoved && handler.onremoved(e)\n          } catch (ex) {\n            setImmediate(function() {\n              throw ex\n            })\n          }\n          return false\n        }\n      })\n\n      // now pop and match until both lists are exhausted\n      // (we use the fact the returned elements are in document order)\n      var el1 = oldElms.pop()\n      var el2 = newElms.pop()\n      while (el1 || el2) {\n        if (el1 === el2) {\n          // MATCH: pop both elements\n          el1 = oldElms.pop()\n          el2 = newElms.pop()\n        } else if (\n          el2 &&\n          /*el1 is after el2*/ (!el1 || (el2.compareDocumentPosition(el1) & (1 | 2 | 8 | 32)) === 0)\n        ) {\n          // INSERT: raise onadded, pop new elements\n          try {\n            handler.onadded && handler.onadded(el2)\n          } catch (ex) {\n            setImmediate(function() {\n              throw ex\n            })\n          }\n          el2 = newElms.pop()\n        } else {\n          // DELETE: raise onremoved, pop old elements\n          try {\n            handler.onremoved && handler.onremoved(el1)\n          } catch (ex) {\n            setImmediate(function() {\n              throw ex\n            })\n          }\n          el1 = oldElms.pop()\n        }\n      }\n    }\n\n    // use the event stream that best matches our needs\n    var simpleSelector = selector.replace(\n      /:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,\n      ''\n    )\n    var eventStream\n    if (simpleSelector.indexOf(':') == -1) {\n      // static stuff only\n      eventStream = new DOMUpdateEventStream({ target: root })\n    } else {\n      // dynamic stuff too\n      eventStream = new DOMUpdateEventStream({ target: root })\n      if (DOMUpdateEventStream != AnimationFrameEventStream) {\n        // detect the presence of focus-related pseudo-classes\n        var reg = /:(focus|active)\\b/gi\n        if (reg.test(simpleSelector)) {\n          // mouse events should be listened\n          eventStream = new CompositeEventStream(new FocusEventStream(), eventStream)\n\n          // simplify simpleSelector\n          var reg = /:(focus)\\b/gi\n          simpleSelector = simpleSelector.replace(reg, '') // :active has other hooks\n        }\n\n        // detect the presence of mouse-button-related pseudo-classes\n        var reg = /:(active)\\b/gi\n        if (reg.test(simpleSelector)) {\n          // mouse events should be listened\n          eventStream = new CompositeEventStream(new MouseButtonEventStream(), eventStream)\n\n          // simplify simpleSelector\n          simpleSelector = simpleSelector.replace(reg, '')\n        }\n\n        // detect the presence of user input pseudo-classes\n        var reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi\n        if (reg.test(simpleSelector)) {\n          // slowly dynamic stuff do happen\n          eventStream = new CompositeEventStream(new TimeoutEventStream(250), eventStream)\n\n          // simplify simpleSelector\n          simpleSelector = simpleSelector.replace(reg, '')\n\n          var reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi\n          // simplify simpleSelector\n          simpleSelector = simpleSelector.replace(reg, '')\n        }\n\n        // detect the presence of nearly-static pseudo-classes\n        var reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi\n        if (reg.test(simpleSelector)) {\n          // nearly static stuff do happen\n          eventStream = new CompositeEventStream(new TimeoutEventStream(333), eventStream)\n\n          // simplify simpleSelector\n          simpleSelector = simpleSelector.replace(reg, '')\n        }\n\n        // detect the presence of mouse-related pseudo-classes\n        var reg = /:(hover)\\b/gi\n        if (reg.test(simpleSelector)) {\n          // mouse events should be listened\n          eventStream = new CompositeEventStream(new MouseEventStream(), eventStream)\n\n          // simplify simpleSelector\n          simpleSelector = simpleSelector.replace(reg, '')\n        }\n\n        // detect the presence of unknown pseudo-classes\n        if (simpleSelector.indexOf(':') !== -1) {\n          // other stuff do happen, too (let's give up on events)\n          eventStream = new AnimationFrameEventStream()\n        }\n      }\n    }\n\n    // start handling changes\n    loop(eventStream)\n  }\n\n  return querySelectorLive\n})(window, document)\n\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\n\nmodule.exports = (function(window, document) { \"use strict\";\n\t\n\t// import dependencies\n\trequire('src/core/polyfill-dom-console.js');\n\trequire('src/core/polyfill-dom-requestAnimationFrame.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar querySelectorLive = require('src/core/dom-query-selector-live.js');\n\t\n\t// define the module\n\tvar cssCascade = {\n\t\t\n\t\t//\n\t\t// returns the priority of a unique selector (NO COMMA!)\n\t\t// { the return value is an integer, with the same formula as webkit }\n\t\t//\n\t\tcomputeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\n\t\t\tif(typeof selector == \"string\") selector = cssSyntax.parse(selector.trim()+\"{}\").value[0].selector;\n\t\t\t\n\t\t\tvar numberOfIDs = 0;\n\t\t\tvar numberOfClasses = 0;\n\t\t\tvar numberOfTags = 0;\n\t\t\t\n\t\t\t// TODO: improve this parser, or find one on the web\n\t\t\tfor(var i = 0; i < selector.length; i++) {\n\t\t\t\t\n\t\t\t\tif(selector[i] instanceof cssSyntax.IdentifierToken) {\n\t\t\t\t\tnumberOfTags++;\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.DelimToken) {\n\t\t\t\t\tif(selector[i].value==\".\") {\n\t\t\t\t\t\tnumberOfClasses++; i++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\tif(selector[++i] instanceof cssSyntax.ColonToken) {\n\t\t\t\t\t\tnumberOfTags++; i++;\n\t\t\t\t\t\t\n\t\t\t\t\t} else if((selector[i] instanceof cssSyntax.Func) && (/^(not|matches)$/i).test(selector[i].name)) {\n\t\t\t\t\t\tvar nestedPriority = this.computeSelectorPriorityOf(selector[i].value);\n\t\t\t\t\t\tnumberOfTags += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfClasses += nestedPriority % 256; nestedPriority /= 256;\n\t\t\t\t\t\tnumberOfIDs += nestedPriority;\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.SimpleBlock) {\n\t\t\t\t\tif(selector[i].name==\"[\") {\n\t\t\t\t\t\tnumberOfClasses++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(selector[i] instanceof cssSyntax.HashToken) {\n\t\t\t\t\tnumberOfIDs++;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: stop ignoring unknown symbols?\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(numberOfIDs>255) numberOfIDs=255;\n\t\t\tif(numberOfClasses>255) numberOfClasses=255;\n\t\t\tif(numberOfTags>255) numberOfTags=255;\n\t\t\t\n\t\t\treturn ((numberOfIDs*256)+numberOfClasses)*256+numberOfTags;\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching an element\n\t\t//\n\t\tfindAllMatchingRules: function findAllMatchingRules(element) {\n\t\t\treturn this.findAllMatchingRulesWithPseudo(element);\n\t\t},\n\t\t\n\t\t//\n\t\t// returns an array of the css rules matching a pseudo-element\n\t\t//\n\t\tfindAllMatchingRulesWithPseudo: function findAllMatchingRules(element,pseudo) {\n\t\t\tpseudo = pseudo ? (''+pseudo).toLowerCase() : pseudo;\n\t\t\t\n\t\t\t// let's look for new results if needed...\n\t\t\tvar results = [];\n\t\t\t\n\t\t\t// walk the whole stylesheet...\n\t\t\tvar visit = function(rules) {\n\t\t\t\ttry {\n\t\t\t\t\tfor(var r = rules.length; r--; ) {\n\t\t\t\t\t\tvar rule = rules[r]; \n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rule.disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(rule instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// consider each selector independently\n\t\t\t\t\t\t\tvar subrules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\t\t\t\tfor(var sr = subrules.length; sr--; ) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tvar selector = subrules[sr].selector.toCSSString().replace(/ *(\\/\\*\\*\\/|  ) */g,' ').trim();\n\t\t\t\t\t\t\t\tif(pseudo) {\n\t\t\t\t\t\t\t\t\t// WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\n\t\t\t\t\t\t\t\t\tvar selectorLow = selector.toLowerCase();\n\t\t\t\t\t\t\t\t\tvar newLength = selector.length-pseudo.length-1;\n\t\t\t\t\t\t\t\t\tif(newLength<=0) continue;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tif(selectorLow.lastIndexOf('::'+pseudo)==newLength-1) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength-1);\n\t\t\t\t\t\t\t\t\t} else if(selectorLow.lastIndexOf(':'+pseudo)==newLength) {\n\t\t\t\t\t\t\t\t\t\tselector = selector.substr(0,newLength);\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t// fix selectors like \"#element > :first-child ~ ::before\"\n\t\t\t\t\t\t\t\t\tif(selector.trim().length == 0) { selector = '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == ' ') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '+') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '>') { selector += '*' }\n\t\t\t\t\t\t\t\t\telse if(selector[selector.length-1] == '~') { selector += '*' }\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// look if the selector matches\n\t\t\t\t\t\t\t\tvar isMatching = false;\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tif(element.matches) isMatching=element.matches(selector)\n\t\t\t\t\t\t\t\t\telse if(element.matchesSelector) isMatching=element.matchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.oMatchesSelector) isMatching=element.oMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.msMatchesSelector) isMatching=element.msMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.mozMatchesSelector) isMatching=element.mozMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse if(element.webkitMatchesSelector) isMatching=element.webkitMatchesSelector(selector)\n\t\t\t\t\t\t\t\t\telse { throw new Error(\"no element.matches?\") }\n\t\t\t\t\t\t\t\t} catch(ex) { debugger; setImmediate(function() { throw ex; }) }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if yes, add it to the list of matched selectors\n\t\t\t\t\t\t\t\tif(isMatching) { results.push(subrules[sr]); }\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else if(rule instanceof cssSyntax.AtRule && rule.name==\"media\") {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rule.toStylesheet().value);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (ex) {\n\t\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=cssCascade.stylesheets.length; s--; ) {\n\t\t\t\tvar rules = cssCascade.stylesheets[s];\n\t\t\t\tvisit(rules);\n\t\t\t}\n\t\t\t\n\t\t\treturn results;\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of all properties supported by the current browser\n\t\t//\n\t\tallCSSProperties: null,\n\t\tgetAllCSSProperties: function getAllCSSProperties() {\n\t\t\t\n\t\t\tif(this.allCSSProperties) return this.allCSSProperties;\n\t\t\t\n\t\t\t// get all claimed properties\n\t\t\tvar s = getComputedStyle(document.documentElement); var ps = new Array(s.length);\n\t\t\tfor(var i=s.length; i--; ) {\n\t\t\t\tps[i] = s[i];\n\t\t\t}\n\t\t\t\n\t\t\t// FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\n\t\t\tif(ps.indexOf('content')==-1) {ps.push('content');}\n\t\t\tif(ps.indexOf('counter-reset')==-1) {\n\t\t\t\t\n\t\t\t\tps.push('counter-reset');\n\t\t\t\tps.push('counter-increment');\n\t\t\t\t\n\t\t\t\t// FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\n\t\t\t\tcssCascade.computationUnsafeProperties['counter-reset']=true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// save in a cache for faster access the next times\n\t\t\treturn this.allCSSProperties = ps;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// those properties are not safe for computation->specified round-tripping\n\t\t// \n\t\tcomputationUnsafeProperties: {\n\t\t\t\"bottom\"          : true,\n\t\t\t\"direction\"       : true,\n\t\t\t\"display\"         : true,\n\t\t\t\"font-size\"       : true,\n\t\t\t\"height\"          : true,\n\t\t\t\"left\"            : true,\n\t\t\t\"line-height\"     : true,\n\t\t\t\"margin-left\"     : true,\n\t\t\t\"margin-right\"    : true,\n\t\t\t\"margin-bottom\"   : true,\n\t\t\t\"margin-top\"      : true,\n\t\t\t\"max-height\"      : true,\n\t\t\t\"max-width\"       : true,\n\t\t\t\"min-height\"      : true,\n\t\t\t\"min-width\"       : true,\n\t\t\t\"padding-left\"    : true,\n\t\t\t\"padding-right\"   : true,\n\t\t\t\"padding-bottom\"  : true,\n\t\t\t\"padding-top\"     : true,\n\t\t\t\"right\"           : true,\n\t\t\t\"text-align\"      : true,\n\t\t\t\"text-align-last\" : true,\n\t\t\t\"top\"             : true,\n\t\t\t\"width\"           : true,\n\t\t\t__proto__         : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// a list of property we should inherit...\n\t\t//\n\t\tinheritingProperties: {\n\t\t\t\"border-collapse\"       : true,\n\t\t\t\"border-spacing\"        : true,\n\t\t\t\"caption-side\"          : true,\n\t\t\t\"color\"                 : true,\n\t\t\t\"cursor\"                : true,\n\t\t\t\"direction\"             : true,\n\t\t\t\"empty-cells\"           : true,\n\t\t\t\"font-family\"           : true,\n\t\t\t\"font-size\"             : true,\n\t\t\t\"font-style\"            : true,\n\t\t\t\"font-variant\"          : true,\n\t\t\t\"font-weight\"           : true,\n\t\t\t\"font\"                  : true,\n\t\t\t\"letter-spacing\"        : true,\n\t\t\t\"line-height\"           : true,\n\t\t\t\"list-style-image\"      : true,\n\t\t\t\"list-style-position\"   : true,\n\t\t\t\"list-style-type\"       : true,\n\t\t\t\"list-style\"            : true,\n\t\t\t\"orphans\"               : true,\n\t\t\t\"quotes\"                : true,\n\t\t\t\"text-align\"            : true,\n\t\t\t\"text-indent\"           : true,\n\t\t\t\"text-transform\"        : true,\n\t\t\t\"visibility\"            : true,\n\t\t\t\"white-space\"           : true,\n\t\t\t\"widows\"                : true,\n\t\t\t\"word-break\"            : true,\n\t\t\t\"word-spacing\"          : true,\n\t\t\t\"word-wrap\"             : true,\n\t\t\t__proto__               : null,\n\t\t},\n\t\t\n\t\t//\n\t\t// returns the default style for a tag\n\t\t//\n\t\tdefaultStylesForTag: Object.create ? Object.create(null) : {},\n\t\tgetDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\n\t\t\t\n\t\t\t// get result from cache\n\t\t\tvar result = this.defaultStylesForTag[tagName];\n\t\t\tif(result) return result;\n\t\t\t\n\t\t\t// create dummy virtual element\n\t\t\tvar element = document.createElement(tagName);\n\t\t\tvar style = this.defaultStylesForTag[tagName] = getComputedStyle(element);\n\t\t\tif(style.display) return style;\n\t\t\t\n\t\t\t// webkit fix: insert the dummy element anywhere (head -> display:none)\n\t\t\tdocument.head.insertBefore(element, document.head.firstChild);\n\t\t\treturn style;\n\t\t},\n\t\t\n\t\t// \n\t\t// returns the specified style of an element. \n\t\t// REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\n\t\t// REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\n\t\t// \n\t\tgetSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules) {\n\t\t\t\n\t\t\t// hook for css regions\n\t\t\tvar fragmentSource;\n\t\t\tif(fragmentSource=element.getAttribute('data-css-regions-fragment-of')) {\n\t\t\t\tfragmentSource = document.querySelector('[data-css-regions-fragment-source=\"'+fragmentSource+'\"]');\n\t\t\t\tif(fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName);\n\t\t\t}\n\t\t\t\n\t\t\t// give IE a thumbs up for this!\n\t\t\tif(element.currentStyle && !window.opera) {\n\t\t\t\t\n\t\t\t\t// ask IE to manage the style himself...\n\t\t\t\tvar bestValue = element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName] || '';\n\t\t\t\t\n\t\t\t\t// return a parsed representation of the value\n\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// TODO: support the \"initial\" and \"inherit\" things?\n\t\t\t\t\n\t\t\t\t// first, let's try inline style as it's fast and generally accurate\n\t\t\t\t// TODO: what if important rules override that?\n\t\t\t\ttry {\n\t\t\t\t\tif(bestValue = element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName]) {\n\t\t\t\t\t\treturn cssSyntax.parseAListOfComponentValues(bestValue);\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t\t\n\t\t\t\t// find all relevant style rules\n\t\t\t\tvar isBestImportant=false; var bestPriority = 0; var bestValue = new cssSyntax.TokenList();\n\t\t\t\tvar rules = matchedRules || (\n\t\t\t\t\tcssPropertyName in cssCascade.monitoredProperties\n\t\t\t\t\t? element.myMatchedRules || []\n\t\t\t\t\t: cssCascade.findAllMatchingRules(element)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tvar visit = function(rules) {\n\t\t\t\t\t\n\t\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// media queries hook\n\t\t\t\t\t\tif(rules[i].disabled) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// find a relevant declaration\n\t\t\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\t\t\tif(decls[j].name==cssPropertyName) {\n\t\t\t\t\t\t\t\t\t\t// only works if selectors containing a \",\" are deduplicated\n\t\t\t\t\t\t\t\t\t\tvar currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector);\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tif(isBestImportant) {\n\t\t\t\t\t\t\t\t\t\t\t// only an important declaration can beat another important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t// an important declaration beats any non-important declaration\n\t\t\t\t\t\t\t\t\t\t\tif(decls[j].important) {\n\t\t\t\t\t\t\t\t\t\t\t\tisBestImportant = true;\n\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\t\t// the selector priority has to be higher otherwise\n\t\t\t\t\t\t\t\t\t\t\t\tif(currentPriority >= bestPriority) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestPriority = currentPriority;\n\t\t\t\t\t\t\t\t\t\t\t\t\tbestValue = decls[j].value;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if((rules[i] instanceof cssSyntax.AtRule) && (rules[i].name==\"media\")) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// visit them\n\t\t\t\t\t\t\tvisit(rules[i].toStylesheet())\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tvisit(rules);\n\t\t\t\t\n\t\t\t\t// return our best guess...\n\t\t\t\treturn bestValue||null;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstylesheets: [],\n\t\tloadStyleSheet: function loadStyleSheet(cssText,i) {\n\t\t\t\n\t\t\t// load in order\n\t\t\t\n\t\t\t// parse the stylesheet content\n\t\t\tvar rules = cssSyntax.parse(cssText).value;\n\t\t\t\n\t\t\t// add the stylesheet into the object model\n\t\t\tif(typeof(i)!==\"undefined\") { cssCascade.stylesheets[i]=rules; } \n\t\t\telse { i=cssCascade.stylesheets.push(rules);}\n\t\t\t\n\t\t\t// make sure to monitor the required rules\n\t\t\tcssCascade.startMonitoringStylesheet(rules)\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// start monitoring a new stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tloadStyleSheetTag: function loadStyleSheetTag(stylesheet,i) {\n\t\t\t\n\t\t\tif(stylesheet.hasAttribute('data-css-polyfilled')) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tif(stylesheet.tagName=='LINK') {\n\t\t\t\t\n\t\t\t\t// oh, no, we have to download it...\n\t\t\t\ttry {\n\t\t\t\t\t\n\t\t\t\t\t// dummy value in-between\n\t\t\t\t\tcssCascade.stylesheets[i] = new cssSyntax.TokenList();\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\tvar xhr = new XMLHttpRequest(); xhr.href = stylesheet.href;\n\t\t\t\t\txhr.open('GET',stylesheet.href,true); xhr.ruleIndex = i; \n\t\t\t\t\txhr.onreadystatechange = function() {\n\t\t\t\t\t\tif(this.readyState==4) { \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// status 0 is a webkit bug for local files\n\t\t\t\t\t\t\tif(this.status==200||this.status==0) {\n\t\t\t\t\t\t\t\tcssCascade.loadStyleSheet(this.responseText,this.ruleIndex)\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + this.href);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\txhr.send();\n\t\t\t\t\t\n\t\t\t\t} catch(ex) {\n\t\t\t\t\tcssConsole.log(\"css-cascade polyfill failled to load: \" + stylesheet.href);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// oh, cool, we just have to parse the content!\n\t\t\t\tcssCascade.loadStyleSheet(stylesheet.textContent,i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// mark the stylesheet as ok\n\t\t\tstylesheet.setAttribute('data-css-polyfilled',true);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will load all currently existing stylesheets in the document\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tselectorForStylesheets: \"style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])\",\n\t\tloadAllStyleSheets: function loadAllStyleSheets() {\n\t\t\t\n\t\t\t// for all stylesheets in the <head> tag...\n\t\t\tvar head = document.head || document.documentElement;\n\t\t\tvar stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets);\n\t\t\t\n\t\t\tvar intialLength = this.stylesheets.length;\n\t\t\tthis.stylesheets.length += stylesheets.length\n\t\t\t\n\t\t\t// for all of them...\n\t\t\tfor(var i = stylesheets.length; i--;) {\n\t\t\t\t\n\t\t\t\t// \n\t\t\t\t// load the stylesheet\n\t\t\t\t// \n\t\t\t\tvar stylesheet = stylesheets[i]; \n\t\t\t\tcssCascade.loadStyleSheetTag(stylesheet,intialLength+i)\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// this is where we store event handlers for monitored properties\n\t\t//\n\t\tmonitoredProperties: Object.create ? Object.create(null) : {},\n\t\tmonitoredPropertiesHandler: {\n\t\t\tonupdate: function(element, rule) {\n\t\t\t\t\n\t\t\t\t// we need to find all regexps that matches\n\t\t\t\tvar mps = cssCascade.monitoredProperties;\n\t\t\t\tvar decls = rule.getDeclarations();\n\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\tif(decls[j].name in mps) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// call all handlers waiting for this\n\t\t\t\t\t\t\tvar hs = mps[decls[j].name];\n\t\t\t\t\t\t\tfor(var hi=hs.length; hi--;) {\n\t\t\t\t\t\t\t\ths[hi].onupdate(element,rule);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// don't call twice\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// add an handler to some properties (aka fire when their value *MAY* be affected)\n\t\t// REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\n\t\t//\n\t\tstartMonitoringProperties: function startMonitoringProperties(properties, handler) {\n\t\t\t\n\t\t\tfor(var i=properties.length; i--; ) {\n\t\t\t\tvar property = properties[i];\n\t\t\t\tvar handlers = (\n\t\t\t\t\tcssCascade.monitoredProperties[property]\n\t\t\t\t\t|| (cssCascade.monitoredProperties[property] = [])\n\t\t\t\t);\n\t\t\t\thandlers.push(handler)\n\t\t\t}\n\t\t\t\n\t\t\tfor(var s=0; s<cssCascade.stylesheets.length; s++) {\n\t\t\t\tvar currentStylesheet = cssCascade.stylesheets[s];\n\t\t\t\tcssCascade.startMonitoringStylesheet(currentStylesheet);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect monitored rules in the stylesheet\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringStylesheet: function startMonitoringStylesheet(rules) {\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\t\n\t\t\t\t// only consider style rules\n\t\t\t\tif(rules[i] instanceof cssSyntax.StyleRule) {\n\t\t\t\t\t\n\t\t\t\t\t// try to see if the current rule is worth monitoring\n\t\t\t\t\tif(rules[i].isMonitored) continue;\n\t\t\t\t\t\n\t\t\t\t\t// for that, let's see if we can find a declaration we should watch\n\t\t\t\t\tvar decls = rules[i].getDeclarations();\n\t\t\t\t\tfor(var j=decls.length-1; j>=0; j--) {\n\t\t\t\t\t\tif(decls[j].type==\"DECLARATION\") {\n\t\t\t\t\t\t\tif(decls[j].name in cssCascade.monitoredProperties) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// if we found some, start monitoring\n\t\t\t\t\t\t\t\tcssCascade.startMonitoringRule(rules[i]);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else if(rules[i] instanceof cssSyntax.AtRule) {\n\t\t\t\t\t\n\t\t\t\t\t// handle @media\n\t\t\t\t\tif(rules[i].name == \"media\" && window.matchMedia) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tcssCascade.startMonitoringMedia(rules[i]);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// calling this function will detect media query updates and fire events accordingly\n\t\t// (should usually not be used because stylesheets load automatically)\n\t\t//\n\t\tstartMonitoringMedia: function startMonitoringMedia(atrule) {\n\t\t\ttry {\n\t\t\t\t\n\t\t\t\tvar media = window.matchMedia(atrule.prelude.toCSSString());\n\t\t\t\t\n\t\t\t\t// update all the rules when needed\n\t\t\t\tvar rules = atrule.toStylesheet().value;\n\t\t\t\tcssCascade.updateMedia(rules, !media.matches, false);\n\t\t\t\tmedia.addListener(\n\t\t\t\t\tfunction(newMedia) { cssCascade.updateMedia(rules, !newMedia.matches, true); }\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\t// it seems I like taking risks...\n\t\t\t\tcssCascade.startMonitoringStylesheet(rules);\n\t\t\t\t\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; })\n\t\t\t}\n\t\t},\n\t\t\n\t\t//\n\t\t// define what happens when a media query status changes\n\t\t//\n\t\tupdateMedia: function(rules,disabled,update) {\n\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\trules[i].disabled = disabled;\n\t\t\t\t// TODO: should probably get handled by a setter on the rule...\n\t\t\t\tvar sr = rules[i].subRules;\n\t\t\t\tif(sr) {\n\t\t\t\t\tfor(var j=sr.length; j--; ) {\n\t\t\t\t\t\tsr[j].disabled = disabled;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// in case of update, all elements matching the selector went potentially updated...\n\t\t\tif(update) {\n\t\t\t\tfor(var i=rules.length; i--; ) {\n\t\t\t\t\tvar els = document.querySelectorAll(rules[i].selector.toCSSString());\n\t\t\t\t\tfor(var j=els.length; j--; ) {\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(els[j],rules[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\n\t\t// \n\t\t// splits a rule if it has multiple selectors\n\t\t// \n\t\tsplitRule: function splitRule(rule) {\n\t\t\t\n\t\t\t// create an array for all the subrules\n\t\t\tvar rules = [];\n\t\t\t\n\t\t\t// fill the array\n\t\t\tvar currentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\tfor(var i=0; i<rule.selector.length; i++) {\n\t\t\t\tif(rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value==\",\") {\n\t\t\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\t\tcurrentRule = new cssSyntax.StyleRule(); currentRule.disabled=rule.disabled;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentRule.selector.push(rule.selector[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentRule.value = rule.value; rules.push(currentRule);\n\t\t\t\n\t\t\t// save the result of the split as subrules\n\t\t\treturn rule.subRules = rules;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// ask the css-selector implementation to notify changes for the rules\n\t\t// \n\t\tstartMonitoringRule: function startMonitoringRule(rule) {\n\t\t\t\n\t\t\t// avoid monitoring rules twice\n\t\t\tif(!rule.isMonitored) { rule.isMonitored=true } else { return; }\n\t\t\t\n\t\t\t// split the rule if it has multiple selectors\n\t\t\tvar rules = rule.subRules || cssCascade.splitRule(rule);\n\t\t\t\n\t\t\t// monitor the rules\n\t\t\tfor(var i=0; i<rules.length; i++) {\n\t\t\t\trule = rules[i];\n\t\t\t\tquerySelectorLive(rule.selector.toCSSString(), {\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// add the rule to the matching list of this element\n\t\t\t\t\t\t(e.myMatchedRules = e.myMatchedRules || []).unshift(rule); // TODO: does not respect priority order\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t},\n\t\t\t\t\tonremoved: function(e) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// remove the rule from the matching list of this element\n\t\t\t\t\t\tif(e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1);\n\t\t\t\t\t\t\n\t\t\t\t\t\t// generate an update event\n\t\t\t\t\t\tcssCascade.monitoredPropertiesHandler.onupdate(e, rule);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// converts a css property name to a javascript name\n\t\t//\n\t\ttoCamelCase: function toCamelCase(variable) { \n\t\t\treturn variable.replace(\n\t\t\t\t/-([a-z])/g, \n\t\t\t\tfunction(str,letter) { \n\t\t\t\t\treturn letter.toUpperCase();\n\t\t\t\t}\n\t\t\t);\n\t\t},\n\t\t\n\t\t//\n\t\t// add some magic code to support properties on the style interface\n\t\t//\n\t\tpolyfillStyleInterface: function(cssPropertyName) {\n\t\t\t\n\t\t\tvar prop = {\n\t\t\t\t\n\t\t\t\tget: function() {\n\t\t\t\t\t\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to get polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return ''; }\n\t\t\t\t\t\n\t\t\t\t\ttry { \n\t\t\t\t\t\t// non-computed style: return the local style of the element\n\t\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\t\t\t\t\t\treturn this.parentElement.getAttribute('data-style-'+cssPropertyName);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\t// computed style: return the specified style of the element\n\t\t\t\t\t\tvar value = cssCascade.getSpecifiedStyle(this.parentElement, cssPropertyName, undefined, true);\n\t\t\t\t\t\treturn value && value.length>0 ? value.toCSSString() : '';\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\t\n\t\t\t\tset: function(v) {\n\t\t\t\t\t\n\t\t\t\t\t// check that the style is writable\n\t\t\t\t\tthis.clip = (this.clip===undefined?'':this.clip);\n\n\t\t\t\t\t// check we know which element we work on\n\t\t\t\t\ttry { if(!this.parentElement) throw new Error(\"Please use the anHTMLElement.myStyle property to set polyfilled properties\") }\n\t\t\t\t\tcatch(ex) { setImmediate(function() { throw ex; }); return; }\n\t\t\t\t\t\n\t\t\t\t\t// modify the local style of the element\n\t\t\t\t\tif(this.parentElement.getAttribute('data-style-'+cssPropertyName) != v) {\n\t\t\t\t\t\tthis.parentElement.setAttribute('data-style-'+cssPropertyName,v);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t};\n\t\t\t\n\t\t\tvar styleProtos = [];\n\t\t\ttry { styleProtos.push(Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\n\t\t\t//try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\n\t\t\t\n\t\t\tfor(var i = styleProtos.length; i--;) {\n\t\t\t\tvar styleProto = styleProtos[i];\n\t\t\t\tObject.defineProperty(styleProto,cssPropertyName,prop);\n\t\t\t\tObject.defineProperty(styleProto,cssCascade.toCamelCase(cssPropertyName),prop);\n\t\t\t}\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[style*=\"'+cssPropertyName+'\"]{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\tcssCascade.startMonitoringRule(cssSyntax.parse('[data-style-'+cssPropertyName+']{'+cssPropertyName+':attr(style)}').value[0]);\n\t\t\t\n\t\t\t// add to the list of polyfilled properties...\n\t\t\tcssCascade.getAllCSSProperties().push(cssPropertyName);\n\t\t\tcssCascade.computationUnsafeProperties[cssPropertyName] = true;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\n\t//\n\t// polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\n\t//\n\tdomEvents.EventTarget.implementsIn(cssCascade);\n\tObject.defineProperty(Element.prototype,'myStyle',{\n\t\tget: function() {\n\t\t\tvar style = this.style; \n\t\t\tif(!style.parentElement) style.parentElement = this;\n\t\t\treturn style;\n\t\t}\n\t});\n\n\t//\n\t// load all stylesheets at the time the script is loaded\n\t// then do it again when all stylesheets are downloaded\n\t// and again if some style tag is added to the DOM\n\t//\n\tif(!(\"no_auto_stylesheet_detection\" in window)) {\n\t\t\n\t\tcssCascade.loadAllStyleSheets();\n\t\tdocument.addEventListener(\"DOMContentLoaded\", function() {\n\t\t\tcssCascade.loadAllStyleSheets();\n\t\t\tquerySelectorLive(\n\t\t\t\tcssCascade.selectorForStylesheets,\n\t\t\t\t{\n\t\t\t\t\tonadded: function(e) {\n\t\t\t\t\t\t// TODO: respect DOM order?\n\t\t\t\t\t\tcssCascade.loadStyleSheetTag(e);\n\t\t\t\t\t\tcssCascade.dispatchEvent('stylesheetadded');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t)\n\t\t})\n\t}\n\t\n\treturn cssCascade;\n\n})(window, document);\n\nrequire.define('src/core/css-cascade.js');","module.exports = (function(window, document) {\n  'use strict'\n\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n\n  var cssBreak = {\n    //\n    // returns true if an element is replaced\n    // (can't be broken because considered as an image in css layout)\n    //\n    isReplacedElement: function isReplacedElement(element) {\n      if (!(element instanceof Element)) return false\n      var replacedElementTags = /^(SVG|MATH|IMG|VIDEO|PICTURE|OBJECT|EMBED|IFRAME|TEXTAREA|BUTTON|INPUT)$/ // TODO: more\n      return replacedElementTags.test(element.tagName)\n    },\n\n    //\n    // returns true if an element has a scrollbar or act on overflowing content\n    //\n    isScrollable: function isScrollable(element, elementOverflow) {\n      if (!(element instanceof Element)) return false\n      if (typeof elementOverflow == 'undefined')\n        elementOverflow = getComputedStyle(element).overflow\n\n      return elementOverflow !== 'visible' && elementOverflow !== 'hidden'\n    },\n\n    //\n    // returns true if the element is part of an inline flow\n    // TextNodes definitely qualify, but also inline-block elements\n    //\n    isSingleLineOfTextComponent: function(\n      element,\n      elementStyle,\n      elementDisplay,\n      elementPosition,\n      isReplaced\n    ) {\n      if (!(element instanceof Element)) return true\n      if (typeof elementStyle == 'undefined') elementStyle = getComputedStyle(element)\n      if (typeof elementDisplay == 'undefined') elementDisplay = elementStyle.display\n      if (typeof elementPosition == 'undefined') elementPosition = elementStyle.position\n      if (typeof isReplaced == 'undefined') isReplaced = this.isReplacedElement(element)\n\n      return (\n        (elementDisplay === 'inline-block' ||\n          elementDisplay === 'inline-table' ||\n          elementDisplay === 'inline-flex' ||\n          elementDisplay === 'inline-grid') &&\n        // TODO: more\n        (elementPosition === 'static' || elementPosition === 'relative')\n      )\n    },\n\n    //\n    // returns true if the element is part of an inline flow\n    // TextNodes definitely qualify, but also inline-block elements\n    //\n    hasAnyInlineFlow: function(element) {\n      function countAsInline(element) {\n        if (!(element instanceof Element)) return !/^\\s*$/.test(element.nodeValue)\n        return (\n          !cssBreak.isOutOfFlowElement(element) && cssBreak.isSingleLineOfTextComponent(element)\n        )\n      }\n\n      // try to find any inline element\n      var current = element.firstChild\n      while (current) {\n        if (countAsInline(current)) return true\n        current = current.nextSibling\n      }\n\n      // no inline element\n      return false\n    },\n\n    //\n    // returns true if the element breaks the inline flow\n    // (the case of block elements, mostly)\n    //\n    isLineBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n      if (!(element instanceof Element)) return false\n      if (typeof elementStyle == 'undefined') elementStyle = getComputedStyle(element)\n      if (typeof elementDisplay == 'undefined') elementDisplay = elementStyle.display\n      if (typeof elementPosition == 'undefined') elementPosition = elementStyle.position\n\n      return (\n        // in-flow bock elements\n        (elementDisplay === 'block' &&\n          !this.isOutOfFlowElement(element, elementStyle, elementDisplay, elementPosition)) ||\n        // displayed <br> elements\n        (element.tagName === 'BR' && elementDisplay !== 'none')\n      )\n    },\n\n    //\n    // returns true if the element breaks the inline flow before him\n    // (the case of block elements, mostly)\n    //\n    isLinePreBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n      if (!(element instanceof Element)) return false\n\n      var breakBefore = cssCascade.getSpecifiedStyle(element, 'break-before').toCSSString()\n      return (\n        breakBefore == 'region' ||\n        breakBefore == 'all' ||\n        cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n      )\n    },\n\n    //\n    // returns true if the element breaks the inline flow after him\n    // (the case of block elements, mostly)\n    //\n    isLinePostBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n      if (!(element instanceof Element)) return false\n\n      var breakAfter = cssCascade.getSpecifiedStyle(element, 'break-after').toCSSString()\n      return (\n        breakAfter == 'region' ||\n        breakAfter == 'all' ||\n        cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n      )\n    },\n\n    //\n    // returns true if the element is outside any block/inline flow\n    // (this the case of absolutely positioned elements, and floats)\n    //\n    isOutOfFlowElement: function(\n      element,\n      elementStyle,\n      elementDisplay,\n      elementPosition,\n      elementFloat\n    ) {\n      if (!(element instanceof Element)) return false\n      if (typeof elementStyle == 'undefined') elementStyle = getComputedStyle(element)\n      if (typeof elementDisplay == 'undefined') elementDisplay = elementStyle.display\n      if (typeof elementPosition == 'undefined') elementPosition = elementStyle.position\n      if (typeof elementFloat == 'undefined')\n        elementFloat = elementStyle.float || elementStyle.styleFloat || elementStyle.cssFloat\n\n      return (\n        // positioned elements are out of the flow\n        elementPosition === 'absolute' ||\n        elementPosition === 'fixed' ||\n        // floated elements as well\n        elementFloat !== 'none' ||\n        // not sure but let's say hidden elements as well\n        elementDisplay === 'none'\n      )\n    },\n\n    //\n    // returns true if two sibling elements are in the same text line\n    // (this function is not perfect, work with it with care)\n    //\n    areInSameSingleLine: function areInSameSingleLine(element1, element2) {\n      //\n      // look for obvious reasons why it wouldn't be the case\n      //\n\n      // if the element are not direct sibling, we must use their inner siblings as well\n      if (element1.nextSibling != element2) {\n        if (element2.nextSibling != element1) throw 'I gave up!'\n        var t = element1\n        element1 = element2\n        element2 = t\n      }\n\n      // a block element is never on the same line as another element\n      if (this.isLinePostBreakingElement(element1)) return false\n      if (this.isLinePreBreakingElement(element2)) return false\n\n      // if the previous element is out of flow, we may consider it as being part of the current line\n      if (this.isOutOfFlowElement(element1)) return true\n\n      // if the current object is not a single line component, return false\n      if (!this.isSingleLineOfTextComponent(element1)) return false\n\n      //\n      // compute the in-flow bounding rect of the two elements\n      //\n      var element1box = Node.getBoundingClientRect(element1)\n      var element2box = Node.getBoundingClientRect(element2)\n      function shift(box, shiftX, shiftY) {\n        return {\n          top: box.top + shiftY,\n          bottom: box.bottom + shiftY,\n          left: box.left + shiftX,\n          right: box.right + shiftX\n        }\n      }\n\n      // we only need to shift elements\n      if (element1 instanceof Element) {\n        var element1Style = getComputedStyle(element1)\n        element1box = shift(\n          element1box,\n          parseFloat(element1Style.marginLeft),\n          parseFloat(element1Style.marginTop)\n        )\n        if (element1Style.position == 'relative') {\n          element1box = shift(\n            element1box,\n            parseFloat(element1Style.left),\n            parseFloat(element1Style.top)\n          )\n        }\n      }\n\n      // we only need to shift elements\n      if (element2 instanceof Element) {\n        var element2Style = getComputedStyle(element2)\n        element2box = shift(\n          element2box,\n          parseFloat(element2Style.marginLeft),\n          parseFloat(element2Style.marginTop)\n        )\n        if (element2Style.position == 'relative') {\n          element2box = shift(\n            element2box,\n            parseFloat(element2Style.left),\n            parseFloat(element2Style.top)\n          )\n        }\n      }\n\n      // order the nodes so that they are in left-to-right order\n      // (this means invert their order in the case of right-to-left flow)\n      var firstElement =\n        getComputedStyle(element1.parentNode).direction == 'rtl' ? element2box : element1box\n      var secondElement =\n        getComputedStyle(element1.parentNode).direction == 'rtl' ? element1box : element2box\n\n      // return true if both elements are have non-overlapping\n      // margin- and position-corrected in-flow bounding rect\n      // and if their relative position is the one of the current\n      // flow (either rtl or ltr)\n      return firstElement.right <= secondElement.left\n\n      // TODO: what about left-to-right + right-aligned text?\n      // I should probably takes care of vertical position in this case to solve ambiguities\n    },\n\n    //\n    // returns true if the element has \"overflow: hidden\" set on it, and actually overflows\n    //\n    isHiddenOverflowing: function isHiddenOverflowing(element, elementOverflow) {\n      if (!(element instanceof Element)) return false\n      if (typeof elementOverflow == 'undefined') elementOverflow = getComputedStyle(element).display\n\n      return (\n        elementOverflow == 'hidden' && element.offsetHeight != element.scrollHeight // trust me that works\n      )\n    },\n\n    //\n    // returns true if the element has a border-radius that impacts his layout\n    //\n    hasBigRadius: function(element, elementStyle) {\n      if (!(element instanceof Element)) return false\n      if (typeof elementStyle == 'undefined') elementStyle = getComputedStyle(element)\n\n      // if the browser supports radiuses {f### prefixes}\n      if ('borderTopLeftRadius' in elementStyle) {\n        var tlRadius = parseFloat(elementStyle.borderTopLeftRadius)\n        var trRadius = parseFloat(elementStyle.borderTopRightRadius)\n        var blRadius = parseFloat(elementStyle.borderBottomLeftRadius)\n        var brRadius = parseFloat(elementStyle.borderBottomRightRadius)\n\n        // tiny radiuses (<15px) are tolerated anyway\n        if (tlRadius < 15 && trRadius < 15 && blRadius < 15 && brRadius < 15) {\n          return false\n        }\n\n        var tWidth = parseFloat(elementStyle.borderTopWidth)\n        var bWidth = parseFloat(elementStyle.borderBottomWidth)\n        var lWidth = parseFloat(elementStyle.borderLeftWidth)\n        var rWidth = parseFloat(elementStyle.borderRightWidth)\n\n        // make sure the radius itself is contained into the border\n\n        if (tlRadius > tWidth) return true\n        if (tlRadius > lWidth) return true\n\n        if (trRadius > tWidth) return true\n        if (trRadius > rWidth) return true\n\n        if (blRadius > bWidth) return true\n        if (blRadius > lWidth) return true\n\n        if (brRadius > bWidth) return true\n        if (brRadius > rWidth) return true\n      }\n\n      // all conditions were met\n      return false\n    },\n\n    //\n    // return trus if the break-inside property is 'avoid' or 'avoid-region'\n    //\n    isBreakInsideAvoid: function isBreakInsideAvoid(element, elementStyle) {\n      var breakInside = cssCascade\n        .getSpecifiedStyle(element, 'break-inside', undefined, true)\n        .toCSSString()\n        .trim()\n        .toLowerCase()\n      return breakInside == 'avoid' || breakInside == 'avoid-region'\n    },\n\n    //\n    // returns true if the element is unbreakable according to the spec\n    // (and some of the expected limitations of HTML/CSS)\n    //\n    isMonolithic: function isMonolithic(element) {\n      if (!(element instanceof Element)) return false\n\n      var elementStyle = getComputedStyle(element)\n      var elementOverflow = elementStyle.overflow\n      var elementDisplay = elementStyle.display\n\n      // Some content is not fragmentable, for example:\n      // - many types of replaced elements (such as images or video)\n\n      var isReplaced = this.isReplacedElement(element)\n\n      // - scrollable elements\n\n      var isScrollable = this.isScrollable(element, elementOverflow)\n\n      // - a single line of text content.\n\n      var isSingleLineOfText = this.isSingleLineOfTextComponent(\n        element,\n        elementStyle,\n        elementDisplay,\n        undefined,\n        isReplaced\n      )\n\n      // Such content is considered monolithic: it contains no\n      // possible break points.\n\n      // In addition to any content which is not fragmentable,\n      // UAs may consider as monolithic:\n      // - any elements with ‘overflow’ set to ‘auto’ or ‘scroll’\n      // - any elements with ‘overflow: hidden’ and a non-‘auto’ logical height (and no specified maximum logical height).\n\n      var isHiddenOverflowing = this.isHiddenOverflowing(element, elementOverflow)\n\n      // ADDITION TO THE SPEC:\n      // I don't want to handle the case where\n      // an element has a border-radius that is bigger\n      // than the border-width to which it belongs\n      var hasBigRadius = this.hasBigRadius(element, elementStyle)\n\n      // ADDITION TO THE SPEC:\n      // Someone proposed to support \"break-inside: avoid\" here\n      var isBreakInsideAvoid = this.isBreakInsideAvoid(element, elementStyle)\n\n      // all of them are monolithic\n      return (\n        isReplaced ||\n        isScrollable ||\n        isSingleLineOfText ||\n        isHiddenOverflowing ||\n        hasBigRadius ||\n        isBreakInsideAvoid\n      )\n    },\n\n    //\n    // returns true if \"r\" is a collapsed range located at a possible break point for \"region\"\n    // (this function does all the magic for you, but you may want to avoid using it too much)\n    //\n    isPossibleBreakPoint: function isPossibleBreakPoint(r, region) {\n      // r has to be a range, and be collapsed\n      if (!(r instanceof Range)) return false\n      if (!r.collapsed) return false\n\n      // no ancestor up to the region has to be monolithic\n      var ancestor = r.startContainer\n      while (ancestor && ancestor !== region) {\n        if (cssBreak.isMonolithic(ancestor)) {\n          return false\n        }\n        ancestor = ancestor.parentNode\n      }\n\n      // we also have to check that we're not between two single-line-of-text elements\n      // that are actually on the same line (in which case you can't break)\n      var ancestor = r.startContainer\n      var lastAncestor = r.startContainer.childNodes[r.startOffset]\n      while (ancestor && lastAncestor !== region) {\n        if (lastAncestor && lastAncestor.previousSibling) {\n          if (this.areInSameSingleLine(lastAncestor, lastAncestor.previousSibling)) {\n            return false\n          }\n        }\n\n        lastAncestor = ancestor\n        ancestor = ancestor.parentNode\n      }\n\n      // there are some very specific conditions for breaking\n      // at the edge of an element:\n\n      if (r.startOffset == 0) {\n        // Class 3 breaking point:\n        // ========================\n        // Between the content edge of a block container box\n        // and the outer edges of its child content (margin\n        // edges of block-level children or line box edges\n        // for inline-level children) if there is a (non-zero)\n        // gap between them.\n\n        var firstChild = r.startContainer.childNodes[0]\n        if (firstChild) {\n          var firstChildBox = Node.getBoundingClientRect(firstChild)\n\n          var parentBox = r.startContainer.getBoundingClientRect()\n\n          if (firstChildBox.top == parentBox.top) {\n            return false\n          }\n        } else {\n          return false\n        }\n      }\n\n      // all conditions are met!\n      return true\n    }\n  }\n\n  return cssBreak\n})(window, document)\n\nrequire.define('src/core/css-break.js');","'use strict'\n\n//\n// start by polyfilling caretRangeFromPoint\n//\n\nif (!document.caretRangeFromPoint) {\n  if (document.caretPositionFromPoint) {\n    document.caretRangeFromPoint = function caretRangeFromPoint(x, y) {\n      var r = document.createRange()\n      var p = document.caretPositionFromPoint(x, y)\n      if (p.offsetNode) {\n        r.setStart(p.offsetNode, p.offset)\n        r.setEnd(p.offsetNode, p.offset)\n      }\n      return r\n    }\n  } else if ((document.body || document.createElement('body')).createTextRange) {\n    //\n    // we may want to convert TextRange to Range\n    //\n\n    var TextRangeUtils = {\n      convertToDOMRange: function(textRange, document) {\n        var adoptBoundary = function(domRange, textRangeInner, bStart) {\n          // iterate backwards through parent element to find anchor location\n          var cursorNode = document.createElement('a'),\n            cursor = textRangeInner.duplicate()\n          cursor.collapse(bStart)\n          var parent = cursor.parentElement()\n          do {\n            parent.insertBefore(cursorNode, cursorNode.previousSibling)\n            cursor.moveToElementText(cursorNode)\n          } while (\n            cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) > 0 &&\n            cursorNode.previousSibling\n          )\n\n          // when we exceed or meet the cursor, we've found the node\n          if (\n            cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) == -1 &&\n            cursorNode.nextSibling\n          ) {\n            // data node\n            cursor.setEndPoint(bStart ? 'EndToStart' : 'EndToEnd', textRangeInner)\n            domRange[bStart ? 'setStart' : 'setEnd'](cursorNode.nextSibling, cursor.text.length)\n          } else {\n            // element\n            domRange[bStart ? 'setStartBefore' : 'setEndBefore'](cursorNode)\n          }\n          cursorNode.parentNode.removeChild(cursorNode)\n        }\n\n        // validate arguments\n        if (!document) {\n          document = window.document\n        }\n\n        // return a DOM range\n        var domRange = document.createRange()\n        adoptBoundary(domRange, textRange, true)\n        adoptBoundary(domRange, textRange, false)\n        return domRange\n      },\n\n      convertFromDOMRange: function(domRange) {\n        var adoptEndPoint = function(textRange, domRangeInner, bStart) {\n          // find anchor node and offset\n          var container = domRangeInner[bStart ? 'startContainer' : 'endContainer']\n          var offset = domRangeInner[bStart ? 'startOffset' : 'endOffset'],\n            textOffset = 0\n          var anchorNode = DOMUtils.isDataNode(container) ? container : container.childNodes[offset]\n          var anchorParent = DOMUtils.isDataNode(container) ? container.parentNode : container\n          // visible data nodes need a text offset\n          if (container.nodeType == 3 || container.nodeType == 4) textOffset = offset\n\n          // create a cursor element node to position range (since we can't select text nodes)\n          var cursorNode = domRangeInner._document.createElement('a')\n          anchorParent.insertBefore(cursorNode, anchorNode)\n          var cursor = domRangeInner._document.body.createTextRange()\n          cursor.moveToElementText(cursorNode)\n          cursorNode.parentNode.removeChild(cursorNode)\n          // move range\n          textRange.setEndPoint(bStart ? 'StartToStart' : 'EndToStart', cursor)\n          textRange[bStart ? 'moveStart' : 'moveEnd']('character', textOffset)\n        }\n\n        // return an IE text range\n        var textRange = domRange._document.body.createTextRange()\n        adoptEndPoint(textRange, domRange, true)\n        adoptEndPoint(textRange, domRange, false)\n        return textRange\n      }\n    }\n\n    document.caretRangeFromPoint = function caretRangeFromPoint(x, y) {\n      // the accepted number of vertical backtracking, in CSS pixels\n      var IYDepth = 40\n\n      // try to create a text range at the specified location\n      var r = document.body.createTextRange()\n      for (var iy = IYDepth; iy; iy = iy - 4) {\n        var ix = x\n        if (true) {\n          try {\n            r.moveToPoint(ix, iy + y - IYDepth)\n            return TextRangeUtils.convertToDOMRange(r)\n          } catch (ex) {}\n        }\n      }\n\n      // if that fails, return the location just after the element located there\n      try {\n        var elem = document.elementFromPoint(x - 1, y - 1)\n        var r = document.createRange()\n        r.setStartAfter(elem)\n        return r\n      } catch (ex) {\n        return null\n      }\n    }\n  }\n}\n\n///\n/// helper function for moving ranges char by char\n///\n\nRange.prototype.myMoveOneCharLeft = function() {\n  var r = this\n\n  // move to the previous cursor location\n  if (r.endOffset > 0) {\n    // if we can enter into the previous sibling\n    var previousSibling = r.endContainer.childNodes[r.endOffset - 1]\n    if (previousSibling && previousSibling.lastChild) {\n      // enter the previous sibling from its end\n      r.setEndAfter(previousSibling.lastChild)\n    } else if (previousSibling && previousSibling.nodeType == previousSibling.TEXT_NODE) {\n      // todo: lookup value\n\n      // enter the previous text node from its end\n      r.setEnd(previousSibling, previousSibling.nodeValue.length)\n    } else {\n      // else move before that element\n      r.setEnd(r.endContainer, r.endOffset - 1)\n    }\n  } else {\n    r.setEndBefore(r.endContainer)\n  }\n}\n\nRange.prototype.myMoveOneCharRight = function() {\n  var r = this\n\n  // move to the previous cursor location\n  var max =\n    r.startContainer.nodeType == r.startContainer.TEXT_NODE\n      ? r.startContainer.nodeValue.length\n      : r.startContainer.childNodes.length\n  if (r.startOffset < max) {\n    // if we can enter into the next sibling\n    var nextSibling = r.endContainer.childNodes[r.endOffset]\n    if (nextSibling && nextSibling.firstChild) {\n      // enter the next sibling from its start\n      r.setStartBefore(nextSibling.firstChild)\n    } else if (\n      nextSibling &&\n      nextSibling.nodeType == nextSibling.TEXT_NODE &&\n      nextSibling.nodeValue != ''\n    ) {\n      // todo: lookup value\n\n      // enter the next text node from its start\n      r.setStart(nextSibling, 0)\n    } else {\n      // else move before that element\n      r.setStart(r.startContainer, r.startOffset + 1)\n    }\n  } else {\n    r.setStartAfter(r.endContainer)\n  }\n\n  // shouldn't be needed but who knows...\n  r.setEnd(r.startContainer, r.startOffset)\n}\n\n///\n/// This functions is optimized to not yield inside a word in a text node\n///\nRange.prototype.myMoveTowardRight = function() {\n  var r = this\n\n  // move to the previous cursor location\n  var isTextNode = r.startContainer.nodeType == r.startContainer.TEXT_NODE\n  var max = isTextNode ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length\n  if (r.startOffset < max) {\n    // if we can enter into the next sibling\n    var nextSibling = r.endContainer.childNodes[r.endOffset]\n    if (nextSibling && nextSibling.firstChild) {\n      // enter the next sibling from its start\n      r.setStartBefore(nextSibling.firstChild)\n    } else if (\n      nextSibling &&\n      nextSibling.nodeType == nextSibling.TEXT_NODE &&\n      nextSibling.nodeValue != ''\n    ) {\n      // todo: lookup value\n\n      // enter the next text node from its start\n      r.setStart(nextSibling, 0)\n    } else if (isTextNode) {\n      // move to the next non a-zA-Z symbol\n      var currentText = r.startContainer.nodeValue\n      var currentOffset = r.startOffset\n      var currentLetter = currentText[currentOffset++]\n      while (currentOffset < max && /^\\w$/.test(currentLetter)) {\n        currentLetter = currentText[currentOffset++]\n      }\n      r.setStart(r.startContainer, currentOffset)\n    } else {\n      // else move after that element\n      r.setStart(r.startContainer, r.startOffset + 1)\n    }\n  } else {\n    r.setStartAfter(r.endContainer)\n  }\n\n  // shouldn't be needed but who knows...\n  r.setEnd(r.startContainer, r.startOffset)\n}\n\nRange.prototype.myMoveEndOneCharLeft = function() {\n  var r = this\n\n  // move to the previous cursor location\n  if (r.endOffset > 0) {\n    // if we can enter into the previous sibling\n    var previousSibling = r.endContainer.childNodes[r.endOffset - 1]\n    if (previousSibling && previousSibling.lastChild) {\n      // enter the previous sibling from its end\n      r.setEndAfter(previousSibling.lastChild)\n    } else if (previousSibling && previousSibling.nodeType == previousSibling.TEXT_NODE) {\n      // todo: lookup value\n\n      // enter the previous text node from its end\n      r.setEnd(previousSibling, previousSibling.nodeValue.length)\n    } else {\n      // else move before that element\n      r.setEnd(r.endContainer, r.endOffset - 1)\n    }\n  } else {\n    r.setEndBefore(r.endContainer)\n  }\n}\n\nRange.prototype.myMoveEndOneCharRight = function() {\n  var r = this\n\n  // move to the previous cursor location\n  var max =\n    r.endContainer.nodeType == r.endContainer.TEXT_NODE\n      ? r.endContainer.nodeValue.length\n      : r.endContainer.childNodes.length\n  if (r.endOffset < max) {\n    // if we can enter into the next sibling\n    var nextSibling = r.endContainer.childNodes[r.endOffset]\n    if (nextSibling && nextSibling.firstChild) {\n      // enter the next sibling from its start\n      r.setEndBefore(nextSibling.firstChild)\n    } else if (nextSibling && nextSibling.nodeType == nextSibling.TEXT_NODE) {\n      // todo: lookup value\n\n      // enter the next text node from its start\n      r.setEnd(nextSibling, 0)\n    } else {\n      // else move before that element\n      r.setEnd(r.endContainer, r.endOffset + 1)\n    }\n  } else {\n    r.setEndAfter(r.endContainer)\n  }\n}\n\n//\n// Get the *real* bounding client rect of the range\n// { therefore we need to fix some browser bugs... }\n//\nRange.prototype.myGetSelectionRect = function() {\n  // get the browser's claimed rect\n  var rect = this.getBoundingClientRect()\n\n  // HACK FOR ANDROID BROWSER AND OLD WEBKIT\n  if (!rect) {\n    rect = { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }\n  }\n\n  // if the value seems wrong... (some browsers don't like collapsed selections)\n  if (this.collapsed && rect.top === 0 && rect.bottom === 0) {\n    // select one char and infer location\n    var clone = this.cloneRange()\n    var collapseToLeft = false\n    clone.collapse(false)\n\n    // the case where no char before is tricky...\n    if (clone.startOffset == 0) {\n      // let's move on char to the right\n      clone.myMoveTowardRight()\n      collapseToLeft = true\n\n      // note: some browsers don't like selections\n      // that spans multiple containers, so we will\n      // iterate this process until we have one true\n      // char selected\n      clone.setStart(clone.endContainer, 0)\n    } else {\n      // else, just select the char before\n      clone.setStart(this.startContainer, this.startOffset - 1)\n      collapseToLeft = false\n    }\n\n    // get some real rect\n    var rect = clone.myGetSelectionRect()\n\n    // compute final value\n    if (collapseToLeft) {\n      return {\n        left: rect.left,\n        right: rect.left,\n        width: 0,\n\n        top: rect.top,\n        bottom: rect.bottom,\n        height: rect.height\n      }\n    } else {\n      return {\n        left: rect.right,\n        right: rect.right,\n        width: 0,\n\n        top: rect.top,\n        bottom: rect.bottom,\n        height: rect.height\n      }\n    }\n  } else {\n    return rect\n  }\n}\n\n// not sure it's needed but still\nif (!window.Element) window.Element = window.HTMLElement\nif (!window.Node) window.Node = {}\n\n// make getBCR working on text nodes & stuff\nNode.getBoundingClientRect = function getBoundingClientRect(element) {\n  if (element.getBoundingClientRect) {\n    var rect = element.getBoundingClientRect()\n  } else {\n    var range = document.createRange()\n    range.selectNode(element)\n\n    var rect = range.getBoundingClientRect()\n  }\n\n  // HACK FOR ANDROID BROWSER AND OLD WEBKIT\n  if (!rect) {\n    rect = { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 }\n  }\n\n  return rect\n}\n\n// make getCR working on text nodes & stuff\nNode.getClientRects = function getClientRects(firstChild) {\n  if (firstChild.getBoundingClientRect) {\n    return firstChild.getClientRects()\n  } else {\n    var range = document.createRange()\n    range.selectNode(firstChild)\n\n    return range.getClientRects()\n  }\n}\n\n// fix for IE (contains fails for text nodes...)\nNode.contains = function contains(parentNode, node) {\n  if (node.nodeType != 1) {\n    if (!node.parentNode) return false\n    return node.parentNode == parentNode || parentNode.contains(node.parentNode)\n  } else {\n    return parentNode.contains(node)\n  }\n}\n\n//\n// get the bounding rect of the selection, including the bottom padding/marging of the previous element if required\n// { this is a special version for breaking algorithms that do not want to miss the previous element real size }\n//\nRange.prototype.myGetExtensionRect = function() {\n  // this function returns the selection rect\n  // but does take care of taking in account\n  // the bottom-{padding/border} of the previous\n  // sibling element, to detect overflow points\n  // more accurately\n\n  var rect = this.myGetSelectionRect()\n  var previousSibling = this.endContainer.childNodes[this.endOffset - 1]\n  if (previousSibling) {\n    // correct with the new take\n    var prevSibRect = Node.getBoundingClientRect(previousSibling)\n    var adjustedBottom = Math.max(rect.bottom, prevSibRect.bottom)\n    if (adjustedBottom == rect.bottom) return rect\n    return {\n      left: rect.left,\n      right: rect.right,\n      width: rect.width,\n\n      top: rect.top,\n      bottom: adjustedBottom,\n      height: adjustedBottom - rect.top\n    }\n  } else if (rect.bottom == 0 && this.endContainer.nodeType === 3) {\n    // note that if we are in a text node,\n    // we may want to cover all the previous\n    // text in the node to avoid whitespace\n    // related bugs\n\n    var onlyWhiteSpaceBefore = /^(\\s|\\n)*$/.test(\n      this.endContainer.nodeValue.substr(0, this.endOffset)\n    )\n    if (onlyWhiteSpaceBefore) {\n      // if we are in the fucking whitespace land, return first line\n      var prevSibRect = Node.getClientRects(this.endContainer)[0]\n      return prevSibRect\n    } else {\n      // otherwhise, let's rely on previous chars\n      var auxiliaryRange = this.cloneRange()\n      auxiliaryRange.setStart(this.endContainer, 0)\n\n      // correct with the new take\n      var prevSibRect = auxiliaryRange.getBoundingClientRect()\n      var adjustedBottom = Math.max(rect.bottom, prevSibRect.bottom)\n      return {\n        left: rect.left,\n        right: rect.right,\n        width: rect.width,\n\n        top: rect.top,\n        bottom: adjustedBottom,\n        height: adjustedBottom - rect.top\n      }\n    }\n  } else {\n    return rect\n  }\n}\n\nrequire.define('src/css-regions/lib/range-extensions.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  var domEvents = require('src/core/dom-events.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n  var cssBreak = require('src/core/css-break.js')\n\n  var cssRegionsHelpers = (window.cssRegionsHelpers = {\n    //\n    // returns the previous sibling of the element\n    // or the previous sibling of its nearest ancestor that has one\n    //\n    getAllLevelPreviousSibling: function(e, region) {\n      if (!e || e == region) return null\n\n      // find the nearest ancestor that has a previous sibling\n      while (!e.previousSibling) {\n        // but bubble to the next avail ancestor\n        e = e.parentNode\n\n        // dont get over the bar\n        if (!e || e == region) return null\n      }\n\n      // return that sibling\n      return e.previousSibling\n    },\n\n    //\n    // prepares the element to become a css region\n    //\n    markNodesAsRegion: function(nodes, fast) {\n      nodes.forEach(function(node) {\n        node.regionOverset = 'empty'\n        node.setAttribute('data-css-region', node.cssRegionsLastFlowFromName)\n        cssRegionsHelpers.hideTextNodesFromFragmentSource([node])\n        node.cssRegionsWrapper =\n          node.cssRegionsWrapper || node.appendChild(document.createElement('cssregion'))\n      })\n    },\n\n    //\n    // prepares the element to return to its normal css life\n    //\n    unmarkNodesAsRegion: function(nodes, fast) {\n      nodes.forEach(function(node) {\n        // restore regionOverset to its natural value\n        node.regionOverset = 'fit'\n\n        // remove the current <cssregion> tag\n        try {\n          node.cssRegionsWrapper && node.removeChild(node.cssRegionsWrapper)\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n        node.cssRegionsWrapper = undefined\n        delete node.cssRegionsWrapper\n\n        // restore top-level texts that may have been hidden\n        cssRegionsHelpers.unhideTextNodesFromFragmentSource([node])\n\n        // unmark as a region\n        node.removeAttribute('data-css-region')\n      })\n    },\n\n    //\n    // prepares the element for cloning (mainly give them an ID)\n    //\n    fragmentSourceIndex: 0,\n    markNodesAsFragmentSource: function(nodes, ignoreRoot) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            if (typeof k == 'undefined' || !ignoreRoot) {\n              // mark as fragment source\n              var id = node.getAttributeNode('data-css-regions-fragment-source')\n              if (!id) {\n                node.setAttribute(\n                  'data-css-regions-fragment-source',\n                  cssRegionsHelpers.fragmentSourceIndex++\n                )\n              }\n            }\n\n            node.setAttribute('data-css-regions-cloning', true)\n\n            // expand list values\n            if (node.tagName == 'OL') cssRegionsHelpers.expandListValues(node)\n            if (typeof k != 'undefined' && node.tagName == 'LI')\n              cssRegionsHelpers.expandListValues(node.parentNode)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // computes the \"value\" attribute of every LI element out there\n    //\n    expandListValues: function(OL) {\n      if (OL.getAttribute('data-css-li-value-expanded')) return\n      OL.setAttribute('data-css-li-value-expanded', true)\n\n      if (OL.hasAttribute('reversed')) {\n        var currentValue = OL.getAttribute('start')\n          ? parseInt(OL.getAttribute('start'))\n          : OL.childElementCount\n        var increment = -1\n      } else {\n        var currentValue = OL.getAttribute('start') ? parseInt(OL.getAttribute('start')) : 1\n        var increment = +1\n      }\n\n      var LI = OL.firstElementChild\n      var LIV = null\n      while (LI) {\n        if (LI.tagName === 'LI') {\n          if ((LIV = LI.getAttributeNode('value'))) {\n            currentValue = parseInt(LIV.nodeValue)\n            LI.setAttribute('data-css-old-value', currentValue)\n          } else {\n            LI.setAttribute('value', currentValue)\n          }\n          currentValue = currentValue + increment\n        }\n        LI = LI.nextElementSibling\n      }\n    },\n\n    //\n    // reverts to automatic computation of the value of LI elements\n    //\n    unexpandListValues: function(OL) {\n      if (!OL.hasAttribute('data-css-li-value-expanded')) return\n      OL.removeAttribute('data-css-li-value-expanded')\n      var LI = OL.firstElementChild\n      var LIV = null\n      while (LI) {\n        if (LI.tagName === 'LI') {\n          if ((LIV = LI.getAttributeNode('data-css-old-value'))) {\n            LI.removeAttributeNode(LIV)\n          } else {\n            LI.removeAttribute('value')\n          }\n        }\n        LI = LI.nextElementSibling\n      }\n    },\n\n    //\n    // makes empty text nodes which cannot get \"display: none\" applied to them\n    //\n    listOfTextNodesForIE: [],\n    hideTextNodesFromFragmentSource: function(nodes) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            if (!node.parentNode.getAttribute('data-css-regions-fragment-source')) {\n              // we have to remove their content the hard way...\n              node.cssRegionsSavedNodeValue = node.nodeValue\n              node.nodeValue = ''\n\n              // HACK: OTHERWISE IE WILL GC THE TEXTNODE AND RETURNS YOU\n              // A FRESH TEXTNODE THE NEXT TIME WHERE YOUR EXPANDO\n              // IS NOWHERE TO BE SEEN!\n              if (\n                navigator.userAgent.indexOf('MSIE') > 0 ||\n                navigator.userAgent.indexOf('Trident') > 0\n              ) {\n                if (cssRegionsHelpers.listOfTextNodesForIE.indexOf(node) == -1) {\n                  cssRegionsHelpers.listOfTextNodesForIE.push(node)\n                }\n              }\n            }\n\n            break\n\n          case 1: // Element node\n            if (node.hasAttribute('data-css-regions-cloning')) {\n              node.removeAttribute('data-css-regions-cloning')\n              node.setAttribute('data-css-regions-cloned', true)\n              if (node.currentStyle) node.currentStyle.display.toString() // IEFIX FOR BAD STYLE RECALC\n            }\n            if (typeof k == 'undefined') return\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // makes emptied text nodes visible again\n    //\n    unhideTextNodesFromFragmentSource: function(nodes) {\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we have to remove their content the hard way...\n            if ('cssRegionsSavedNodeValue' in node) {\n              node.nodeValue = node.cssRegionsSavedNodeValue\n              delete node.cssRegionsSavedNodeValue\n            }\n\n            break\n\n          case 1: // Element node\n            if (typeof k == 'undefined') return\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // prepares the content elements to return to ther normal css life\n    //\n    unmarkNodesAsFragmentSource: function(nodes) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we have to reinstall their content the hard way...\n            if ('cssRegionsSavedNodeValue' in node) {\n              node.nodeValue = node.cssRegionsSavedNodeValue\n              delete node.cssRegionsSavedNodeValue\n            }\n\n            break\n          case 1: // Element node\n            node.removeAttribute('data-css-regions-cloned')\n            node.removeAttribute('data-css-regions-fragment-source')\n            if (node.currentStyle) node.currentStyle.display.toString() // IEFIX FOR BAD STYLE RECALC\n            if (node.tagName == 'OL') cssRegionsHelpers.unexpandListValues(node)\n            if (typeof k != 'undefined' && node.tagName == 'LI')\n              cssRegionsHelpers.unexpandListValues(node.parentNode)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // marks cloned content as fragment instead of as fragment source (basically)\n    //\n    transformFragmentSourceToFragments: function(nodes) {\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            var id = node.getAttribute('data-css-regions-fragment-source')\n            node.removeAttribute('data-css-regions-fragment-source')\n            node.removeAttribute('data-css-regions-cloning')\n            node.removeAttribute('data-css-regions-cloned')\n            node.setAttribute('data-css-regions-fragment-of', id)\n            if (node.id) node.id += '--fragment'\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // removes some invisible text nodes from the tree\n    // (useful if you don't want to face browser bugs when dealing with them)\n    //\n    embedTrailingWhiteSpaceNodes: function(fragment) {\n      var onlyWhiteSpace = /^\\s*$/\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we only remove nodes at the edges\n            if (!node.previousSibling) {\n              // we only remove nodes if their parent doesn't preserve whitespace\n              if (getComputedStyle(node.parentNode).whiteSpace.substring(0, 3) !== 'pre') {\n                // only remove pure whitespace nodes\n                if (onlyWhiteSpace.test(node.nodeValue)) {\n                  node.parentNode.setAttribute('data-whitespace-before', node.nodeValue)\n                  node.parentNode.removeChild(node)\n                }\n              }\n\n              break\n            }\n\n            // we only remove nodes at the edges\n            if (!node.nextSibling) {\n              // we only remove nodes if their parent doesn't preserve whitespace\n              if (getComputedStyle(node.parentNode).whiteSpace.substring(0, 3) !== 'pre') {\n                // only remove pure whitespace nodes\n                if (onlyWhiteSpace.test(node.nodeValue)) {\n                  node.parentNode.setAttribute('data-whitespace-after', node.nodeValue)\n                  node.parentNode.removeChild(node)\n                }\n              }\n\n              break\n            }\n\n            break\n          case 1: // Element node\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      visit(fragment)\n    },\n\n    //\n    // recover the previously removed invisible text nodes\n    //\n    unembedTrailingWhiteSpaceNodes: function(fragment) {\n      var onlyWhiteSpace = /^\\s*$/\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            var txt = ''\n            if ((txt = node.getAttribute('data-whitespace-before'))) {\n              if (\n                node.getAttribute('data-starting-fragment') == '' &&\n                node.getAttribute('data-special-starting-fragment', '')\n              ) {\n                node.insertBefore(document.createTextNode(txt), node.firstChild)\n              }\n            }\n            node.removeAttribute('data-whitespace-before')\n            if ((txt = node.getAttribute('data-whitespace-after'))) {\n              if (\n                node.getAttribute('data-continued-fragment') == '' &&\n                node.getAttribute('data-special-continued-fragment', '')\n              ) {\n                node.insertAfter(document.createTextNode(txt), node.lastChild)\n              }\n            }\n            node.removeAttribute('data-whitespace-after')\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      visit(fragment)\n    },\n\n    ///\n    /// walk the two trees the same way, and copy all the styles\n    /// BEWARE: if the DOMs are different, funny things will happen\n    /// NOTE: this function will also remove elements put in another flow\n    ///\n    copyStyle: function(root1, root2) {\n      function visit(node1, node2, isRoot) {\n        var child1, next1, child2, next2\n        switch (node1.nodeType) {\n          case 1: // Element node\n            // firstly, setup a cache of all css properties on the element\n            var matchedRules =\n              node1.currentStyle && !window.opera\n                ? undefined\n                : cssCascade.findAllMatchingRules(node1)\n\n            // and compute the value of all css properties\n            var properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties()\n            for (var p = properties.length; p--; ) {\n              // if the property is computation-safe, use the computed value\n              if (\n                !(properties[p] in cssCascade.computationUnsafeProperties) &&\n                properties[p][0] != '-'\n              ) {\n                var style = getComputedStyle(node1).getPropertyValue(properties[p])\n                var defaultStyle = cssCascade\n                  .getDefaultStyleForTag(node1.tagName)\n                  .getPropertyValue(properties[p])\n                if (style != defaultStyle) node2.style.setProperty(properties[p], style)\n                continue\n              }\n\n              // otherwise, get the element's specified value\n              var cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules)\n              if (cssValue && cssValue.length) {\n                // if we have a specified value, let's use it\n                node2.style.setProperty(properties[p], cssValue.toCSSString())\n              } else if (isRoot && node1.parentNode && properties[p][0] != '-') {\n                // NOTE: the root will be detached from its parent\n                // Therefore, we have to inherit styles from it (oh no!)\n\n                // TODO: create a list of inherited properties\n                if (!(properties[p] in cssCascade.inheritingProperties)) continue\n\n                // if the property is computation-safe, use the computed value\n                if (\n                  properties[p] == 'font-size' ||\n                  (!(properties[p] in cssCascade.computationUnsafeProperties) &&\n                    properties[p][0] != '-')\n                ) {\n                  var style = getComputedStyle(node1).getPropertyValue(properties[p])\n                  node2.style.setProperty(properties[p], style)\n                  //var parentStyle = style; try { parentStyle = getComputedStyle(node1.parentNode).getPropertyValue(properties[p]) } catch(ex){}\n                  //var defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\n\n                  //if(style === parentStyle) {\n                  //  node2.style.setProperty(properties[p], style)\n                  //}\n                  continue\n                }\n\n                // otherwise, get the parent's specified value\n                var cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules)\n                if (cssValue && cssValue.length) {\n                  // if we have a specified value, let's use it\n                  node2.style.setProperty(properties[p], cssValue.toCSSString())\n                }\n              }\n            }\n\n            // now, let's work on ::after and ::before\n            var importPseudo = function(node1, node2, pseudo) {\n              //\n              // we'll need to use getSpecifiedStyle here as the pseudo thing is slow\n              //\n              var mayExist = !!cssCascade.findAllMatchingRulesWithPseudo(node1, pseudo.substr(1))\n                .length\n              if (!mayExist) return\n\n              var pseudoStyle = getComputedStyle(node1, pseudo)\n              if (pseudoStyle.content != 'none') {\n                // let's create a stylesheet for the element\n                var stylesheet = document.createElement('style')\n                stylesheet.setAttribute('data-no-css-polyfill', true)\n\n                // compute the value of all css properties\n                var node2style = ''\n                var properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties()\n                for (var p = properties.length; p--; ) {\n                  // we always use the computed value, because we don't have better\n                  var style = pseudoStyle.getPropertyValue(properties[p])\n                  node2style += properties[p] + ':' + style + ';'\n                }\n\n                stylesheet.textContent =\n                  '[data-css-regions-fragment-of=\"' +\n                  node1.getAttribute('data-css-regions-fragment-source') +\n                  '\"]' +\n                  ':not([data-css-regions-starting-fragment]):not([data-css-regions-special-starting-fragment])' +\n                  ':' +\n                  pseudo +\n                  '{' +\n                  node2style +\n                  '}'\n\n                node2.parentNode.insertBefore(stylesheet, node2)\n              }\n            }\n            importPseudo(node1, node2, ':before')\n            importPseudo(node1, node2, ':after')\n\n            // retarget events\n            cssRegionsHelpers.retargetEvents(node1, node2)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child1 = node1.firstChild\n            child2 = node2.firstChild\n            while (child1) {\n              next1 = child1.nextSibling\n              next2 = child2.nextSibling\n\n              // decide between process style or hide\n              if (\n                child1.cssRegionsLastFlowIntoName &&\n                child1.cssRegionsLastFlowIntoType === 'element'\n              ) {\n                node2.removeChild(child2)\n              } else {\n                visit(child1, child2)\n              }\n\n              child1 = next1\n              child2 = next2\n            }\n            break\n        }\n      }\n\n      visit(root1, root2, true)\n    },\n\n    //\n    // make sure the most critical events still fire in the fragment source\n    // even if the browser initially fire them on the fragments\n    //\n    retargetEvents: function retargetEvents(node1, node2) {\n      var retargetEvent = 'cssRegionsHelpers.retargetEvent(this,event)'\n      node2.setAttribute('onclick', retargetEvent)\n      node2.setAttribute('ondblclick', retargetEvent)\n      node2.setAttribute('onmousedown', retargetEvent)\n      node2.setAttribute('onmouseup', retargetEvent)\n      node2.setAttribute('onmousein', retargetEvent)\n      node2.setAttribute('onmouseout', retargetEvent)\n      node2.setAttribute('onmouseenter', retargetEvent)\n      node2.setAttribute('onmouseleave', retargetEvent)\n    },\n\n    //\n    // single hub for event retargeting operations.\n    //\n    retargetEvent: function retargeEvent(node2, e) {\n      // get the node we should fire the event on\n      var node1 =\n        node2.cssRegionsFragmentSource ||\n        (node2.cssRegionsFragmentSource = document.querySelector(\n          '[data-css-regions-fragment-source=\"' +\n            node2.getAttribute('data-css-regions-fragment-of') +\n            '\"]'\n        ))\n\n      if (node1) {\n        // dispatch the event on the real node\n        var ne = domEvents.cloneEvent(e)\n        node1.dispatchEvent(ne)\n\n        // prevent the event to fire on the region\n        e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.stopPropagation()\n\n        // make sure to cancel the event if required\n        if (ne.isDefaultPrevented || ne.defaultPrevented) {\n          e.preventDefault()\n          return false\n        }\n      }\n    }\n  })\n\n  return cssRegionsHelpers\n})(window, document)\n\nrequire.define('src/css-regions/lib/helpers.js');","//\n// this module holds the front-facing features of the polyfill\n//\nmodule.exports = function(window, document, cssRegions) {\n  'use strict'\n\n  var domEvents = require('src/core/dom-events.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n  var cssBreak = require('src/core/css-break.js')\n  var cssRegionsHelpers = require('src/css-regions/lib/helpers.js')\n  var ES = require('src/core/dom-experimental-event-streams.js')\n\n  //\n  // this class contains flow-relative data field\n  //\n  cssRegions.Flow = function NamedFlow(name) {\n    // TODO: force immediate relayout if someone ask the overset properties\n    // and the layout has been deemed wrong (still isn't a proof of correctness but okay)\n\n    // define the flow name\n    this.name = name\n    Object.defineProperty(this, 'name', {\n      get: function() {\n        return name\n      }\n    })\n\n    // define the overset status\n    this.overset = false\n\n    // define the first empty region\n    this.firstEmptyRegionIndex = -1\n\n    // elements poured into the flow\n    this.content = []\n    this.lastContent = []\n\n    // elements that consume this flow\n    this.regions = []\n    this.lastRegions = []\n\n    // event handlers\n    this.eventListeners = {\n      regionfragmentchange: [],\n      regionoversetchange: []\n    }\n\n    // this function is used to work with dom event streams\n    var This = this\n    This.update = function(stream) {\n      stream.schedule(This.update)\n      This.relayout()\n    }\n\n    // register to style changes already\n    This.lastStylesheetAdded = 0\n    cssCascade.addEventListener('stylesheetadded', function() {\n      if (This.lastStylesheetAdded - Date() > 100) {\n        This.lastStylesheetAdded = +Date()\n        This.relayout()\n      } else {\n        cssConsole.warn(\n          \"Please don't add stylesheets as a response to region events. Operation cancelled.\"\n        )\n      }\n    })\n\n    // a small counter to avoid enter retry loops\n    This.failedLayoutCount = 0\n\n    // some other fields\n    This.lastEventRAF = 0\n    This.restartLayout = false\n  }\n\n  cssRegions.Flow.prototype.removeFromContent = function(element) {\n    // clean up stuff\n    this.removeEventListenersOf(element)\n\n    // remove reference\n    var index = this.content.indexOf(element)\n    if (index >= 0) {\n      this.content.splice(index, 1)\n    }\n  }\n\n  cssRegions.Flow.prototype.removeFromRegions = function(element) {\n    // clean up stuff\n    this.removeEventListenersOf(element)\n\n    // remove reference\n    var index = this.regions.indexOf(element)\n    if (index >= 0) {\n      this.regions.splice(index, 1)\n    }\n  }\n\n  cssRegions.Flow.prototype.addToContent = function(element) {\n    // handle trivial cases real quick\n    var content = this.content\n    if (content.length == 0 || content[content.length - 1].nextSibling === element) {\n      content.push(element)\n      return\n    }\n    if (content[0].previousSibling === element) {\n      content.unshift(element)\n      return\n    }\n\n    // walk the tree to find an element inside the content chain\n    var currentNodeIndex = -1\n    var treeWalker = document.createTreeWalker(\n      document.documentElement,\n      NodeFilter.SHOW_ELEMENT,\n      function(node) {\n        return (currentNodeIndex = content.indexOf(node)) >= 0\n          ? NodeFilter.FILTER_ACCEPT\n          : NodeFilter.FILTER_SKIP\n      },\n      false\n    )\n\n    // which by the way has to be after the considered element\n    treeWalker.currentNode = element\n\n    // if we find such node\n    if (treeWalker.nextNode()) {\n      // insert the element at his current location\n      content.splice(currentNodeIndex, 0, element)\n    } else {\n      // add the new element to the end of the array\n      content.push(element)\n    }\n  }\n\n  cssRegions.Flow.prototype.addToRegions = function(element) {\n    // walk the tree to find an element inside the region chain\n    var regions = this.regions\n    var treeWalker = document.createTreeWalker(\n      document.documentElement,\n      NodeFilter.SHOW_ELEMENT,\n      function(node) {\n        return regions.indexOf(node) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT\n      },\n      false\n    )\n\n    // which by the way has to be after the considered element\n    treeWalker.currentNode = element\n\n    // if we find such node\n    if (treeWalker.nextNode()) {\n      // insert the element at his current location\n      regions.splice(this.regions.indexOf(treeWalker.currentNode), 0, element)\n    } else {\n      // add the new element to the end of the array\n      regions.push(element)\n    }\n  }\n\n  cssRegions.Flow.prototype.generateContentFragment = function() {\n    var fragment = document.createDocumentFragment()\n    var This = this\n\n    // add copies of all due content\n    for (var i = 0; i < this.content.length; i++) {\n      var element = this.content[i]\n\n      //\n      // STEP 1: IDENTIFY FRAGMENT SOURCES AS SUCH\n      //\n      cssRegionsHelpers.markNodesAsFragmentSource(\n        [element],\n        element.cssRegionsLastFlowIntoType == 'content'\n      )\n\n      //\n      // STEP 2: CLONE THE FRAGMENT SOURCES\n      //\n\n      // depending on the requested behavior\n      if (element.cssRegionsLastFlowIntoType == 'element') {\n        // add the element\n        var el = element\n        var elClone = el.cloneNode(true)\n        var elToInsert = elClone\n        if (elToInsert.tagName == 'LI') {\n          elToInsert = document.createElement(el.parentNode.tagName)\n          elToInsert.style.margin = '0'\n          elToInsert.style.padding = '0'\n          elToInsert.appendChild(elClone)\n        }\n        fragment.appendChild(elToInsert)\n\n        // clone the style\n        cssRegionsHelpers.copyStyle(el, elClone)\n      } else {\n        // add current children\n        var el = element.firstChild\n        while (el) {\n          // add the element\n          var elClone = el.cloneNode(true)\n          var elToInsert = elClone\n          if (elToInsert.tagName == 'LI') {\n            elToInsert = document.createElement(el.parentNode.tagName)\n            elToInsert.style.margin = '0'\n            elToInsert.style.padding = '0'\n            elToInsert.appendChild(elClone)\n          }\n          fragment.appendChild(elToInsert)\n\n          // clone the style\n          cssRegionsHelpers.copyStyle(el, elClone)\n\n          el = el.nextSibling\n        }\n      }\n    }\n\n    //\n    // STEP 3: HIDE TEXT NODES IN FRAGMENT SOURCES\n    //\n    cssRegionsHelpers.hideTextNodesFromFragmentSource(this.content)\n\n    //\n    // STEP 4: CONVERT CLONED FRAGMENT SOURCES INTO TRUE FRAGMENTS\n    //\n    cssRegionsHelpers.transformFragmentSourceToFragments(\n      Array.prototype.slice.call(fragment.childNodes, 0)\n    )\n\n    //\n    // CLONED CONTENT IS READY!\n    //\n    return fragment\n  }\n\n  cssRegions.Flow.prototype.relayout = function() {\n    var This = this\n\n    // prevent previous relayouts from eventing\n    cancelAnimationFrame(This.lastEventRAF)\n\n    // batch relayout queries\n    if (This.relayoutScheduled) {\n      return\n    }\n    if (This.relayoutInProgress) {\n      This.restartLayout = true\n      return\n    }\n    This.relayoutScheduled = true\n    requestAnimationFrame(function() {\n      This._relayout()\n    })\n  }\n\n  cssRegions.Flow.prototype._relayout = function(data) {\n    var This = this\n\n    try {\n      //\n      // note: it is recommended to look at the beautiful\n      // drawings I made before attempting to understand\n      // this stuff. If you don't have them, ask me.\n      //\n      cssConsole.log('starting a new relayout for ' + This.name)\n      This.relayoutInProgress = true\n      This.relayoutScheduled = false\n      This.lastRelayout = +new Date()\n      //debugger;\n\n      // NOTE: we recover the scroll position in case the browser mess it up\n      var docElmScrollTop =\n        data && data.docElmScrollTop ? data.docElmScrollTop : document.documentElement.scrollTop\n      var docBdyScrollTop =\n        data && data.docBdyScrollTop ? data.docBdyScrollTop : document.body.scrollTop\n\n      //\n      // STEP 1: REMOVE PREVIOUS EVENT LISTENERS\n      //\n\n      // remove the listeners from everything\n      This.removeEventListenersOf(This.lastRegions)\n      This.removeEventListenersOf(This.lastContent)\n      cancelAnimationFrame(This.lastEventRAF)\n\n      //\n      // STEP 2: RESTORE CONTENT/REGIONS TO A CLEAN STATE\n      //\n\n      // detect elements being removed of the document\n      This.regions = This.regions.filter(function(e) {\n        return document.documentElement.contains(e)\n      })\n      This.content = This.content.filter(function(e) {\n        return document.documentElement.contains(e)\n      })\n\n      // cleanup previous layout\n      cssRegionsHelpers.unmarkNodesAsRegion(This.lastRegions)\n      This.lastRegions = This.regions.slice(0)\n      cssRegionsHelpers.unmarkNodesAsFragmentSource(This.lastContent)\n      This.lastContent = This.content.slice(0)\n\n      //\n      // STEP 3: EMPTY ALL REGIONS\n      // ADD WRAPPER FOR FLOW CONTENT\n      // PREPARE FOR CONTENT CLONING\n      //\n\n      // empty all the regions\n      cssRegionsHelpers.markNodesAsRegion(This.regions)\n\n      // create a fresh list of the regions\n      var regionStack = This.regions.slice(0).reverse()\n\n      //\n      // STEP 4: CLONE THE CONTENT\n      // ADD METADATA TO CLONED CONTENT\n      // HIDE FLOW CONTENT AT INITIAL POSITION\n      //\n\n      // create a fresh list of the content\n      // compute the style of all source elements\n      // generate stylesheets for those rules\n      var contentFragment = This.generateContentFragment()\n\n      //\n      // STEP 5: POUR CONTENT INTO THE REGIONS\n      //\n\n      // layout this stuff\n      cssRegions.layoutContent(regionStack, contentFragment, {\n        onprogress: function(continueLayout) {\n          // NOTE: we recover the scroll position in case the browser mess it up\n          document.documentElement.scrollTop = docElmScrollTop\n          document.body.scrollTop = docBdyScrollTop\n\n          // NOTE: if the current layout goes nowhere, start a new one already\n          if (This.restartLayout) {\n            This.relayoutInProgress = false\n            This.failedLayoutCount = 0\n            This.restartLayout = false\n            This._relayout({\n              docElmScrollTop: docElmScrollTop,\n              docBdyScrollTop: docBdyScrollTop\n            })\n          } else {\n            setImmediate(continueLayout)\n          }\n        },\n        ondone: function onLayoutDone(overset) {\n          This.overset = overset\n          This.firstEmptyRegionIndex = This.regions.length - 1\n          while (This.regions[This.firstEmptyRegionIndex]) {\n            // tell whether the region is empty\n            var isEmpty = false\n            isEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper\n            isEmpty =\n              isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper.firstChild\n\n            // if the region is not empty\n            if (!isEmpty) {\n              // the first empty region if the next one, if it exists\n              if (++This.firstEmptyRegionIndex == This.regions.length) {\n                This.firstEmptyRegionIndex = -1\n              }\n              break\n            } else {\n              // else, let's try the previous region\n              This.firstEmptyRegionIndex--\n            }\n          }\n\n          //\n          // STEP 6: REGISTER TO UPDATE EVENTS\n          //\n\n          // make sure regions update are taken in consideration\n          if (window.MutationObserver) {\n            This.addEventListenersTo(This.content)\n            This.addEventListenersTo(This.regions)\n          } else {\n            // the other browsers don't get this as acurately\n            // but that shouldn't be that of an issue for 99% of the cases\n            setImmediate(function() {\n              This.addEventListenersTo(This.content)\n            })\n          }\n\n          //\n          // STEP 7: FIRE SOME EVENTS\n          //\n          if (This.regions.length > 0 && !This.restartLayout) {\n            // before doing anything, let's check our stuff is consistent\n            var isBuggy = false\n            isBuggy =\n              isBuggy ||\n              This.regions.some(function(e) {\n                return !document.documentElement.contains(e)\n              })\n            isBuggy =\n              isBuggy ||\n              This.content.some(function(e) {\n                return !document.documentElement.contains(e)\n              })\n\n            if (isBuggy) {\n              // if we found any bug, we will need to restart a layout\n              cssConsole.warn('Buggy css regions layout: the page changed; we need to restart.')\n              This.restartLayout = true\n            } else {\n              // if it was okay, let's fire some event\n              This.lastEventRAF = requestAnimationFrame(function() {\n                // TODO: only fire when necessary but...\n                This.dispatchEvent('regionfragmentchange')\n                This.dispatchEvent('regionoversetchange')\n              })\n            }\n          }\n\n          // NOTE: we recover the scroll position in case the browser mess it up\n          document.documentElement.scrollTop = docElmScrollTop\n          document.body.scrollTop = docBdyScrollTop\n\n          // mark layout has being done\n          This.relayoutInProgress = false\n          This.failedLayoutCount = 0\n\n          // restart a layout if a request was queued during the current one\n          if (This.restartLayout) {\n            This.restartLayout = false\n            This.relayout()\n          }\n        }\n      })\n    } catch (ex) {\n      // sometimes IE fails for no valid reason\n      // (other than the page is still loading)\n      setImmediate(function() {\n        throw ex\n      })\n\n      // but we cannot accept to fail, so we need to try again\n      // until we finish a complete layout pass...\n      This.failedLayoutCount++\n      if (This.failedLayoutCount < 7) {\n        requestAnimationFrame(function() {\n          This._relayout()\n        })\n      } else {\n        This.failedLayoutCount = 0\n        This.relayoutScheduled = false\n        This.relayoutInProgress = false\n        This.restartLayout = false\n      }\n    }\n  }\n\n  cssRegions.Flow.prototype.relayoutIfSizeChanged = function() {\n    // go through all regions\n    // and see if any did change of size\n    var rs = this.regions\n    for (var i = rs.length; i--; ) {\n      if (\n        rs[i].offsetHeight !== rs[i].cssRegionsLastOffsetHeight ||\n        rs[i].offsetWidth !== rs[i].cssRegionsLastOffsetWidth\n      ) {\n        this.relayout()\n        return\n      }\n    }\n  }\n\n  cssRegions.Flow.prototype.addEventListenersTo = function(nodes) {\n    var This = this\n    if (nodes instanceof Element) {\n      nodes = [nodes]\n    }\n\n    nodes.forEach(function(element) {\n      if (!element.cssRegionsEventStream) {\n        element.cssRegionsEventStream = new ES.DOMUpdateEventStream({ target: element })\n        element.cssRegionsEventStream.schedule(This.update)\n      }\n    })\n  }\n\n  cssRegions.Flow.prototype.removeEventListenersOf = function(nodes) {\n    var This = this\n    if (nodes instanceof Element) {\n      nodes = [nodes]\n    }\n\n    nodes.forEach(function(element) {\n      if (element.cssRegionsEventStream) {\n        element.cssRegionsEventStream.dispose()\n        delete element.cssRegionsEventStream\n      }\n    })\n  }\n\n  // alias\n  cssRegions.NamedFlow = cssRegions.Flow\n\n  // return a disconnected array of the content of a NamedFlow\n  cssRegions.NamedFlow.prototype.getContent = function getContent() {\n    return this.content.slice(0)\n  }\n\n  // return a disconnected array of the regions of a NamedFlow\n  cssRegions.NamedFlow.prototype.getRegions = function getRegions() {\n    return this.regions.slice(0)\n  }\n\n  cssRegions.NamedFlow.prototype.getRegionsByContent = function getRegionsByContent(node) {\n    var regions = []\n    var fragments = document.querySelectorAll(\n      '[data-css-regions-fragment-of=\"' +\n        node.getAttribute('data-css-regions-fragment-source') +\n        '\"]'\n    )\n    for (var i = 0; i < fragments.length; i++) {\n      var current = fragments[i]\n      do {\n        if (current.getAttribute('data-css-region')) {\n          regions.push(current)\n          break\n        }\n      } while ((current = current.parentNode))\n    }\n\n    return regions\n  }\n\n  domEvents.EventTarget.implementsIn(cssRegions.Flow)\n\n  //\n  // this class is a collection of named flows (not an array, sadly)\n  //\n  cssRegions.NamedFlowCollection = function NamedFlowCollection() {\n    this.length = 0\n  }\n\n  cssRegions.NamedFlowCollection.prototype.namedItem = function(k) {\n    return cssRegions.flows[k] || (cssRegions.flows[k] = new cssRegions.Flow(k))\n  }\n\n  //\n  // this helper creates the required methods on top of the DOM {ie: public exports}\n  //\n  cssRegions.enablePolyfillObjectModel = function() {\n    //\n    // DOCUMENT INTERFACE\n    //\n\n    //\n    // returns a static list of active named flows\n    //\n    document.getNamedFlows = function() {\n      var c = new cssRegions.NamedFlowCollection()\n      var flows = cssRegions.flows\n      for (var flowName in cssRegions.flows) {\n        if (Object.prototype.hasOwnProperty.call(flows, flowName)) {\n          // only active flows can be included\n          if (flows[flowName].content.length != 0 || flows[flowName].regions.length != 0) {\n            c[c.length++] = c[flowName] = flows[flowName]\n          }\n        }\n      }\n      return c\n    }\n\n    //\n    // returns a live object for any named flow\n    //\n    document.getNamedFlow = function(flowName) {\n      var flows = cssRegions.flows\n      return flows[flowName] || (flows[flowName] = new cssRegions.NamedFlow(flowName))\n    }\n\n    //\n    // ELEMENT INTERFACE\n    //\n    Object.defineProperties(Element.prototype, {\n      regionOverset: {\n        get: function() {\n          return this._regionOverset || 'fit'\n        },\n        set: function(value) {\n          this._regionOverset = value\n        }\n      },\n      getRegionFlowRanges: {\n        value: function getRegionFlowRanges() {\n          return null // TODO: can we implement that? I think we can't (properly).\n        }\n      },\n      getComputedRegionStyle: {\n        value: function getComputedRegionStyle(element, pseudo) {\n          // TODO: only works while we don't relayout\n          // TODO: only works properly for elements actually in the region\n          var fragment = document.querySelector(\n            '[data-css-regions-fragment-of=\"' +\n              element.getAttribute('data-css-regions-fragment-source') +\n              '\"]'\n          )\n          if (pseudo) {\n            return getComputedStyle(fragment || element, pseudo)\n          } else {\n            return getComputedStyle(fragment || element)\n          }\n        }\n      }\n    })\n\n    //\n    // CSSStyleDeclaration interface\n    //\n    cssCascade.polyfillStyleInterface('flow-into')\n    cssCascade.polyfillStyleInterface('flow-from')\n    cssCascade.polyfillStyleInterface('region-fragment')\n    cssCascade.polyfillStyleInterface('break-before')\n    cssCascade.polyfillStyleInterface('break-after')\n  }\n\n  // load the polyfill immediately if not especially told otherwise\n  if (!('cssRegionsManualTrigger' in window)) {\n    cssRegions.enablePolyfill()\n  }\n}\n\nrequire.define('src/css-regions/lib/objectmodel.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  var domEvents = require('src/core/dom-events.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n  var cssBreak = require('src/core/css-break.js')\n\n  require('src/css-regions/lib/range-extensions.js')\n  var cssRegionsHelpers = require('src/css-regions/lib/helpers.js')\n  var enableObjectModel = require('src/css-regions/lib/objectmodel.js')\n\n  var CSS_STYLE =\n    \"cssregion,[data-css-region]>*,[data-css-regions-fragment-source]:not([data-css-regions-cloning]),[data-css-regions-fragment-source][data-css-regions-cloned]{display:none!important}[data-css-region]>cssregion:last-of-type{display:inline!important}[data-css-region]{content:normal!important}[data-css-special-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;padding-bottom:0!important;border-bottom:none!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]::after{content:none!important;display:none!important}[data-css-special-starting-fragment]{text-indent:0!important;margin-top:0!important}[data-css-starting-fragment]{text-indent:0!important;margin-top:0!important;padding-top:0!important;border-top:none!important;border-top-left-radius:0!important;border-top-right-radius:0!important}[data-css-starting-fragment]::before{content:none!important;display:none!important}[data-css-continued-block-fragment][data-css-continued-fragment]:not(:empty)::after{content:''!important;display:inline-block!important;width:100%!important;height:0!important;font-size:0!important;line-height:0!important;margin:0!important;padding:0!important;border:0!important}\"\n\n  var cssRegions = {\n    //\n    // this function is at the heart of the region polyfill\n    // it will iteratively fill a list of regions until no\n    // content or no region is left\n    //\n    // the before-overflow size of a region is determined by\n    // adding all content to it and comparing his offsetHeight\n    // and his scrollHeight\n    //\n    // when this is done, we use dom ranges to detect the point\n    // where the content exceed this box and we split the fragment\n    // at that point.\n    //\n    // when splitting inside an element, the borders, paddings and\n    // generated content must be tied to the right fragments which\n    // require some code\n    //\n    // this functions returns whether some content was still remaining\n    // when the flow when the last region was filled. please not this\n    // can only happen if this last region has \"region-fragment\" set\n    // to break, otherwhise all the content will automatically overflow\n    // this last region.\n    //\n    layoutContent: function(regions, remainingContent, callback, startTime) {\n      //\n      // this function will iteratively fill all the regions\n      // when we reach the last region, we return the overset status\n      //\n\n      // validate args\n      if (!regions) return callback.ondone(!!remainingContent.hasChildNodes())\n      if (!regions.length) return callback.ondone(!!remainingContent.hasChildNodes())\n      if (!startTime) startTime = Date.now()\n\n      // get the next region\n      var region = regions.pop()\n\n      // NOTE: while we don't monitor that, and it can therefore become inaccurate\n      // I'm going to follow the spec and refuse to mark as region inline/none elements]\n      while (true) {\n        var regionDisplay = getComputedStyle(region).display\n        if (regionDisplay == 'none' || regionDisplay.indexOf('inline') !== -1) {\n          if ((region = regions.pop())) {\n            continue\n          } else {\n            return callback.ondone(!!remainingContent.hasChildNodes())\n          }\n        } else {\n          break\n        }\n      }\n\n      // the polyfill actually use a <cssregion> wrapper\n      // we need to link this wrapper and the actual region\n      if (region.cssRegionsWrapper) {\n        region.cssRegionsWrapper.cssRegionHost = region\n        region = region.cssRegionsWrapper\n      } else {\n        region.cssRegionHost = region\n      }\n\n      // empty the region\n      region.innerHTML = ''\n\n      // avoid doing the layout of empty regions\n      if (!remainingContent.hasChildNodes()) {\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        region.cssRegionHost.regionOverset = 'empty'\n\n        var dummyCallback = {\n          ondone: function() {},\n          onprogress: function(f) {\n            f()\n          }\n        }\n        cssRegions.layoutContent(regions, remainingContent, dummyCallback, startTime)\n\n        return callback.ondone(false)\n      }\n\n      // append the remaining content to the region\n      region.appendChild(remainingContent)\n\n      // check if we have more regions to process\n      if (regions.length !== 0) {\n        return this.layoutContentInNextRegionsWhenReady(\n          region,\n          regions,\n          remainingContent,\n          callback,\n          startTime\n        )\n      } else {\n        return this.layoutContentInLastRegionWhenReady(\n          region,\n          regions,\n          remainingContent,\n          callback,\n          startTime\n        )\n      }\n    },\n\n    layoutContentInNextRegionsWhenReady: function(\n      region,\n      regions,\n      remainingContent,\n      callback,\n      startTime\n    ) {\n      // delays until all images are loaded\n      var imgs = region.getElementsByTagName('img')\n      for (var imgs_index = imgs.length; imgs_index--; ) {\n        if (!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n          return setTimeout(\n            function() {\n              this.layoutContentInNextRegionsWhenReady(\n                region,\n                regions,\n                remainingContent,\n                callback,\n                startTime + 32\n              )\n            }.bind(this),\n            16\n          )\n        }\n      }\n\n      // check if there was an overflow or some break-before/after instruction\n      var regionDidOverflow = region.cssRegionHost.scrollHeight != region.cssRegionHost.offsetHeight\n      var shouldSegmentContent = regionDidOverflow\n      if (!shouldSegmentContent) {\n        var first = region.firstElementChild\n        var last = region.lastElementChild\n        var current = first\n        while (current) {\n          if (current != first) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-before', undefined, true).toCSSString()\n              )\n            ) {\n              shouldSegmentContent = true\n              break\n            }\n          }\n\n          if (current != last) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-after', undefined, true).toCSSString()\n              )\n            ) {\n              current = current.nextElementSibling\n              shouldSegmentContent = true\n              break\n            }\n          }\n\n          current = current.nextElementSibling\n        }\n      }\n\n      if (shouldSegmentContent) {\n        // the remaining content is what was overflowing\n        remainingContent = this.extractOverflowingContent(region)\n      } else {\n        // there's nothing more to insert\n        remainingContent = document.createDocumentFragment()\n      }\n\n      // if any content didn't fit\n      if (remainingContent.hasChildNodes()) {\n        region.cssRegionHost.regionOverset = 'overset'\n      } else {\n        region.cssRegionHost.regionOverset = 'fit'\n      }\n\n      // update flags\n      region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n      region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n      // layout the next regions\n      // WE LET THE NEXT REGION DECIDE WHAT TO RETURN\n      if (startTime + 200 > Date.now()) {\n        return cssRegions.layoutContent(regions, remainingContent, callback, startTime)\n      } else {\n        return callback.onprogress(function() {\n          cssRegions.layoutContent(regions, remainingContent, callback)\n        })\n      }\n    },\n\n    layoutContentInLastRegionWhenReady: function(\n      region,\n      regions,\n      remainingContent,\n      callback,\n      startTime\n    ) {\n      // delays until all images are loaded\n      var imgs = region.getElementsByTagName('img')\n      for (var imgs_index = imgs.length; imgs_index--; ) {\n        if (!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n          return setTimeout(\n            function() {\n              this.layoutContentInLastRegionWhenReady(\n                region,\n                regions,\n                remainingContent,\n                callback,\n                startTime + 32\n              )\n            }.bind(this),\n            32\n          )\n        }\n      }\n\n      // support region-fragment: break\n      if (\n        cssCascade\n          .getSpecifiedStyle(region.cssRegionHost, 'region-fragment', undefined, true)\n          .toCSSString()\n          .trim()\n          .toLowerCase() == 'break'\n      ) {\n        // WE RETURN TRUE IF WE DID OVERFLOW\n        var didOverflow = this.extractOverflowingContent(region).hasChildNodes()\n\n        // update flags\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        return callback.ondone(didOverflow)\n      } else {\n        // update flags\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        // WE RETURN FALSE IF WE DIDN'T OVERFLOW\n        return callback.ondone(\n          region.cssRegionHost.offsetHeight != region.cssRegionHost.scrollHeight\n        )\n      }\n    },\n\n    //\n    // this function returns a document fragment containing the content\n    // that didn't fit in a particular <cssregion> element.\n    //\n    // in the simplest cases, we can just use hit-targeting to get very\n    // close the the natural breaking point. for mostly textual flows,\n    // this works perfectly, for the others, we may need some tweaks.\n    //\n    // there's a code detecting whether this hit-target optimization\n    // did possibly fail, in which case we return to a setup where we\n    // start from scratch.\n    //\n    extractOverflowingContent: function(region, dontOptimize) {\n      // make sure empty nodes don't make our life more difficult\n      cssRegionsHelpers.embedTrailingWhiteSpaceNodes(region)\n\n      // get the region layout\n      var sizingH = region.cssRegionHost.offsetHeight // avail size (max-height)\n      var sizingW = region.cssRegionHost.offsetWidth // avail size (max-width)\n      var pos = region.cssRegionHost.getBoundingClientRect() // avail size?\n      pos = { top: pos.top, bottom: pos.bottom, left: pos.left, right: pos.right }\n\n      // substract from the bottom any border/padding of the region\n      var lostHeight = parseInt(getComputedStyle(region.cssRegionHost).paddingBottom)\n      lostHeight += parseInt(getComputedStyle(region.cssRegionHost).borderBottomWidth)\n      pos.bottom -= lostHeight\n      sizingH -= lostHeight\n\n      //\n      // note: let's use hit targeting to find a dom range\n      // which is close to the location where we will need to\n      // break the content into fragments\n      //\n\n      // get the caret range for the bottom-right of that location\n      try {\n        var r = dontOptimize\n          ? document.createRange()\n          : document.caretRangeFromPoint(pos.left + sizingW - 1, pos.top + sizingH - 1)\n      } catch (ex) {\n        try {\n          cssConsole.error(ex.message)\n          cssConsole.dir(ex)\n        } catch (ex) {}\n      }\n\n      // helper for logging info\n      /*cssConsole.log(\"extracting overflow\")\n\t\t\tcssConsole.log(pos.bottom)*/\n      var debug = function() {\n        /*cssConsole.dir({\n\t\t\t\t\tstartContainer: r.startContainer,\n\t\t\t\t\tstartOffset: r.startOffset,\n\t\t\t\t\tbrowserBCR: r.getBoundingClientRect(),\n\t\t\t\t\tcomputedBCR: rect\n\t\t\t\t});*/\n      }\n\n      var fixNullRect = function() {\n        if (rect.bottom == 0 && rect.top == 0 && rect.left == 0 && rect.right == 0) {\n          var scrollTop = -(document.documentElement.scrollTop || document.body.scrollTop)\n          var scrollLeft = -(document.documentElement.scrollLeft || document.body.scrollLeft)\n\n          rect = {\n            width: 0,\n            heigth: 0,\n            top: scrollTop,\n            bottom: scrollTop,\n            left: scrollLeft,\n            right: scrollLeft\n          }\n        }\n      }\n\n      // if the caret is outside the region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        // if the caret is after the region wrapper but inside the host...\n        if (\n          r &&\n          r.endContainer === region.cssRegionHost &&\n          r.endOffset == r.endContainer.childNodes.length\n        ) {\n          // move back at the end of the region, actually\n          r.setStart(region, region.childNodes.length)\n          r.setEnd(region, region.childNodes.length)\n        } else {\n          // move back into the region\n          r = r || document.createRange()\n          r.setStart(region, 0)\n          r.setEnd(region, 0)\n          dontOptimize = true\n        }\n      }\n\n      // start finding the natural breaking point\n      do {\n        // store the current selection rect for fast access\n        var rect = r.myGetExtensionRect()\n        fixNullRect()\n        debug()\n\n        //\n        // note: maybe the text is right-to-left\n        // in this case, we can go further than the caret\n        //\n\n        // move the end point char by char until it's completely in the region\n        while (\n          !(r.endContainer == region && r.endOffset == r.endContainer.childNodes.length) &&\n          rect.bottom <= pos.top + sizingH\n        ) {\n          debug()\n\n          // look if we can optimize by moving fast forward\n          var nextSibling = r.endContainer.childNodes[r.endOffset]\n          var nextSiblingRect = !nextSibling || Node.getBoundingClientRect(nextSibling)\n          if (nextSibling && nextSiblingRect.bottom <= pos.top + sizingH) {\n            // if yes, move element by element\n            r.setStartAfter(nextSibling)\n            r.setEndAfter(nextSibling)\n            rect = nextSiblingRect\n            fixNullRect()\n          } else {\n            // otherwise, go char-by-char\n            r.myMoveTowardRight()\n            rect = r.myGetExtensionRect()\n            fixNullRect()\n          }\n        }\n\n        //\n        // note: maybe the text is one line too big\n        // in this case, we have to backtrack a little\n        //\n\n        // move the end point char by char until it's completely in the region\n        while (!(r.endContainer == region && r.endOffset == 0) && rect.bottom > pos.top + sizingH) {\n          debug()\n          r.myMoveOneCharLeft()\n          rect = r.myGetExtensionRect()\n          fixNullRect()\n        }\n\n        debug()\n\n        //\n        // note: if we optimized via hit-testing, this may be wrong\n        // if next condition does not hold, we're fine.\n        // otherwhise we must restart without optimization...\n        //\n\n        // if the selected content is possibly off-target\n        var optimizationFailled = false\n        if (!dontOptimize) {\n          var current = r.endContainer\n          while ((current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region))) {\n            if (Node.getBoundingClientRect(current).bottom > pos.top + sizingH) {\n              r.setStart(region, 0)\n              r.setEnd(region, 0)\n              optimizationFailled = true\n              dontOptimize = true\n              break\n            }\n          }\n        }\n      } while (optimizationFailled)\n\n      //\n      // note: we should not break the content inside monolithic content\n      // if we do, we need to change the selection to avoid that\n      //\n\n      // move the selection before the monolithic ancestors\n      var current = r.endContainer\n      while (current !== region) {\n        if (cssBreak.isMonolithic(current)) {\n          r.setEndBefore(current)\n        }\n        current = current.parentNode\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      //\n      // note: we don't want to break inside a line.\n      // backtrack to end of previous line...\n      //\n      var first = r.startContainer.childNodes[r.startOffset],\n        current = first\n      if (cssBreak.hasAnyInlineFlow(r.startContainer)) {\n        while (current && (current = current.previousSibling)) {\n          if (cssBreak.areInSameSingleLine(current, first)) {\n            // optimization: first and current are on the same line\n            // so if next and current are not the same line, it will still be\n            // the same line the \"first\" element is in\n            first = current\n\n            if (current instanceof Element) {\n              // we don't want to break inside text lines\n              r.setEndBefore(current)\n            } else {\n              // get last line via client rects\n              var lines = Node.getClientRects(current)\n\n              // if the text node did wrap into multiple lines\n              if (lines.length > 1) {\n                // move back from the end until we get into previous line\n                var previousLineBottom = lines[lines.length - 2].bottom\n                r.setEnd(current, current.nodeValue.length)\n                while (rect.bottom > previousLineBottom) {\n                  r.myMoveOneCharLeft()\n                  rect = r.myGetExtensionRect()\n                  fixNullRect()\n                }\n\n                // make sure we didn't exit the text node by mistake\n                if (r.endContainer !== current) {\n                  // if we did, there's something wrong about the text node\n                  // but we can consider the text node as an element instead\n                  r.setEndBefore(current) // debugger;\n                }\n              } else {\n                // we can consider the text node as an element\n                r.setEndBefore(current)\n              }\n            }\n          } else {\n            // if the two elements are not on the same line,\n            // then we just found a line break!\n            break\n          }\n        }\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      //\n      // note: the css-break spec says that a region should not be emtpy\n      //\n\n      // if we end up with nothing being selected, add the first block anyway\n      if (\n        r.endContainer === region &&\n        r.endOffset === 0 &&\n        r.endOffset !== region.childNodes.length\n      ) {\n        // find the first allowed break point\n        do {\n          //cssConsole.dir(r.cloneRange());\n\n          // move the position char-by-char\n          r.myMoveTowardRight()\n\n          // but skip long islands of monolithic elements\n          // since we know we cannot break inside them anyway\n          var current = r.endContainer\n          while (current && current !== region) {\n            if (cssBreak.isMonolithic(current)) {\n              r.setStartAfter(current)\n              r.setEndAfter(current)\n            }\n            current = current.parentNode\n          }\n        } while (\n          // do that until we reach a possible break point, or the end of the element\n          !cssBreak.isPossibleBreakPoint(r, region) &&\n          !(r.endContainer === region && r.endOffset === region.childNodes.length)\n        )\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      // now, let's try to find a break-before/break-after element before the splitting point\n      var current = r.endContainer\n      if (current.hasChildNodes()) {\n        if (r.endOffset > 0) {\n          current = current.childNodes[r.endOffset - 1]\n        }\n      }\n      var first = r.endContainer.firstChild\n      do {\n        if (current.style) {\n          if (current != first) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-before', undefined, true).toCSSString()\n              )\n            ) {\n              r.setStartBefore(current)\n              r.setEndBefore(current)\n              dontOptimize = true // no algo involved in breaking, after all\n            }\n          }\n\n          if (current !== region) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-after', undefined, true).toCSSString()\n              )\n            ) {\n              r.setStartAfter(current)\n              r.setEndAfter(current)\n              dontOptimize = true // no algo involved in breaking, after all\n            }\n          }\n        }\n      } while ((current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region)))\n\n      // we're almost done! now, let's collect the ancestors to make some splitting postprocessing\n      var current = r.endContainer\n      var allAncestors = []\n      if (current.nodeType !== current.ELEMENT_NODE) current = current.parentNode\n      while (current !== region) {\n        allAncestors.push(current)\n        current = current.parentNode\n      }\n\n      //\n      // note: if we're about to split after the last child of\n      // an element which has bottom-{padding/border/margin},\n      // we need to figure how how much of that p/b/m we can\n      // actually keep in the first fragment\n      //\n      // TODO: avoid top & bottom p/b/m cuttings to use the\n      // same variables names, it's ugly\n      //\n\n      // split bottom-{margin/border/padding} correctly\n      if (r.endOffset == r.endContainer.childNodes.length && r.endContainer !== region) {\n        // compute how much of the bottom border can actually fit\n        var box = r.endContainer.getBoundingClientRect()\n        var excessHeight = box.bottom - (pos.top + sizingH)\n        var endContainerStyle = getComputedStyle(r.endContainer)\n        var availBorderHeight = parseFloat(endContainerStyle.borderBottomWidth)\n        var availPaddingHeight = parseFloat(endContainerStyle.paddingBottom)\n\n        // start by cutting into the border\n        var borderCut = excessHeight\n        if (excessHeight > availBorderHeight) {\n          borderCut = availBorderHeight\n          excessHeight -= borderCut\n\n          // continue by cutting into the padding\n          var paddingCut = excessHeight\n          if (paddingCut > availPaddingHeight) {\n            paddingCut = availPaddingHeight\n            excessHeight -= paddingCut\n          } else {\n            excessHeight = 0\n          }\n        } else {\n          excessHeight = 0\n        }\n\n        // we don't cut borders with radiuses\n        // TODO: accept to cut the content not affected by the radius\n        if (typeof borderCut === 'number' && borderCut !== 0) {\n          // check the presence of a radius:\n          var hasBottomRadius =\n            parseInt(endContainerStyle.borderBottomLeftRadius) > 0 ||\n            parseInt(endContainerStyle.borderBottomRightRadius) > 0\n\n          if (hasBottomRadius) {\n            // break before the whole border:\n            borderCut = availBorderHeight\n          }\n        }\n      }\n\n      // split top-{margin/border/padding} correctly\n      if (r.endOffset == 0 && r.endContainer !== region) {\n        // note: the only possibility here is that we\n        // did split after a padding or a border.\n        //\n        // it can only happen if the border/padding is\n        // too big to fit the region but is actually\n        // the first break we could find!\n\n        // compute how much of the top border can actually fit\n        var box = r.endContainer.getBoundingClientRect()\n        var availHeight = pos.top + sizingH - pos.top\n        var endContainerStyle = getComputedStyle(r.endContainer)\n        var availBorderHeight = parseFloat(endContainerStyle.borderTopWidth)\n        var availPaddingHeight = parseFloat(endContainerStyle.paddingTop)\n        var excessHeight = availBorderHeight + availPaddingHeight - availHeight\n\n        if (excessHeight > 0) {\n          // start by cutting into the padding\n          var topPaddingCut = excessHeight\n          if (excessHeight > availPaddingHeight) {\n            topPaddingCut = availPaddingHeight\n            excessHeight -= topPaddingCut\n\n            // continue by cutting into the border\n            var topBorderCut = excessHeight\n            if (topBorderCut > availBorderHeight) {\n              topBorderCut = availBorderHeight\n              excessHeight -= topBorderCut\n            } else {\n              excessHeight = 0\n            }\n          } else {\n            excessHeight = 0\n          }\n        }\n      }\n\n      // remove bottom-{pbm} from all ancestors involved in the cut\n      for (var i = allAncestors.length - 1; i >= 0; i--) {\n        allAncestors[i].setAttribute('data-css-continued-fragment', true)\n        if (getComputedStyle(allAncestors[i]).display.indexOf('block') >= 0) {\n          allAncestors[i].setAttribute('data-css-continued-block-fragment', true)\n        }\n      }\n      if (typeof borderCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.borderBottomWidth = availBorderHeight - borderCut + 'px'\n      }\n      if (typeof paddingCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.paddingBottom = availPaddingHeight - paddingCut + 'px'\n      }\n      if (typeof topBorderCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-continued-fragment', true)\n        allAncestors[0].style.borderTopWidth = availBorderHeight - topBorderCut + 'px'\n      }\n      if (typeof topPaddingCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.paddingTop = availPaddingHeight - topPaddingCut + 'px'\n      }\n\n      //\n      // note: at this point we have a collapsed range\n      // located at the split point\n      //\n\n      // select the overflowing content\n      r.setEnd(region, region.childNodes.length)\n\n      // extract it from the current region\n      var overflowingContent = r.extractContents()\n\n      // remove trailing whitespace from the cut element\n      var tmp = allAncestors[0]\n      if (tmp && (tmp = tmp.lastChild) && !tmp.tagName && tmp.nodeValue) {\n        var nodeValue = tmp.nodeValue.replace(/(\\s|\\r|\\n)*$/, '')\n        if (nodeValue) {\n          // if the last cut was just after a &shy; (soft hyphen), we need to append a dash\n          if (/\\u00AD$/.test(nodeValue)) {\n            nodeValue = nodeValue.replace(/\\u00AD$/, '-')\n          } else if (overflowingContent && overflowingContent.textContent[0] == '\\u00AD') {\n            nodeValue = nodeValue + '-'\n          }\n          tmp.nodeValue = nodeValue\n        } else {\n          tmp.parentNode.removeChild(tmp)\n        }\n      }\n\n      //\n      // note: now we have to cancel out the artifacts of\n      // the fragments cloning algorithm...\n      //\n\n      // do not forget to remove any top p/b/m on cut elements\n      var newFragments = overflowingContent.querySelectorAll('[data-css-continued-fragment]')\n      for (var i = newFragments.length; i--; ) {\n        // TODO: optimize by using while loop and a simple matchesSelector.\n        newFragments[i].removeAttribute('data-css-continued-fragment')\n        newFragments[i].setAttribute('data-css-starting-fragment', true)\n      }\n\n      // deduct any already-used bottom p/b/m\n      var specialNewFragment = overflowingContent.querySelector(\n        '[data-css-special-continued-fragment]'\n      )\n      if (specialNewFragment) {\n        specialNewFragment.removeAttribute('data-css-special-continued-fragment')\n        specialNewFragment.setAttribute('data-css-starting-fragment', true)\n\n        if (typeof borderCut === 'number') {\n          specialNewFragment.style.borderBottomWidth = borderCut + 'px'\n        }\n        if (typeof paddingCut === 'number') {\n          specialNewFragment.style.paddingBottom = paddingCut\n        } else {\n          specialNewFragment.style.paddingBottom = '0px'\n        }\n\n        if (typeof topBorderCut === 'number') {\n          specialNewFragment.removeAttribute('data-css-starting-fragment')\n          specialNewFragment.setAttribute('data-css-special-starting-fragment', true)\n          specialNewFragment.style.borderTopWidth = topBorderCut + 'px'\n        }\n        if (typeof topPaddingCut === 'number') {\n          specialNewFragment.removeAttribute('data-css-starting-fragment')\n          specialNewFragment.setAttribute('data-css-special-starting-fragment', true)\n          specialNewFragment.style.paddingTop = topPaddingCut + 'px'\n          specialNewFragment.style.paddingBottom = '0px'\n          specialNewFragment.style.borderBottomWidth = '0px'\n        }\n      } else if (typeof borderCut === 'number') {\n        // hum... there's an element missing here... {never happens anymore}\n        try {\n          throw new Error()\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n      } else if (typeof topPaddingCut === 'number') {\n        // hum... there's an element missing here... {never happens anymore}\n        try {\n          throw new Error()\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n      }\n\n      // make sure empty nodes are reintroduced\n      cssRegionsHelpers.unembedTrailingWhiteSpaceNodes(region)\n      cssRegionsHelpers.unembedTrailingWhiteSpaceNodes(overflowingContent)\n\n      // we're ready to return our result!\n      return overflowingContent\n    },\n\n    enablePolyfill: function enablePolyfill() {\n      //\n      // [0] insert necessary css\n      //\n      var s = document.createElement('style')\n      s.setAttribute('data-css-no-polyfill', true)\n      s.textContent = CSS_STYLE\n      var head = document.head || document.getElementsByTagName('head')[0]\n      head.appendChild(s)\n\n      //\n      // [1] when any update happens:\n      // construct new content and region flow pairs\n      // restart the region layout algorithm for the modified pairs\n      //\n      cssCascade.startMonitoringProperties(['flow-into', 'flow-from', 'region-fragment'], {\n        onupdate: function onupdate(element, rule) {\n          // let's just ignore fragments\n          if (element.getAttributeNode('data-css-regions-fragment-of')) return\n\n          // log some message in the console for debug\n          cssConsole.dir({\n            message: 'onupdate',\n            element: element,\n            selector: rule.selector.toCSSString(),\n            rule: rule\n          })\n          var temp = null\n\n          //\n          // compute the value of region properties\n          //\n          var flowInto = cssCascade.getSpecifiedStyle(element, 'flow-into').filter(function(t) {\n            return t instanceof cssSyntax.IdentifierToken\n          })\n\n          var flowIntoName = flowInto[0] ? flowInto[0].toCSSString().toLowerCase() : ''\n          if (\n            flowIntoName == 'none' ||\n            flowIntoName == 'initial' ||\n            flowIntoName == 'inherit' ||\n            flowIntoName == 'default'\n          ) {\n            flowIntoName = ''\n          }\n          var flowIntoType = flowInto[1] ? flowInto[1].toCSSString().toLowerCase() : ''\n          if (flowIntoType != 'content') {\n            flowIntoType = 'element'\n          }\n          var flowInto = flowIntoName ? flowIntoName + ' ' + flowIntoType : ''\n\n          var flowFrom = cssCascade.getSpecifiedStyle(element, 'flow-from').filter(function(t) {\n            return t instanceof cssSyntax.IdentifierToken\n          })\n\n          var flowFromName = flowFrom[0] ? flowFrom[0].toCSSString().toLowerCase() : ''\n          if (\n            flowFromName == 'none' ||\n            flowFromName == 'initial' ||\n            flowFromName == 'inherit' ||\n            flowFromName == 'default'\n          ) {\n            flowFromName = ''\n          }\n          var flowFrom = flowFromName\n\n          //\n          // if the value of any property did change...\n          //\n          if (\n            element.cssRegionsLastFlowInto != flowInto ||\n            element.cssRegionsLastFlowFrom != flowFrom\n          ) {\n            // remove the element from previous regions\n            var regionOverset = element.regionOverset\n            var lastFlowFrom = cssRegions.flows[element.cssRegionsLastFlowFromName]\n            var lastFlowInto = cssRegions.flows[element.cssRegionsLastFlowIntoName]\n            lastFlowFrom && lastFlowFrom.removeFromRegions(element)\n            lastFlowInto && lastFlowInto.removeFromContent(element)\n\n            // relayout those regions\n            // (it's async so it will wait for us\n            // to add the element back if needed)\n            lastFlowFrom && regionOverset != 'empty' && lastFlowFrom.relayout()\n            lastFlowInto && lastFlowInto.relayout()\n\n            // save some property values for later\n            element.cssRegionsLastFlowInto = flowInto\n            element.cssRegionsLastFlowFrom = flowFrom\n            element.cssRegionsLastFlowIntoName = flowIntoName\n            element.cssRegionsLastFlowFromName = flowFromName\n            element.cssRegionsLastFlowIntoType = flowIntoType\n\n            // add the element to new regions\n            // and relayout those regions, if deemed necessary\n            if (flowFromName) {\n              var lastFlowFrom = (cssRegions.flows[flowFromName] =\n                cssRegions.flows[flowFromName] || new cssRegions.Flow(flowFromName))\n              lastFlowFrom && lastFlowFrom.addToRegions(element)\n              lastFlowFrom && lastFlowFrom.relayout()\n            }\n            if (flowIntoName) {\n              var lastFlowInto = (cssRegions.flows[flowIntoName] =\n                cssRegions.flows[flowIntoName] || new cssRegions.Flow(flowIntoName))\n              lastFlowInto && lastFlowInto.addToContent(element)\n              lastFlowInto && lastFlowInto.relayout()\n            }\n          }\n        }\n      })\n      cssCascade.startMonitoringProperties(['break-before', 'break-after'], {\n        onupdate: function(element) {\n          // avoid fragments triggering update loops\n          if (element.getAttribute('data-css-regions-fragment-of')) {\n            return\n          }\n\n          // update parent regions\n          while (element) {\n            if (element.cssRegionsLastFlowIntoName) {\n              cssRegions.flows[element.cssRegionsLastFlowIntoName].relayout()\n              return\n            }\n            element = element.parentNode\n          }\n        }\n      })\n\n      //\n      // [2] perform the OM exports\n      //\n      cssRegions.enablePolyfillObjectModel()\n\n      //\n      // [3] make sure to update the region layout when all images loaded\n      //\n      window.addEventListener('load', function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          flows[i].relayout()\n        }\n      })\n\n      //\n      // [4] make sure we react to window resizes\n      //\n      //\n      var lastWindowResize = 0\n      var relayoutModifiedFlows = function() {\n        // specify the function did run\n        relayoutModifiedFlows.timeout = 0\n\n        // rerun the layout\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            flows[i].relayout()\n          } else {\n            flows[i].relayoutIfSizeChanged()\n          }\n        }\n      }\n      var hasOngoingLayouts = function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            return true\n          }\n        }\n\n        return false\n      }\n      var restartOngoingLayouts = function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            flows[i].relayout()\n          }\n        }\n      }\n      window.addEventListener('resize', function() {\n        // update the last layout flag\n        lastWindowResize = +new Date()\n\n        // if we aren't planning a resfresh already\n        if (!relayoutModifiedFlows.timeout) {\n          // if we are already busy\n          if (hasOngoingLayouts()) {\n            // restart all layouts now\n            setTimeout(restartOngoingLayouts, 16)\n\n            // wait half a second before restarting them from now\n            relayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 500)\n          } else {\n            // debounce by running the resize code every 200ms\n            relayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 200)\n          }\n        }\n      })\n    },\n\n    // this dictionary is supposed to contains all the currently existing flows\n    flows: Object.create ? Object.create(null) : {}\n  }\n\n  enableObjectModel(window, document, cssRegions)\n\n  window.cssRegions = cssRegions\n\n  return cssRegions\n})(window, document)\n\nrequire.define('src/css-regions/polyfill.js');","//require('core:polyfill-dom-matchMedia');\n//require('core:polyfill-dom-classList');\n//require('css-grid:polyfill');\nrequire('src/css-regions/polyfill.js')\n\nrequire.define('src/requirements.js');"]}