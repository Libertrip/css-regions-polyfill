{"version":3,"sources":["../src/core/polyfill-dom-console.js","../src/core/dom-events.js","../src/core/css-syntax.js","../src/core/polyfill-dom-requestAnimationFrame.js","../src/core/dom-experimental-event-streams.js","../src/core/dom-query-selector-live.js","../src/core/css-cascade.js","../src/core/css-break.js","../src/css-regions/lib/range-extensions.js","../src/css-regions/lib/helpers.js","../src/css-regions/lib/objectmodel.js","../src/css-regions/polyfill.js","../src/requirements.js"],"names":[],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mD;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;AC5LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yC;;;;ACxzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iE;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6D;;;;ACnXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sD;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0C;;;;ACryBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;AC9aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0D;;;;ACjgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iD;;;;AChmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qD;;;;AChoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8C;;;;ACngCA;AACA;AACA;AACA;AACA,sC","file":"css-regions-polyfill.js","sourcesContent":["!(function(window, document) { \"use strict\";\n\n\t//\n\t// some code for console polyfilling\n\t//\n\tif(!window.console) {\n\t\t\t\n\t\twindow.console = {\n\t\t\tbacklog: '',\n\t\t\t\n\t\t\tlog: function(x) { this.backlog+=x+'\\n'; if(window.debug) alert(x); },\n\t\t\t\n\t\t\tdir: function(x) { try { \n\t\t\t\t\n\t\t\t\tvar elm = function(e) {\n\t\t\t\t\tif(e.innerHTML) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttagName: e.tagName,\n\t\t\t\t\t\t\tclassName: e.className,\n\t\t\t\t\t\t\tid: e.id,\n\t\t\t\t\t\t\tinnerHTML: e.innerHTML.substr(0,100)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\tnodeName: e.nodeName,\n\t\t\t\t\t\t\tnodeValue: e.nodeValue\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tvar jsonify = function(o) {\n\t\t\t\t\tvar seen=[];\n\t\t\t\t\tvar jso=JSON.stringify(o, function(k,v){\n\t\t\t\t\t\tif (typeof v =='object') {\n\t\t\t\t\t\t\tif ( !seen.indexOf(v) ) { return '__cycle__'; }\n\t\t\t\t\t\t\tif ( v instanceof window.Node) { return elm(v); }\n\t\t\t\t\t\t\tseen.push(v);\n\t\t\t\t\t\t} return v;\n\t\t\t\t\t});\n\t\t\t\t\treturn jso;\n\t\t\t\t};\n\t\t\t\t\n\t\t\t\tthis.log(jsonify(x)); \n\t\t\t\t\n\t\t\t} catch(ex) { this.log(x) } },\n\t\t\t\n\t\t\twarn: function(x) { this.log(x) },\n\t\t\t\n\t\t\terror: function(x) { this.log(\"ERROR:\"); this.log(x); }\n\t\t\t\n\t\t};\n\t\t\n\t\tif(!window.onerror) {\n\t\t\twindow.onerror = function() {\n\t\t\t\tconsole.log([].slice.call(arguments,0).join(\"\\n\"))\n\t\t\t};\n\t\t}\n\t\t\n\t}\n\n\t//\n\t// this special console is used as a proxy emulating the CSS console of browsers\n\t//\n\twindow.cssConsole = {\n\t\tenabled: (!!window.debug), warnEnabled: (true),\n\t\tlog: function(x) { if(this.enabled) console.log(x) },\n\t\tdir: function(x) { if(this.enabled) console.dir(x) },\n\t\twarn: function(x) { if(this.warnEnabled) console.warn(x) },\n\t\terror: function(x) { console.error(x); }\n\t}\n\n})(window, document);\nrequire.define('src/core/polyfill-dom-console.js');","module.exports = (function(window, document) { \"use strict\";\n\n\trequire('src/core/polyfill-dom-console.js');\n\n\t//\n\t// some other basic om code\n\t//\n\tvar domEvents = {\n\t\t\n\t\t//\n\t\t// the following functions are about event cloning\n\t\t//\n\t\tcloneMouseEvent: function cloneMouseEvent(e) {\n\t\t\tvar evt = document.createEvent(\"MouseEvent\");\n\t\t\tevt.initMouseEvent( \n\t\t\t\te.type, \n\t\t\t\te.canBubble||e.bubbles, \n\t\t\t\te.cancelable, \n\t\t\t\te.view, \n\t\t\t\te.detail, \n\t\t\t\te.screenX, \n\t\t\t\te.screenY, \n\t\t\t\te.clientX, \n\t\t\t\te.clientY, \n\t\t\t\te.ctrlKey, \n\t\t\t\te.altKey, \n\t\t\t\te.shiftKey, \n\t\t\t\te.metaKey, \n\t\t\t\te.button, \n\t\t\t\te.relatedTarget\n\t\t\t);\n\t\t\treturn evt;\n\t\t},\n\t\t\n\t\tcloneKeyboardEvent: function cloneKeyboardEvent(e) {\n\t\t\t// TODO: this doesn't work cross-browser...\n\t\t\t// see https://gist.github.com/termi/4654819/ for the huge code\n\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t},\n\t\t\n\t\tcloneCustomEvent: function cloneCustomEvent(e) {\n\t\t\tvar ne = document.createEvent(\"CustomEvent\");\n\t\t\tne.initCustomEvent(e.type, e.canBubble||e.bubbles, e.cancelable, \"detail\" in e ? e.detail : e);\n\t\t\tfor(var prop in e) {\n\t\t\t\ttry {\n\t\t\t\t\tif(e[prop] != ne[prop] && e[prop] != e.target) {\n\t\t\t\t\t\ttry { ne[prop] = e[prop]; }\n\t\t\t\t\t\tcatch (ex) { Object.defineProperty(ne,prop,{get:function() { return e[prop]} }) }\n\t\t\t\t\t}\n\t\t\t\t} catch(ex) {}\n\t\t\t}\n\t\t\treturn ne;\n\t\t},\n\t\t\n\t\tcloneEvent: function cloneEvent(e) {\n\t\t\t\n\t\t\tif(e instanceof MouseEvent) {\n\t\t\t\treturn domEvents.cloneMouseEvent(e);\n\t\t\t} else if(e instanceof KeyboardEvent) {\n\t\t\t\treturn domEvents.cloneKeyboardEvent(e);\n\t\t\t} else {\n\t\t\t\treturn domEvents.cloneCustomEvent(e);\n\t\t\t}\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// allows you to drop event support to any class easily\n\t\t//\n\t\tEventTarget: {\n\t\t\timplementsIn: function(eventClass, static_class) {\n\t\t\t\t\n\t\t\t\tif(!static_class && typeof(eventClass)==\"function\") eventClass=eventClass.prototype;\n\t\t\t\t\n\t\t\t\teventClass.dispatchEvent = domEvents.EventTarget.prototype.dispatchEvent;\n\t\t\t\teventClass.addEventListener = domEvents.EventTarget.prototype.addEventListener;\n\t\t\t\teventClass.removeEventListener = domEvents.EventTarget.prototype.removeEventListener;\n\t\t\t\t\n\t\t\t},\n\t\t\tprototype: {}\n\t\t}\n\t\t\n\t};\n\n\tdomEvents.EventTarget.prototype.addEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[]));\n\t\tif(ls.indexOf(f)==-1) {\n\t\t\tls.push(f);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.removeEventListener = function(eventType,f) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\n\t\tvar ls = (this.eventListeners[eventType] || (this.eventListeners[eventType]=[])), i;\n\t\tif((i=ls.indexOf(f))!==-1) {\n\t\t\tls.splice(i,1);\n\t\t}\n\t\t\n\t}\n\n\tdomEvents.EventTarget.prototype.dispatchEvent = function(event_or_type) {\n\t\tif(!this.eventListeners) this.eventListeners=[];\n\t\t\n\t\t// abort quickly when no listener has been set up\n\t\tif(typeof(event_or_type) == \"string\") {\n\t\t\tif(!this.eventListeners[event_or_type] || this.eventListeners[event_or_type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif(!this.eventListeners[event_or_type.type] || this.eventListeners[event_or_type.type].length==0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// convert the event\n\t\tvar event = event_or_type;\n\t\tfunction setUpPropertyForwarding(e,ee,key) {\n\t\t\tObject.defineProperty(ee,key,{\n\t\t\t\tget:function() {\n\t\t\t\t\tvar v = e[key]; \n\t\t\t\t\tif(typeof(v)==\"function\") {\n\t\t\t\t\t\treturn v.bind(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn v;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tset:function(v) {\n\t\t\t\t\te[key] = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tfunction setUpTarget(e,v) {\n\t\t\ttry { Object.defineProperty(e,\"target\",{get:function() {return v}}); }\n\t\t\tcatch(ex) {}\n\t\t\tfinally {\n\t\t\t\t\n\t\t\t\tif(e.target !== v) {\n\t\t\t\t\t\n\t\t\t\t\tvar ee = Object.create(Object.getPrototypeOf(e));\n\t\t\t\t\tee = setUpTarget(ee,v);\n\t\t\t\t\tfor(var key in e) {\n\t\t\t\t\t\tif(key != \"target\") setUpPropertyForwarding(e,ee,key);\n\t\t\t\t\t}\n\t\t\t\t\treturn ee;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\treturn e;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// try to set the target\n\t\tif(typeof(event)==\"object\") {\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else if(typeof(event)==\"string\") {\n\t\t\tevent = document.createEvent(\"CustomEvent\");\n\t\t\tevent.initCustomEvent(event_or_type, /*canBubble:*/ true, /*cancelable:*/ false, /*detail:*/this);\n\t\t\ttry { event=setUpTarget(event,this); } catch(ex) {}\n\t\t\t\n\t\t} else {\n\t\t\tthrow new Error(\"dispatchEvent expect an Event object or a string containing the event type\");\n\t\t}\n\t\t\n\t\t// call all listeners\n\t\tvar ls = (this.eventListeners[event.type] || (this.eventListeners[event.type]=[]));\n\t\tfor(var i=ls.length; i--;) {\n\t\t\ttry { \n\t\t\t\tls[i](event);\n\t\t\t} catch(ex) {\n\t\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn event.isDefaultPrevented;\n\t}\n\t\n\treturn domEvents;\n\t\n})(window, document);\n\nrequire.define('src/core/dom-events.js');","//\n// note: this file is based on Tab Atkins's CSS Parser\n// please include him (@tabatkins) if you open any issue for this file\n// \nmodule.exports = (function(window, document) { \"use strict\";\n\n// \n// exports\n//\nvar cssSyntax = { \n\ttokenize: function(string) {/*filled later*/}, \n\tparse: function(tokens) {/*filled later*/}\n};\n\n//\n// css tokenizer\n//\n\n// Add support for token lists (superclass of array)\nfunction TokenList() {\n\tvar array = []; \n\tarray.toCSSString=TokenListToCSSString;\n\treturn array;\n}\nfunction TokenListToCSSString(sep) {\n\tif(sep) {\n\t\treturn this.map(function(o) { return o.toCSSString(); }).join(sep);\n\t} else {\n\t\treturn this.asCSSString || (this.asCSSString = (\n\t\t\tthis.map(function(o) { return o.toCSSString(); }).join(\"/**/\")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/( +\\/\\*\\*\\/ *| * | *\\/\\*\\*\\/ +)/g,\" \")\n\t\t\t\t.replace(/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)\\/\\*\\*\\//g,\"$1\")\n\t\t\t\t.replace(/\\/\\*\\*\\/(\\!|\\:|\\;|\\@|\\.|\\,|\\*|\\=|\\&|\\\\|\\/|\\<|\\>|\\[|\\{|\\(|\\]|\\}|\\)|\\|)/g,\"$1\")\n\t\t));\n\t}\n}\ncssSyntax.TokenList = TokenList;\ncssSyntax.TokenListToCSSString = TokenListToCSSString;\n\nfunction between(num, first, last) { return num >= first && num <= last; }\nfunction digit(code) { return between(code, 0x30,0x39); }\nfunction hexdigit(code) { return digit(code) || between(code, 0x41,0x46) || between(code, 0x61,0x66); }\nfunction uppercaseletter(code) { return between(code, 0x41,0x5a); }\nfunction lowercaseletter(code) { return between(code, 0x61,0x7a); }\nfunction letter(code) { return uppercaseletter(code) || lowercaseletter(code); }\nfunction nonascii(code) { return code >= 0x80; }\nfunction namestartchar(code) { return letter(code) || nonascii(code) || code == 0x5f; }\nfunction namechar(code) { return namestartchar(code) || digit(code) || code == 0x2d; }\nfunction nonprintable(code) { return between(code, 0,8) || code == 0xb || between(code, 0xe,0x1f) || code == 0x7f; }\nfunction newline(code) { return code == 0xa; }\nfunction whitespace(code) { return newline(code) || code == 9 || code == 0x20; }\nfunction badescape(code) { return newline(code) || isNaN(code); }\n\nvar maximumallowedcodepoint = 0x10ffff;\n\nfunction InvalidCharacterError(message) {\n\tthis.message = message;\n};\nInvalidCharacterError.prototype = new Error;\nInvalidCharacterError.prototype.name = 'InvalidCharacterError';\n\nfunction preprocess(str) {\n\t// Turn a string into an array of code points,\n\t// following the preprocessing cleanup rules.\n\tvar codepoints = [];\n\tfor(var i = 0; i < str.length; i++) {\n\t\tvar code = str.charCodeAt(i);\n\t\tif(code == 0xd && str.charCodeAt(i+1) == 0xa) {\n\t\t\tcode = 0xa; i++;\n\t\t}\n\t\tif(code == 0xd || code == 0xc) code = 0xa;\n\t\tif(code == 0x0) code = 0xfffd;\n\t\tif(between(code, 0xd800, 0xdbff) && between(str.charCodeAt(i+1), 0xdc00, 0xdfff)) {\n\t\t\t// Decode a surrogate pair into an astral codepoint.\n\t\t\tvar lead = code - 0xd800;\n\t\t\tvar trail = str.charCodeAt(i+1) - 0xdc00;\n\t\t\tcode = Math.pow(2, 21) + lead * Math.pow(2, 10) + trail;\n\t\t}\n\t\tcodepoints.push(code);\n\t}\n\treturn codepoints;\n}\n\nfunction stringFromCode(code) {\n\tif(code <= 0xffff) return String.fromCharCode(code);\n\t// Otherwise, encode astral char as surrogate pair.\n\tcode -= Math.pow(2, 21);\n\tvar lead = Math.floor(code/Math.pow(2, 10)) + 0xd800;\n\tvar trail = code % Math.pow(2, 10); + 0xdc00;\n\treturn String.fromCharCode(lead) + String.fromCharCode(trail);\n}\n\nfunction tokenize(str) {\n\tstr = preprocess(str);\n\tvar i = -1;\n\tvar tokens = new TokenList();\n\tvar code;\n\n\t// Line number information.\n\tvar line = 0;\n\tvar column = 0;\n\t// The only use of lastLineLength is in reconsume().\n\tvar lastLineLength = 0;\n\tvar incrLineno = function() {\n\t\tline += 1;\n\t\tlastLineLength = column;\n\t\tcolumn = 0;\n\t};\n\tvar locStart = {line:line, column:column};\n\n\tvar codepoint = function(i) {\n\t\tif(i >= str.length) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn str[i];\n\t}\n\tvar next = function(num) {\n\t\tif(num === undefined) { num = 1; }\n\t\tif(num > 3) { throw \"Spec Error: no more than three codepoints of lookahead.\"; }\n\t\treturn codepoint(i+num);\n\t};\n\tvar consume = function(num) {\n\t\tif(num === undefined)\n\t\t\tnum = 1;\n\t\ti += num;\n\t\tcode = codepoint(i);\n\t\tif(newline(code)) incrLineno();\n\t\telse column += num;\n\t\t//console.log('Consume '+i+' '+String.fromCharCode(code) + ' 0x' + code.toString(16));\n\t\treturn true;\n\t};\n\tvar reconsume = function() {\n\t\ti -= 1;\n\t\tif (newline(code)) {\n\t\t\tline -= 1;\n\t\t\tcolumn = lastLineLength;\n\t\t} else {\n\t\t\tcolumn -= 1;\n\t\t}\n\t\tlocStart.line = line;\n\t\tlocStart.column = column;\n\t\treturn true;\n\t};\n\tvar eof = function(codepoint) {\n\t\tif(codepoint === undefined) codepoint = code;\n\t\treturn codepoint == -1;\n\t};\n\tvar donothing = function() {};\n\tvar tokenizeerror = function() { console.log(\"Parse error at index \" + i + \", processing codepoint 0x\" + code.toString(16) + \".\");return true; };\n\n\tvar consumeAToken = function() {\n\t\tconsumeComments();\n\t\tconsume();\n\t\tif(whitespace(code)) {\n\t\t\twhile(whitespace(next())) consume();\n\t\t\treturn new WhitespaceToken;\n\t\t}\n\t\telse if(code == 0x22) return consumeAStringToken();\n\t\telse if(code == 0x23) {\n\t\t\tif(namechar(next()) || areAValidEscape(next(1), next(2))) {\n\t\t\t\tvar token = new HashToken();\n\t\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) token.type = \"id\";\n\t\t\t\ttoken.value = consumeAName();\n\t\t\t\treturn token;\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x24) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SuffixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x27) return consumeAStringToken();\n\t\telse if(code == 0x28) return new OpenParenToken();\n\t\telse if(code == 0x29) return new CloseParenToken();\n\t\telse if(code == 0x2a) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new SubstringMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2b) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2c) return new CommaToken();\n\t\telse if(code == 0x2d) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else if(next(1) == 0x2d && next(2) == 0x3e) {\n\t\t\t\tconsume(2);\n\t\t\t\treturn new CDCToken();\n\t\t\t} else if(startsWithAnIdentifier()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x2e) {\n\t\t\tif(startsWithANumber()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeANumericToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x3a) return new ColonToken;\n\t\telse if(code == 0x3b) return new SemicolonToken;\n\t\telse if(code == 0x3c) {\n\t\t\tif(next(1) == 0x21 && next(2) == 0x2d && next(3) == 0x2d) {\n\t\t\t\tconsume(3);\n\t\t\t\treturn new CDOToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x40) {\n\t\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\t\treturn new AtKeywordToken(consumeAName());\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5b) return new OpenSquareToken();\n\t\telse if(code == 0x5c) {\n\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\treconsume();\n\t\t\t\treturn consumeAnIdentlikeToken();\n\t\t\t} else {\n\t\t\t\ttokenizeerror();\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x5d) return new CloseSquareToken();\n\t\telse if(code == 0x5e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new PrefixMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7b) return new OpenCurlyToken();\n\t\telse if(code == 0x7c) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new DashMatchToken();\n\t\t\t} else if(next() == 0x7c) {\n\t\t\t\tconsume();\n\t\t\t\treturn new ColumnToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(code == 0x7d) return new CloseCurlyToken();\n\t\telse if(code == 0x7e) {\n\t\t\tif(next() == 0x3d) {\n\t\t\t\tconsume();\n\t\t\t\treturn new IncludeMatchToken();\n\t\t\t} else {\n\t\t\t\treturn new DelimToken(code);\n\t\t\t}\n\t\t}\n\t\telse if(digit(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeANumericToken();\n\t\t}\n\t\telse if(namestartchar(code)) {\n\t\t\treconsume();\n\t\t\treturn consumeAnIdentlikeToken();\n\t\t}\n\t\telse if(eof()) return new EOFToken();\n\t\telse return new DelimToken(code);\n\t};\n\n\tvar consumeComments = function() {\n\t\twhile(next(1) == 0x2f && next(2) == 0x2a) {\n\t\t\tconsume(2);\n\t\t\twhile(true) {\n\t\t\t\tconsume();\n\t\t\t\tif(code == 0x2a && next() == 0x2f) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(eof()) {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumericToken = function() {\n\t\tvar num = consumeANumber();\n\t\tif(wouldStartAnIdentifier(next(1), next(2), next(3))) {\n\t\t\tvar token = new DimensionToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\ttoken.unit = consumeAName();\n\t\t\treturn token;\n\t\t} else if(next() == 0x25) {\n\t\t\tconsume();\n\t\t\tvar token = new PercentageToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\treturn token;\n\t\t} else {\n\t\t\tvar token = new NumberToken();\n\t\t\ttoken.value = num.value;\n\t\t\ttoken.repr = num.repr;\n\t\t\ttoken.type = num.type;\n\t\t\treturn token;\n\t\t}\n\t};\n\n\tvar consumeAnIdentlikeToken = function() {\n\t\tvar str = consumeAName();\n\t\tif(str.toLowerCase() == \"url\" && next() == 0x28) {\n\t\t\tconsume();\n\t\t\twhile(whitespace(next(1)) && whitespace(next(2))) consume();\n\t\t\tif(next() == 0x22 || next() == 0x27) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else if(whitespace(next()) && (next(2) == 0x22 || next(2) == 0x27)) {\n\t\t\t\treturn new FunctionToken(str);\n\t\t\t} else {\n\t\t\t\treturn consumeAURLToken();\n\t\t\t}\n\t\t} else if(next() == 0x28) {\n\t\t\tconsume();\n\t\t\treturn new FunctionToken(str);\n\t\t} else {\n\t\t\treturn new IdentifierToken(str);\n\t\t}\n\t};\n\n\tvar consumeAStringToken = function(endingCodePoint) {\n\t\tif(endingCodePoint === undefined) endingCodePoint = code;\n\t\tvar string = \"\";\n\t\twhile(consume()) {\n\t\t\tif(code == endingCodePoint || eof()) {\n\t\t\t\treturn new StringToken(string);\n\t\t\t} else if(newline(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\treconsume();\n\t\t\t\treturn new BadStringToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(eof(next())) {\n\t\t\t\t\tdonothing();\n\t\t\t\t} else if(newline(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t} else {\n\t\t\t\t\tstring += stringFromCode(consumeEscape())\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstring += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeAURLToken = function() {\n\t\tvar token = new URLToken(\"\");\n\t\twhile(whitespace(next())) consume();\n\t\tif(eof(next())) return token;\n\t\twhile(consume()) {\n\t\t\tif(code == 0x29 || eof()) {\n\t\t\t\treturn token;\n\t\t\t} else if(whitespace(code)) {\n\t\t\t\twhile(whitespace(next())) consume();\n\t\t\t\tif(next() == 0x29 || eof(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\treturn token;\n\t\t\t\t} else {\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else if(code == 0x22 || code == 0x27 || code == 0x28 || nonprintable(code)) {\n\t\t\t\ttokenizeerror();\n\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\treturn new BadURLToken();\n\t\t\t} else if(code == 0x5c) {\n\t\t\t\tif(startsWithAValidEscape()) {\n\t\t\t\t\ttoken.value += stringFromCode(consumeEscape());\n\t\t\t\t} else {\n\t\t\t\t\ttokenizeerror();\n\t\t\t\t\tconsumeTheRemnantsOfABadURL();\n\t\t\t\t\treturn new BadURLToken();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttoken.value += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeEscape = function() {\n\t\t// Assume the the current character is the \\\n\t\t// and the next code point is not a newline.\n\t\tconsume();\n\t\tif(hexdigit(code)) {\n\t\t\t// Consume 1-6 hex digits\n\t\t\tvar digits = [code];\n\t\t\tfor(var total = 0; total < 5; total++) {\n\t\t\t\tif(hexdigit(next())) {\n\t\t\t\t\tconsume();\n\t\t\t\t\tdigits.push(code);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(whitespace(next())) consume();\n\t\t\tvar value = parseInt(digits.map(function(x){return String.fromCharCode(x);}).join(''), 16);\n\t\t\tif( value > maximumallowedcodepoint ) value = 0xfffd;\n\t\t\treturn value;\n\t\t} else if(eof()) {\n\t\t\treturn 0xfffd;\n\t\t} else {\n\t\t\treturn code;\n\t\t}\n\t};\n\n\tvar areAValidEscape = function(c1, c2) {\n\t\tif(c1 != 0x5c) return false;\n\t\tif(newline(c2)) return false;\n\t\treturn true;\n\t};\n\tvar startsWithAValidEscape = function() {\n\t\treturn areAValidEscape(code, next());\n\t};\n\n\tvar wouldStartAnIdentifier = function(c1, c2, c3) {\n\t\tif(c1 == 0x2d) {\n\t\t\treturn namestartchar(c2) || c2 == 0x2d || areAValidEscape(c2, c3);\n\t\t} else if(namestartchar(c1)) {\n\t\t\treturn true;\n\t\t} else if(c1 == 0x5c) {\n\t\t\treturn areAValidEscape(c1, c2);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithAnIdentifier = function() {\n\t\treturn wouldStartAnIdentifier(code, next(1), next(2));\n\t};\n\n\tvar wouldStartANumber = function(c1, c2, c3) {\n\t\tif(c1 == 0x2b || c1 == 0x2d) {\n\t\t\tif(digit(c2)) return true;\n\t\t\tif(c2 == 0x2e && digit(c3)) return true;\n\t\t\treturn false;\n\t\t} else if(c1 == 0x2e) {\n\t\t\tif(digit(c2)) return true;\n\t\t\treturn false;\n\t\t} else if(digit(c1)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t};\n\tvar startsWithANumber = function() {\n\t\treturn wouldStartANumber(code, next(1), next(2));\n\t};\n\n\tvar consumeAName = function() {\n\t\tvar result = \"\";\n\t\twhile(consume()) {\n\t\t\tif(namechar(code)) {\n\t\t\t\tresult += stringFromCode(code);\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tresult += stringFromCode(consumeEscape());\n\t\t\t} else {\n\t\t\t\treconsume();\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar consumeANumber = function() {\n\t\tvar repr = '';\n\t\tvar type = \"integer\";\n\t\tif(next() == 0x2b || next() == 0x2d) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\twhile(digit(next())) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t}\n\t\tif(next(1) == 0x2e && digit(next(2))) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar c1 = next(1), c2 = next(2), c3 = next(3);\n\t\tif((c1 == 0x45 || c1 == 0x65) && digit(c2)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t} else if((c1 == 0x45 || c1 == 0x65) && (c2 == 0x2b || c2 == 0x2d) && digit(c3)) {\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\tconsume();\n\t\t\trepr += stringFromCode(code);\n\t\t\ttype = \"number\";\n\t\t\twhile(digit(next())) {\n\t\t\t\tconsume();\n\t\t\t\trepr += stringFromCode(code);\n\t\t\t}\n\t\t}\n\t\tvar value = convertAStringToANumber(repr);\n\t\treturn {type:type, value:value, repr:repr};\n\t};\n\n\tvar convertAStringToANumber = function(string) {\n\t\t// CSS's number rules are identical to JS, afaik.\n\t\treturn +string;\n\t};\n\n\tvar consumeTheRemnantsOfABadURL = function() {\n\t\twhile(consume()) {\n\t\t\tif(code == 0x2d || eof()) {\n\t\t\t\treturn;\n\t\t\t} else if(startsWithAValidEscape()) {\n\t\t\t\tconsumeEscape();\n\t\t\t\tdonothing();\n\t\t\t} else {\n\t\t\t\tdonothing();\n\t\t\t}\n\t\t}\n\t};\n\n\n\n\tvar iterationCount = 0;\n\twhile(!eof(next())) {\n\t\ttokens.push(consumeAToken());\n\t\tif(iterationCount++ > str.length*2) throw new Error(\"The CSS Tokenizer is infinite-looping\");\n\t}\n\treturn tokens;\n}\n\nfunction CSSParserToken() { return this; }\nCSSParserToken.prototype.toJSON = function() {\n\treturn {token: this.tokenType};\n}\nCSSParserToken.prototype.toString = function() { return this.tokenType; }\nCSSParserToken.prototype.toCSSString = function() { return ''+this; }\n\nfunction BadStringToken() { return this; }\nBadStringToken.prototype = new CSSParserToken;\nBadStringToken.prototype.tokenType = \"BADSTRING\";\nBadStringToken.prototype.toCSSString = function() { return \"'\"; }\n\nfunction BadURLToken() { return this; }\nBadURLToken.prototype = new CSSParserToken;\nBadURLToken.prototype.tokenType = \"BADURL\";\nBadURLToken.prototype.toCSSString = function() { return \"url(\"; }\n\nfunction WhitespaceToken() { return this; }\nWhitespaceToken.prototype = new CSSParserToken;\nWhitespaceToken.prototype.tokenType = \"WHITESPACE\";\nWhitespaceToken.prototype.toString = function() { return \"WS\"; }\nWhitespaceToken.prototype.toCSSString = function() { return \" \"; }\n\nfunction CDOToken() { return this; }\nCDOToken.prototype = new CSSParserToken;\nCDOToken.prototype.tokenType = \"CDO\";\nCDOToken.prototype.toCSSString = function() { return \"<!--\"; }\n\nfunction CDCToken() { return this; }\nCDCToken.prototype = new CSSParserToken;\nCDCToken.prototype.tokenType = \"CDC\";\nCDCToken.prototype.toCSSString = function() { return \"-->\"; }\n\nfunction ColonToken() { return this; }\nColonToken.prototype = new CSSParserToken;\nColonToken.prototype.tokenType = \":\";\n\nfunction SemicolonToken() { return this; }\nSemicolonToken.prototype = new CSSParserToken;\nSemicolonToken.prototype.tokenType = \";\";\n\nfunction CommaToken() { return this; }\nCommaToken.prototype = new CSSParserToken;\nCommaToken.prototype.tokenType = \",\";\nCommaToken.prototype.value = \";\"; // backwards-compat with DELIM token\n\nfunction GroupingToken() { return this; }\nGroupingToken.prototype = new CSSParserToken;\n\nfunction OpenCurlyToken() { this.value = \"{\"; this.mirror = \"}\"; return this; }\nOpenCurlyToken.prototype = new GroupingToken;\nOpenCurlyToken.prototype.tokenType = \"{\";\n\nfunction CloseCurlyToken() { this.value = \"}\"; this.mirror = \"{\"; return this; }\nCloseCurlyToken.prototype = new GroupingToken;\nCloseCurlyToken.prototype.tokenType = \"}\";\n\nfunction OpenSquareToken() { this.value = \"[\"; this.mirror = \"]\"; return this; }\nOpenSquareToken.prototype = new GroupingToken;\nOpenSquareToken.prototype.tokenType = \"[\";\n\nfunction CloseSquareToken() { this.value = \"]\"; this.mirror = \"[\"; return this; }\nCloseSquareToken.prototype = new GroupingToken;\nCloseSquareToken.prototype.tokenType = \"]\";\n\nfunction OpenParenToken() { this.value = \"(\"; this.mirror = \")\"; return this; }\nOpenParenToken.prototype = new GroupingToken;\nOpenParenToken.prototype.tokenType = \"(\";\n\nfunction CloseParenToken() { this.value = \")\"; this.mirror = \"(\"; return this; }\nCloseParenToken.prototype = new GroupingToken;\nCloseParenToken.prototype.tokenType = \")\";\n\nfunction IncludeMatchToken() { return this; }\nIncludeMatchToken.prototype = new CSSParserToken;\nIncludeMatchToken.prototype.tokenType = \"~=\";\n\nfunction DashMatchToken() { return this; }\nDashMatchToken.prototype = new CSSParserToken;\nDashMatchToken.prototype.tokenType = \"|=\";\n\nfunction PrefixMatchToken() { return this; }\nPrefixMatchToken.prototype = new CSSParserToken;\nPrefixMatchToken.prototype.tokenType = \"^=\";\n\nfunction SuffixMatchToken() { return this; }\nSuffixMatchToken.prototype = new CSSParserToken;\nSuffixMatchToken.prototype.tokenType = \"$=\";\n\nfunction SubstringMatchToken() { return this; }\nSubstringMatchToken.prototype = new CSSParserToken;\nSubstringMatchToken.prototype.tokenType = \"*=\";\n\nfunction ColumnToken() { return this; }\nColumnToken.prototype = new CSSParserToken;\nColumnToken.prototype.tokenType = \"||\";\n\nfunction EOFToken() { return this; }\nEOFToken.prototype = new CSSParserToken;\nEOFToken.prototype.tokenType = \"EOF\";\nEOFToken.prototype.toCSSString = function() { return \"\"; }\n\nfunction DelimToken(code) {\n\tthis.value = stringFromCode(code);\n\treturn this;\n}\nDelimToken.prototype = new CSSParserToken;\nDelimToken.prototype.tokenType = \"DELIM\";\nDelimToken.prototype.toString = function() { return \"DELIM(\"+this.value+\")\"; }\nDelimToken.prototype.toCSSString = function() {\n\treturn (this.value == \"\\\\\") ? \"\\\\\\n\" : this.value;\n}\n\nfunction StringValuedToken() { return this; }\nStringValuedToken.prototype = new CSSParserToken;\nStringValuedToken.prototype.ASCIIMatch = function(str) {\n\treturn this.value.toLowerCase() == str.toLowerCase();\n}\n\nfunction IdentifierToken(val) {\n\tthis.value = val;\n}\nIdentifierToken.prototype = new StringValuedToken;\nIdentifierToken.prototype.tokenType = \"IDENT\";\nIdentifierToken.prototype.toString = function() { return \"IDENT(\"+this.value+\")\"; }\nIdentifierToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value);\n}\n\nfunction FunctionToken(val) {\n\tthis.value = val;\n\tthis.mirror = \")\";\n}\nFunctionToken.prototype = new StringValuedToken;\nFunctionToken.prototype.tokenType = \"FUNCTION\";\nFunctionToken.prototype.toString = function() { return \"FUNCTION(\"+this.value+\")\"; }\nFunctionToken.prototype.toCSSString = function() {\n\treturn escapeIdent(this.value) + \"(\";\n}\n\t\nfunction AtKeywordToken(val) {\n\tthis.value = val;\n}\nAtKeywordToken.prototype = new StringValuedToken;\nAtKeywordToken.prototype.tokenType = \"AT-KEYWORD\";\nAtKeywordToken.prototype.toString = function() { return \"AT(\"+this.value+\")\"; }\nAtKeywordToken.prototype.toCSSString = function() {\n\treturn \"@\" + escapeIdent(this.value);\n}\n\nfunction HashToken(val) {\n\tthis.value = val;\n\tthis.type = \"unrestricted\";\n}\nHashToken.prototype = new StringValuedToken;\nHashToken.prototype.tokenType = \"HASH\";\nHashToken.prototype.toString = function() { return \"HASH(\"+this.value+\")\"; }\nHashToken.prototype.toCSSString = function() {\n\tvar escapeValue = (this.type == \"id\") ? escapeIdent : escapeHash;\n\treturn \"#\" + escapeValue(this.value);\n}\n\nfunction StringToken(val) {\nthis.value = val;\n}\nStringToken.prototype = new StringValuedToken;\nStringToken.prototype.tokenType = \"STRING\";\nStringToken.prototype.toString = function() {\n\treturn '\"' + escapeString(this.value) + '\"';\n}\n\nfunction URLToken(val) {\n\tthis.value = val;\n}\nURLToken.prototype = new StringValuedToken;\nURLToken.prototype.tokenType = \"URL\";\nURLToken.prototype.toString = function() { return \"URL(\"+this.value+\")\"; }\nURLToken.prototype.toCSSString = function() {\n\treturn 'url(\"' + escapeString(this.value) + '\")';\n}\n\nfunction NumberToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n}\nNumberToken.prototype = new CSSParserToken;\nNumberToken.prototype.tokenType = \"NUMBER\";\nNumberToken.prototype.toString = function() {\n\tif(this.type == \"integer\")\n\t\treturn \"INT(\"+this.value+\")\";\n\treturn \"NUMBER(\"+this.value+\")\";\n}\nNumberToken.prototype.toJSON = function() {\n\tvar json = this.constructor.prototype.constructor.prototype.toJSON.call(this);\n\tjson.value = this.value;\n\tjson.type = this.type;\n\tjson.repr = this.repr;\n\treturn json;\n}\nNumberToken.prototype.toCSSString = function() { return this.repr; };\n\nfunction PercentageToken() {\n\tthis.value = null;\n\tthis.repr = \"\";\n}\nPercentageToken.prototype = new CSSParserToken;\nPercentageToken.prototype.tokenType = \"PERCENTAGE\";\nPercentageToken.prototype.toString = function() { return \"PERCENTAGE(\"+this.value+\")\"; }\nPercentageToken.prototype.toCSSString = function() { return this.repr + \"%\"; }\n\nfunction DimensionToken() {\n\tthis.value = null;\n\tthis.type = \"integer\";\n\tthis.repr = \"\";\n\tthis.unit = \"\";\n}\nDimensionToken.prototype = new CSSParserToken;\nDimensionToken.prototype.tokenType = \"DIMENSION\";\nDimensionToken.prototype.toString = function() { return \"DIM(\"+this.value+\",\"+this.unit+\")\"; }\nDimensionToken.prototype.toCSSString = function() {\n\tvar source = this.repr;\n\tvar unit = escapeIdent(this.unit);\n\tif(unit[0].toLowerCase() == \"e\" && (unit[1] == \"-\" || between(unit.charCodeAt(1), 0x30, 0x39))) {\n\t\t// Unit is ambiguous with scinot\n\t\t// Remove the leading \"e\", replace with escape.\n\t\tunit = \"\\\\65 \" + unit.slice(1, unit.length);\n\t}\n\treturn source+unit;\n}\n\nfunction escapeIdent(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tbetween(code, 0x1, 0x1f) || code == 0x7f ||\n\t\t\t(i == 0 && between(code, 0x30, 0x39)) ||\n\t\t\t(i == 1 && between(code, 0x30, 0x39) && firstcode == 0x2d)\n\t\t) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeHash(string) {\n\t// Escapes the contents of \"unrestricted\"-type hash tokens.\n\t// Won't preserve the ID-ness of \"id\"-type hash tokens;\n\t// use escapeIdent() for that.\n\tstring = ''+string;\n\tvar result = '';\n\tvar firstcode = string.charCodeAt(0);\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(\n\t\t\tcode >= 0x80 ||\n\t\t\tcode == 0x2d ||\n\t\t\tcode == 0x5f ||\n\t\t\tbetween(code, 0x30, 0x39) ||\n\t\t\tbetween(code, 0x41, 0x5a) ||\n\t\t\tbetween(code, 0x61, 0x7a)\n\t\t) {\n\t\t\tresult += string[i];\n\t\t} else {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t}\n\t}\n\treturn result;\n}\n\nfunction escapeString(string) {\n\tstring = ''+string;\n\tvar result = '';\n\tfor(var i = 0; i < string.length; i++) {\n\t\tvar code = string.charCodeAt(i);\n\n\t\tif(code == 0x0) {\n\t\t\tthrow new InvalidCharacterError('Invalid character: the input contains U+0000.');\n\t\t}\n\n\t\tif(between(code, 0x1, 0x1f) || code == 0x7f) {\n\t\t\tresult += '\\\\' + code.toString(16) + ' ';\n\t\t} else if(code == 0x22 || code == 0x5c) {\n\t\t\tresult += '\\\\' + string[i];\n\t\t} else {\n\t\t\tresult += string[i];\n\t\t}\n\t}\n\treturn result;\n}\n\n// Exportation.\ncssSyntax.tokenize = tokenize;\ncssSyntax.IdentToken = IdentifierToken;\ncssSyntax.IdentifierToken = IdentifierToken;\ncssSyntax.FunctionToken = FunctionToken;\ncssSyntax.AtKeywordToken = AtKeywordToken;\ncssSyntax.HashToken = HashToken;\ncssSyntax.StringToken = StringToken;\ncssSyntax.BadStringToken = BadStringToken;\ncssSyntax.URLToken = URLToken;\ncssSyntax.BadURLToken = BadURLToken;\ncssSyntax.DelimToken = DelimToken;\ncssSyntax.NumberToken = NumberToken;\ncssSyntax.PercentageToken = PercentageToken;\ncssSyntax.DimensionToken = DimensionToken;\ncssSyntax.IncludeMatchToken = IncludeMatchToken;\ncssSyntax.DashMatchToken = DashMatchToken;\ncssSyntax.PrefixMatchToken = PrefixMatchToken;\ncssSyntax.SuffixMatchToken = SuffixMatchToken;\ncssSyntax.SubstringMatchToken = SubstringMatchToken;\ncssSyntax.ColumnToken = ColumnToken;\ncssSyntax.WhitespaceToken = WhitespaceToken;\ncssSyntax.CDOToken = CDOToken;\ncssSyntax.CDCToken = CDCToken;\ncssSyntax.ColonToken = ColonToken;\ncssSyntax.SemicolonToken = SemicolonToken;\ncssSyntax.CommaToken = CommaToken;\ncssSyntax.OpenParenToken = OpenParenToken;\ncssSyntax.CloseParenToken = CloseParenToken;\ncssSyntax.OpenSquareToken = OpenSquareToken;\ncssSyntax.CloseSquareToken = CloseSquareToken;\ncssSyntax.OpenCurlyToken = OpenCurlyToken;\ncssSyntax.CloseCurlyToken = CloseCurlyToken;\ncssSyntax.EOFToken = EOFToken;\ncssSyntax.CSSParserToken = CSSParserToken;\ncssSyntax.GroupingToken = GroupingToken;\n\n//\n// css parser\n//\n\nfunction TokenStream(tokens) {\n\t// Assume that tokens is an array.\n\tthis.tokens = tokens;\n\tthis.i = -1;\n}\nTokenStream.prototype.tokenAt = function(i) {\n\tif(i < this.tokens.length)\n\t\treturn this.tokens[i];\n\treturn new EOFToken();\n}\nTokenStream.prototype.consume = function(num) {\n\tif(num === undefined) num = 1;\n\tthis.i += num;\n\tthis.token = this.tokenAt(this.i);\n\t//console.log(this.i, this.token);\n\treturn true;\n}\nTokenStream.prototype.next = function() {\n\treturn this.tokenAt(this.i+1);\n}\nTokenStream.prototype.reconsume = function() {\n\tthis.i--;\n}\n\nfunction parseerror(s, msg) {\n\tconsole.log(\"Parse error at token \" + s.i + \": \" + s.token + \".\\n\" + msg);\n\treturn true;\n}\nfunction donothing(){ return true; };\n\nfunction consumeAListOfRules(s, topLevel) {\n\tvar rules = new TokenList();\n\tvar rule;\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn rules;\n\t\t} else if(s.token instanceof CDOToken || s.token instanceof CDCToken) {\n\t\t\tif(topLevel == \"top-level\") continue;\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAnAtRule(s)) rules.push(rule);\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\tif(rule = consumeAStyleRule(s)) rules.push(rule);\n\t\t}\n\t}\n}\n\nfunction consumeAnAtRule(s) {\n\ts.consume();\n\tvar rule = new AtRule(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof SemicolonToken || s.token instanceof EOFToken) {\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAStyleRule(s) {\n\tvar rule = new StyleRule();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken) {\n\t\t\tparseerror(s, \"Hit EOF when trying to parse the prelude of a qualified rule.\");\n\t\t\treturn;\n\t\t} else if(s.token instanceof OpenCurlyToken) {\n\t\t\trule.value = consumeASimpleBlock(s);\n\t\t\treturn rule;\n\t\t} else if(s.token instanceof SimpleBlock && s.token.name == \"{\") {\n\t\t\trule.value = s.token;\n\t\t\treturn rule;\n\t\t} else {\n\t\t\ts.reconsume();\n\t\t\trule.prelude.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAListOfDeclarations(s) {\n\tvar decls = new TokenList();\n\twhile(s.consume()) {\n\t\tif(s.token instanceof WhitespaceToken || s.token instanceof SemicolonToken) {\n\t\t\tdonothing();\n\t\t} else if(s.token instanceof EOFToken) {\n\t\t\treturn decls;\n\t\t} else if(s.token instanceof AtKeywordToken) {\n\t\t\ts.reconsume();\n\t\t\tdecls.push(consumeAnAtRule(s));\n\t\t} else if(s.token instanceof IdentifierToken) {\n\t\t\tvar temp = [s.token];\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\ttemp.push(consumeAComponentValue(s));\n\t\t\tvar decl;\n\t\t\tif(decl = consumeADeclaration(new TokenStream(temp))) decls.push(decl);\n\t\t} else {\n\t\t\tparseerror(s);\n\t\t\ts.reconsume();\n\t\t\twhile(!(s.next() instanceof SemicolonToken || s.next() instanceof EOFToken))\n\t\t\t\tconsumeAComponentValue(s);\n\t\t}\n\t}\n}\n\nfunction consumeADeclaration(s) {\n\t// Assumes that the next input token will be an ident token.\n\ts.consume();\n\tvar decl = new Declaration(s.token.value);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof ColonToken)) {\n\t\tparseerror(s);\n\t\treturn;\n\t} else {\n\t\ts.consume();\n\t}\n\twhile(!(s.next() instanceof EOFToken)) {\n\t\tdecl.value.push(consumeAComponentValue(s));\n\t}\n\tvar foundImportant = false;\n\tfor(var i = decl.value.length - 1; i >= 0; i--) {\n\t\tif(decl.value[i] instanceof WhitespaceToken) {\n\t\t\tcontinue;\n\t\t} else if(decl.value[i] instanceof IdentifierToken && decl.value[i].ASCIIMatch(\"important\")) {\n\t\t\tfoundImportant = true;\n\t\t} else if(foundImportant && decl.value[i] instanceof DelimToken && decl.value[i].value == \"!\") {\n\t\t\tdecl.value.splice(i, decl.value.length);\n\t\t\tdecl.important = true;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn decl;\n}\n\nfunction consumeAComponentValue(s) {\n\ts.consume();\n\tif(s.token instanceof OpenCurlyToken || s.token instanceof OpenSquareToken || s.token instanceof OpenParenToken)\n\t\treturn consumeASimpleBlock(s);\n\tif(s.token instanceof FunctionToken)\n\t\treturn consumeAFunction(s);\n\treturn s.token;\n}\n\nfunction consumeASimpleBlock(s) {\n\tvar mirror = s.token.mirror;\n\tvar block = new SimpleBlock(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || (s.token instanceof GroupingToken && s.token.value == mirror))\n\t\t\treturn block;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tblock.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction consumeAFunction(s) {\n\tvar func = new Func(s.token.value);\n\twhile(s.consume()) {\n\t\tif(s.token instanceof EOFToken || s.token instanceof CloseParenToken)\n\t\t\treturn func;\n\t\telse {\n\t\t\ts.reconsume();\n\t\t\tfunc.value.push(consumeAComponentValue(s));\n\t\t}\n\t}\n}\n\nfunction normalizeInput(input) {\n\tif(typeof input == \"string\")\n\t\treturn new TokenStream(tokenize(input));\n\tif(input instanceof TokenStream)\n\t\treturn input;\n\tif(input.length !== undefined)\n\t\treturn new TokenStream(input);\n\telse throw SyntaxError(input);\n}\n\nfunction parseAStylesheet(s) {\n\ts = normalizeInput(s);\n\tvar sheet = new Stylesheet();\n\tsheet.value = consumeAListOfRules(s, \"top-level\");\n\treturn sheet;\n}\n\nfunction parseAListOfRules(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfRules(s);\n}\n\nfunction parseARule(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tif(s.next() instanceof AtKeywordToken) {\n\t\tvar rule = consumeAnAtRule(s);\n\t} else {\n\t\tvar rule = consumeAStyleRule(s);\n\t\tif(!rule) throw SyntaxError();\n\t}\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken)\n\t\treturn rule;\n\tthrow SyntaxError();\n}\n\nfunction parseADeclaration(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof IdentifierToken)) throw SyntaxError();\n\tvar decl = consumeADeclaration(s);\n\tif(!decl) { throw new SyntaxError() }\n\treturn decl;\n}\n\nfunction parseAListOfDeclarations(s) {\n\ts = normalizeInput(s);\n\treturn consumeAListOfDeclarations(s);\n}\n\nfunction parseAComponentValue(s) {\n\ts = normalizeInput(s);\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(s.next() instanceof EOFToken) throw SyntaxError();\n\tvar val = consumeAComponentValue(s);\n\tif(!val) throw SyntaxError();\n\twhile(s.next() instanceof WhitespaceToken) s.consume();\n\tif(!(s.next() instanceof EOFToken)) throw new SyntaxError();\n\treturn val;\n}\n\nfunction parseAListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar vals = new TokenList();\n\twhile(true) {\n\t\tvar val = consumeAComponentValue(s);\n\t\tif(val instanceof EOFToken)\n\t\t\treturn vals\n\t\telse\n\t\t\tvals.push(val);\n\t}\n}\n\nfunction parseACommaSeparatedListOfComponentValues(s) {\n\ts = normalizeInput(s);\n\tvar listOfCVLs = new TokenList();\n\twhile(true) {\n\t\tvar vals = new TokenList();\n\t\twhile(true) {\n\t\t\tvar val = consumeAComponentValue(s);\n\t\t\tif(val instanceof EOFToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\treturn listOfCVLs;\n\t\t\t} else if(val instanceof CommaToken) {\n\t\t\t\tlistOfCVLs.push(vals);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tvals.push(val);\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction CSSParserRule() { return this; }\nCSSParserRule.prototype.toString = function(indent) {\n\treturn JSON.stringify(this,null,indent);\n}\n\nfunction Stylesheet() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nStylesheet.prototype = new CSSParserRule;\nStylesheet.prototype.type = \"STYLESHEET\";\nStylesheet.prototype.toCSSString = function() { return this.value.toCSSString(\"\\n\"); }\n\nfunction AtRule(name) {\n\tthis.name = name;\n\tthis.prelude = new TokenList();\n\tthis.value = null;\n\treturn this;\n}\nAtRule.prototype = new CSSParserRule;\nAtRule.prototype.toCSSString = function() { \n\tif(this.value) {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + this.value.toCSSString(); \n\t} else {\n\t\treturn \"@\" + escapeIdent(this.name) + \" \" + this.prelude.toCSSString() + '; '; \n\t}\n}\nAtRule.prototype.toStylesheet = function() {\n\treturn this.asStylesheet || (this.asStylesheet = this.value ? parseAStylesheet(this.value.value) : new Stylesheet());\n}\n\nfunction StyleRule() {\n\tthis.prelude = new TokenList(); this.selector = this.prelude;\n\tthis.value = null;\n\treturn this;\n}\nStyleRule.prototype = new CSSParserRule;\nStyleRule.prototype.type = \"STYLE-RULE\";\nStyleRule.prototype.toCSSString = function() {\n\treturn this.prelude.toCSSString() + this.value.toCSSString();\n}\nStyleRule.prototype.getSelector = function() {\n\treturn this.prelude;\n}\nStyleRule.prototype.getDeclarations = function() {\n\tif(!(this.value instanceof SimpleBlock)) { return new TokenList(); }\n\tvar value = this.value.value; return parseAListOfDeclarations(value);\n}\n\n\nfunction Declaration(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\tthis.important = false;\n\treturn this;\n}\nDeclaration.prototype = new CSSParserRule;\nDeclaration.prototype.type = \"DECLARATION\";\nDeclaration.prototype.toCSSString = function() {\n\treturn this.name + ':' + this.value.toCSSString() + '; ';\n}\n\nfunction SimpleBlock(type) {\n\tthis.name = type;\n\tthis.value = new TokenList();\n\treturn this;\n}\nSimpleBlock.prototype = new CSSParserRule;\nSimpleBlock.prototype.type = \"BLOCK\";\nSimpleBlock.prototype.toCSSString = function() {\n\tswitch(this.name) {\n\t\tcase \"(\":\n\t\t\treturn \"(\" + this.value.toCSSString() + \")\";\n\t\t\t\n\t\tcase \"[\":\n\t\t\treturn \"[\" + this.value.toCSSString() + \"]\";\n\t\t\t\n\t\tcase \"{\":\n\t\t\treturn \"{\" + this.value.toCSSString() + \"}\";\n\t\t\n\t\tdefault: //best guess\n\t\t\treturn this.name + this.value.toCSSString() + this.name;\n\t}\n}\n\nfunction Func(name) {\n\tthis.name = name;\n\tthis.value = new TokenList();\n\treturn this;\n}\nFunc.prototype = new CSSParserRule;\nFunc.prototype.type = \"FUNCTION\";\nFunc.prototype.toCSSString = function() {\n\treturn this.name+'('+this.value.toCSSString()+')';\n}\nFunc.prototype.getArguments = function() {\n\tvar args = new TokenList(); var arg = new TokenList(); var value = this.value;\n\tfor(var i = 0; i<value.length; i++) {\n\t\tif(value[i].tokenType == ',') {\n\t\t\targs.push(arg); arg = new TokenList();\n\t\t} else {\n\t\t\targ.push(value[i])\n\t\t}\n\t}\n\tif(args.length > 0 || arg.length > 0) { args.push(arg); }\n\treturn args;\n}\n\nfunction FuncArg() {\n\tthis.value = new TokenList();\n\treturn this;\n}\nFuncArg.prototype = new CSSParserRule;\nFuncArg.prototype.type = \"FUNCTION-ARG\";\nFuncArg.prototype.toCSSString = function() {\n\treturn this.value.toCSSString()+', ';\n}\n\n// Exportation.\ncssSyntax.CSSParserRule = CSSParserRule;\ncssSyntax.Stylesheet = Stylesheet;\ncssSyntax.AtRule = AtRule;\ncssSyntax.StyleRule = StyleRule;\ncssSyntax.Declaration = Declaration;\ncssSyntax.SimpleBlock = SimpleBlock;\ncssSyntax.Func = Func;\ncssSyntax.parseAStylesheet = parseAStylesheet;\ncssSyntax.parseAListOfRules = parseAListOfRules;\ncssSyntax.parseARule = parseARule;\ncssSyntax.parseADeclaration = parseADeclaration;\ncssSyntax.parseAListOfDeclarations = parseAListOfDeclarations;\ncssSyntax.parseAComponentValue = parseAComponentValue;\ncssSyntax.parseAListOfComponentValues = parseAListOfComponentValues;\ncssSyntax.parseACommaSeparatedListOfComponentValues = parseACommaSeparatedListOfComponentValues;\ncssSyntax.parse = parseAStylesheet;\ncssSyntax.parseCSSValue = parseAListOfComponentValues;\n\nreturn cssSyntax;\n\n}());\n\nrequire.define('src/core/css-syntax.js');","void function() {\n\t\n\t// request animation frame\n    var vendors = ['webkit', 'moz', 'ms', 'o'];\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\n        var vp = vendors[i];\n        window.requestAnimationFrame = window[vp+'RequestAnimationFrame'];\n        window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']);\n    }\n    if (!window.requestAnimationFrame || !window.cancelAnimationFrame) {\n\t\t\n\t\t// tick every 16ms\n        var listener_index = 0; var listeners = []; var tmp = []; var tick = function() {\n\t\t\tvar now = +(new Date()); var callbacks = listeners; listeners = tmp;\n\t\t\tfor(var i = 0; i<callbacks.length; i++) { callbacks[i](now); }\n\t\t\tlistener_index += callbacks.length; callbacks.length = 0; tmp = callbacks;\n\t\t\tsetTimeout(tick, 16);\n\t\t}; tick();\n\t\t\n\t\t// add a listener\n        window.requestAnimationFrame = function(callback) {\n            return listener_index + listeners.push(callback);\n        };\n\t\t\n\t\t// remove a listener\n        window.cancelAnimationFrame = function(index) {\n\t\t\tindex -= listener_index; if(index >= 0 && index < listeners.length) {\n\t\t\t\tlisteners[index] = function() {};\n\t\t\t}\n\t\t};\n\t\t\n    }\n\t\n\t// setImmediate\n\tif(!window.setImmediate) {\n\t\twindow.setImmediate = function(f) { return setTimeout(f, 0) };\n\t\twindow.cancelImmediate = clearTimeout;\n\t}\n\t\n}();\n\nrequire.define('src/core/polyfill-dom-requestAnimationFrame.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                 prerequirements of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\n// TODO: improve event streams\n// - look for a few optimizations ideas in gecko/webkit\n// - use arrays in CompositeEventStream to avoid nested debouncings\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t///\n\t/// event stream implementation\n\t/// please note this is required to 'live update' the qSA requests\n\t///\n\tfunction EventStream(connect, disconnect, reconnect) {\n\t\tvar self=this;\n\t\t\n\t\t// validate arguments\n\t\tif(!disconnect) disconnect=function(){};\n\t\tif(!reconnect) reconnect=connect;\n\t\t\n\t\t// high-level states\n\t\tvar isConnected=false;\n\t\tvar isDisconnected=false;\n\t\tvar shouldDisconnect=false;\n\t\t\n\t\t// global variables\n\t\tvar callback=null;\n\t\tvar yieldEvent = function() {\n\t\t\t\n\t\t\t// call the callback function, and pend disposal\n\t\t\tshouldDisconnect=true;\n\t\t\ttry { callback && callback(self); } catch(ex) { setImmediate(function() { throw ex; }); }\n\t\t\t\n\t\t\t// if no action was taken, dispose\n\t\t\tif(shouldDisconnect) { dispose(); }\n\t\t\t\n\t\t}\n\t\t\n\t\t// export the interface\n\t\tvar schedule = this.schedule = function(newCallback) {\n\t\t\n\t\t\t// do not allow to schedule on disconnected event streams\n\t\t\tif(isDisconnected) { throw new Error(\"Cannot schedule on a disconnected event stream\"); }\n\t\t\t\n\t\t\t// do not allow to schedule on already scheduled event streams\n\t\t\tif(isConnected && !shouldDisconnect) { throw new Error(\"Cannot schedule on an already-scheduled event stream\"); }\n\t\t\t\n\t\t\t// schedule the new callback\n\t\t\tcallback=newCallback; shouldDisconnect=false;\n\t\t\t\n\t\t\t// reconnect to the stream\n\t\t\tif(isConnected) {\n\t\t\t\treconnect(yieldEvent);\n\t\t\t} else {\n\t\t\t\tconnect(yieldEvent);\n\t\t\t\tisConnected=true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvar dispose = this.dispose = function() {\n\t\t\n\t\t\t// do not allow to dispose non-connected streams\n\t\t\tif(isConnected) {\n\t\t\t\n\t\t\t\t// disconnect & save resources\n\t\t\t\tdisconnect(); \n\t\t\t\tself=null; yieldEvent=null; callback=null; \n\t\t\t\tisConnected=false; isDisconnected=true; shouldDisconnect=false;\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\t///\n\t/// call a function every frame\n\t///\n\tfunction AnimationFrameEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0;\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = requestAnimationFrame(yieldEvent); },\n\t\t\tfunction disconnect() { cancelAnimationFrame(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every timeout\n\t///\n\tfunction TimeoutEventStream(options) {\n\t\t\n\t\t// flag that says whether the observer is still needed or not\n\t\tvar rid = 0; var timeout=(typeof(options)==\"number\") ? (+options) : (\"timeout\" in options ? +options.timeout : 333);\n\t\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(yieldEvent) { rid = setTimeout(yieldEvent, timeout); },\n\t\t\tfunction disconnect() { clearTimeout(rid); }\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse moves\n\t///\n\tfunction MouseEventStream() {\n\t\tvar self=this; var pointermove = ((\"PointerEvent\" in window) ? \"pointermove\" : ((\"MSPointerEvent\" in window) ? \"MSPointerMove\" : \"mousemove\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointermove, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function every time the mouse is clicked/unclicked\n\t///\n\tfunction MouseButtonEventStream() {\n\t\tvar self=this; \n\t\tvar pointerup = ((\"PointerEvent\" in window) ? \"pointerup\" : ((\"MSPointerEvent\" in window) ? \"MSPointerUp\" : \"mouseup\"));\n\t\tvar pointerdown = ((\"PointerEvent\" in window) ? \"pointerdown\" : ((\"MSPointerEvent\" in window) ? \"MSPointerDown\" : \"mousedown\"));\n\n\t\t// flag that says whether the event is still observed or not\n\t\tvar scheduled = false; var interval=0;\n\t\t\n\t\t// handle the synchronous nature of mutation events\n\t\tvar yieldEvent=null;\n\t\tvar yieldEventDelayed = function() {\n\t\t\tif(scheduled) return;\n\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\twindow.removeEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.removeEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\twindow.addEventListener(pointerup, yieldEventDelayed, true);\n\t\t\t\twindow.addEventListener(pointerdown, yieldEventDelayed, true);\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// call a function whenever the DOM is modified\n\t///\n\tvar DOMUpdateEventStream;\n\tif(\"MutationObserver\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\t \n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: \"subtree\" in options ? !!options.subtree : true, \n\t\t\t\t\tattributes: \"attributes\" in options ? !!options.attributes : true, \n\t\t\t\t\tchildList: \"childList\" in options ? !!options.childList : true, \n\t\t\t\t\tcharacterData: \"characterData\" in options ? !!options.characterData : false\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t\tvar config = { \n\t\t\t\t\tsubtree: true, \n\t\t\t\t\tattributes: true, \n\t\t\t\t\tchildList: true, \n\t\t\t\t\tcharacterData: false\n\t\t\t\t};\n\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t// start the event stream\n\t\t\tvar observer = null;\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(yieldEvent) { if(config) { observer=new MutationObserver(yieldEvent); observer.observe(target,config); target=null; config=null; } },\n\t\t\t\tfunction disconnect() { observer && observer.disconnect(); observer=null; },\n\t\t\t\tfunction reconnect() { observer.takeRecords(); }\n\t\t\t);\n\n\t\t}\n\t} else if(\"MutationEvent\" in window) {\n\t\tDOMUpdateEventStream = function DOMUpdateEventStream(options) {\n\t\t\tvar self=this;\n\n\t\t\t// flag that says whether the event is still observed or not\n\t\t\tvar scheduled = false;\n\t\t\t\n\t\t\t// configuration of the observer\n\t\t\tif(options) {\n\t\t\t\tvar target = \"target\" in options ? options.target : document.documentElement;\n\t\t\t} else {\n\t\t\t\tvar target = document.documentElement;\n\t\t\t}\n\t\t\t\n\t\t\t// handle the synchronous nature of mutation events\n\t\t\tvar yieldEvent=null;\n\t\t\tvar yieldEventDelayed = function() {\n\t\t\t\tif(scheduled || !yieldEventDelayed) return;\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\tscheduled = requestAnimationFrame(yieldEvent);\n\t\t\t}\n\t\t\t\n\t\t\t// start the event stream\n\t\t\tEventStream.call(\n\t\t\t\tthis, \n\t\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\t\tdocument.addEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t},\n\t\t\t\tfunction disconnect() { \n\t\t\t\t\tdocument.removeEventListener(\"DOMContentLoaded\", yieldEventDelayed, false);\n\t\t\t\t\ttarget.removeEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t\tcancelAnimationFrame(scheduled); yieldEventDelayed=null; yieldEvent=null; scheduled=false;\n\t\t\t\t},\n\t\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\t\tyieldEvent=newYieldEvent; scheduled=false;\n\t\t\t\t\ttarget.addEventListener(\"DOMSubtreeModified\", yieldEventDelayed, false);\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t}\n\t} else {\n\t\tDOMUpdateEventStream = AnimationFrameEventStream;\n\t}\n\n\t///\n\t/// call a function every time the focus shifts\n\t///\n\tfunction FocusEventStream() {\n\t\tvar self=this;\n\t\t\n\t\t// handle the filtering nature of focus events\n\t\tvar yieldEvent=null; var previousActiveElement=null; var previousHasFocus=false; var rid=0;\n\t\tvar yieldEventDelayed = function() {\n\t\t\t\n\t\t\t// if the focus didn't change\n\t\t\tif(previousActiveElement==document.activeElement && previousHasFocus==document.hasFocus()) {\n\t\t\t\t\n\t\t\t\t// then do not generate an event\n\t\t\t\tsetTimeout(yieldEventDelayed, 333); // focus that didn't move is expected to stay\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// else, generate one & save config\n\t\t\t\tpreviousActiveElement=document.activeElement;\n\t\t\t\tpreviousHasFocus=document.hasFocus();\n\t\t\t\tyieldEvent();\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 500); // let the document load\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tclearTimeout(rid); yieldEventDelayed=null; yieldEvent=null; rid=0;\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\trid=setTimeout(yieldEventDelayed, 100); // focus by tab navigation moves fast\n\t\t\t}\n\t\t);\n\t\t\n\t}\n\n\t///\n\t/// composite event stream\n\t/// because sometimes you need more than one event source\n\t///\n\tfunction CompositeEventStream(stream1, stream2) {\n\t\tvar self=this;\n\t\t\n\t\t// fields\n\t\tvar yieldEvent=null; var s1=false, s2=false;\n\t\tvar yieldEventWrapper=function(s) { \n\t\t\tif(s==stream1) s1=true;\n\t\t\tif(s==stream2) s2=true;\n\t\t\tif(s1&&s2) return;\n\t\t\tyieldEvent(self);\n\t\t}\n\t\t\n\t\t// start the event stream\n\t\tEventStream.call(\n\t\t\tthis, \n\t\t\tfunction connect(newYieldEvent) {\n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\tstream1.schedule(yieldEventWrapper);\n\t\t\t\tstream2.schedule(yieldEventWrapper);\n\t\t\t},\n\t\t\tfunction disconnect() { \n\t\t\t\tstream1.dispose();\n\t\t\t\tstream2.dispose();\n\t\t\t},\n\t\t\tfunction reconnect(newYieldEvent) { \n\t\t\t\tyieldEvent=newYieldEvent;\n\t\t\t\ts1 && stream1.schedule(yieldEventWrapper);\n\t\t\t\ts2 && stream2.schedule(yieldEventWrapper);\n\t\t\t\ts1 = s2 = false;\n\t\t\t}\n\t\t);\n\t}\n\t\n\treturn {\n\t\tEventStream:                EventStream,\n\t\tAnimationFrameEventStream:  AnimationFrameEventStream,\n\t\tTimeoutEventStream:         TimeoutEventStream,\n\t\tMouseEventStream:           MouseEventStream,\n\t\tMouseButtonEventStream:     MouseButtonEventStream,\n\t\tDOMUpdateEventStream:       DOMUpdateEventStream,\n\t\tFocusEventStream:           FocusEventStream,\n\t\tCompositeEventStream:       CompositeEventStream\n\t};\n\n})(window, document);\nrequire.define('src/core/dom-experimental-event-streams.js');","/////////////////////////////////////////////////////////////////\n////                                                         ////\n////                  Implementation of qSL                  ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n////                                                         ////\n////   Please note that I require querySelectorAll to work   ////\n////                                                         ////\n////   See http://github.com/termi/CSS_selector_engine/      ////\n////   for a polyfill for older browsers                     ////\n////                                                         ////\n/////////////////////////////////////////////////////////////////\n\nmodule.exports = (function(window, document) { \"use strict\";\n\n\t// import dependencies\n\tvar eventStreams = require('src/core/dom-experimental-event-streams.js'),\n\t    DOMUpdateEventStream = eventStreams.DOMUpdateEventStream,\n\t\tAnimationFrameEventStream = eventStreams.AnimationFrameEventStream,\n\t\tCompositeEventStream = eventStreams.CompositeEventStream,\n\t\tFocusEventStream = eventStreams.FocusEventStream,\n\t\tMouseButtonEventStream = eventStreams.MouseButtonEventStream,\n\t\tTimeoutEventStream = eventStreams.TimeoutEventStream,\n\t\tMouseEventStream = eventStreams.MouseEventStream;\n\n\t///\n\t/// the live querySelectorAll implementation\n\t///\n\tfunction querySelectorLive(selector, handler, root) {\n\t\t\n\t\t// restrict the selector coverage to some part of the DOM only\n\t\tvar root = root || document;\n\t\t\n\t\t// TODO: make use of \"mutatedAncestorElement\" to update only elements inside the mutated zone\n\t\t\n\t\tvar currentElms = [];\n\t\tvar loop = function loop(eventStream) {\n\t\t\t\n\t\t\t// schedule next run\n\t\t\teventStream.schedule(loop);\n\t\t\t\n\t\t\t// update elements matching the selector\n\t\t\tvar newElms = [];\n\t\t\tvar oldElms = currentElms.slice(0);\n\t\t\tvar temps = root.querySelectorAll(selector);\n\t\t\tfor(var i=newElms.length=temps.length; i;) { newElms.push(temps[--i]); }\n\t\t\tcurrentElms = newElms.slice(0); temps=null;\n\t\t\t\n\t\t\t// first let's clear all elements that have been removed from the document\n\t\t\toldElms = oldElms.filter(function(e) {\n\t\t\t\t\n\t\t\t\t// check whether the current element is still there\n\t\t\t\tvar isStillInDocument = (\n\t\t\t\t\te===document.documentElement \n\t\t\t\t\t|| document.documentElement.contains(e)\n\t\t\t\t);\n\t\t\t\t\n\t\t\t\tif(isStillInDocument) {\n\t\t\t\t\t\n\t\t\t\t\t// NEED_COMPARE: we will compare this element to the new list\n\t\t\t\t\treturn true;\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(e); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\treturn false;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t// now pop and match until both lists are exhausted\n\t\t\t// (we use the fact the returned elements are in document order)\n\t\t\tvar el1 = oldElms.pop();\n\t\t\tvar el2 = newElms.pop();\n\t\t\twhile(el1 || el2) {\n\t\t\t\tif(el1===el2) {\n\t\t\t\t\n\t\t\t\t\t// MATCH: pop both elements\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else if (el2 && /*el1 is after el2*/(!el1||(el2.compareDocumentPosition(el1) & (1|2|8|32))===0)) {\n\t\t\t\t\t\n\t\t\t\t\t// INSERT: raise onadded, pop new elements\n\t\t\t\t\ttry { handler.onadded && handler.onadded(el2); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel2 = newElms.pop();\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\n\t\t\t\t\t// DELETE: raise onremoved, pop old elements\n\t\t\t\t\ttry { handler.onremoved && handler.onremoved(el1); } catch(ex) { setImmediate(function() {throw ex})}\n\t\t\t\t\tel1 = oldElms.pop();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t};\n\t\t\n\t\t// use the event stream that best matches our needs\n\t\tvar simpleSelector = selector.replace(/:(dir|lang|root|empty|blank|nth-child|nth-last-child|first-child|last-child|only-child|nth-of-type|nth-last-of-child|fist-of-type|last-of-type|only-of-type|not|matches|default)\\b/gi,'')\n\t\tvar eventStream; if(simpleSelector.indexOf(':') == -1) {\n\t\t\t\n\t\t\t// static stuff only\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// dynamic stuff too\n\t\t\teventStream = new DOMUpdateEventStream({target:root}); \n\t\t\tif(DOMUpdateEventStream != AnimationFrameEventStream) {\n\t\t\t\n\t\t\t\t// detect the presence of focus-related pseudo-classes\n\t\t\t\tvar reg = /:(focus|active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew FocusEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tvar reg = /:(focus)\\b/gi;\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, ''); // :active has other hooks\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-button-related pseudo-classes\n\t\t\t\tvar reg = /:(active)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseButtonEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\n\t\t\t\t// detect the presence of user input pseudo-classes\n\t\t\t\tvar reg = /:(target|checked|indeterminate|valid|invalid|in-range|out-of-range|user-error)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// slowly dynamic stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(250),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\n\t\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of nearly-static pseudo-classes\n\t\t\t\tvar reg = /:(any-link|link|visited|local-link|enabled|disabled|read-only|read-write|required|optional)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// nearly static stuff do happen\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew TimeoutEventStream(333),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of mouse-related pseudo-classes\n\t\t\t\tvar reg = /:(hover)\\b/gi;\n\t\t\t\tif(reg.test(simpleSelector)) {\n\t\t\t\t\t\n\t\t\t\t\t// mouse events should be listened\n\t\t\t\t\teventStream = new CompositeEventStream(\n\t\t\t\t\t\tnew MouseEventStream(),\n\t\t\t\t\t\teventStream\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\t// simplify simpleSelector\n\t\t\t\t\tsimpleSelector = simpleSelector.replace(reg, '');\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// detect the presence of unknown pseudo-classes\n\t\t\t\tif(simpleSelector.indexOf(':') !== -1) {\n\t\t\t\t\t\n\t\t\t\t\t// other stuff do happen, too (let's give up on events)\n\t\t\t\t\teventStream = new AnimationFrameEventStream(); \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// start handling changes\n\t\tloop(eventStream);\n\t\t\n\t}\n\t\n\treturn querySelectorLive;\n\t\n})(window, document);\nrequire.define('src/core/dom-query-selector-live.js');","// TODO: comment about the 'no_auto_stylesheet_detection' flag?\n\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  // import dependencies\n  require('src/core/polyfill-dom-console.js')\n  require('src/core/polyfill-dom-requestAnimationFrame.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var domEvents = require('src/core/dom-events.js')\n  var querySelectorLive = require('src/core/dom-query-selector-live.js')\n\n  // define the module\n  var cssCascade = {\n    //\n    // returns the priority of a unique selector (NO COMMA!)\n    // { the return value is an integer, with the same formula as webkit }\n    //\n    computeSelectorPriorityOf: function computeSelectorPriorityOf(selector) {\n      if (typeof selector == 'string')\n        selector = cssSyntax.parse(selector.trim() + '{}').value[0].selector\n\n      var numberOfIDs = 0\n      var numberOfClasses = 0\n      var numberOfTags = 0\n\n      // TODO: improve this parser, or find one on the web\n      for (var i = 0; i < selector.length; i++) {\n        if (selector[i] instanceof cssSyntax.IdentifierToken) {\n          numberOfTags++\n        } else if (selector[i] instanceof cssSyntax.DelimToken) {\n          if (selector[i].value == '.') {\n            numberOfClasses++\n            i++\n          }\n        } else if (selector[i] instanceof cssSyntax.ColonToken) {\n          if (selector[++i] instanceof cssSyntax.ColonToken) {\n            numberOfTags++\n            i++\n          } else if (\n            selector[i] instanceof cssSyntax.Func &&\n            /^(not|matches)$/i.test(selector[i].name)\n          ) {\n            var nestedPriority = this.computeSelectorPriorityOf(selector[i].value)\n            numberOfTags += nestedPriority % 256\n            nestedPriority /= 256\n            numberOfClasses += nestedPriority % 256\n            nestedPriority /= 256\n            numberOfIDs += nestedPriority\n          } else {\n            numberOfClasses++\n          }\n        } else if (selector[i] instanceof cssSyntax.SimpleBlock) {\n          if (selector[i].name == '[') {\n            numberOfClasses++\n          }\n        } else if (selector[i] instanceof cssSyntax.HashToken) {\n          numberOfIDs++\n        } else {\n          // TODO: stop ignoring unknown symbols?\n        }\n      }\n\n      if (numberOfIDs > 255) numberOfIDs = 255\n      if (numberOfClasses > 255) numberOfClasses = 255\n      if (numberOfTags > 255) numberOfTags = 255\n\n      return (numberOfIDs * 256 + numberOfClasses) * 256 + numberOfTags\n    },\n\n    //\n    // returns an array of the css rules matching an element\n    //\n    findAllMatchingRules: function findAllMatchingRules(element) {\n      return this.findAllMatchingRulesWithPseudo(element)\n    },\n\n    //\n    // returns an array of the css rules matching a pseudo-element\n    //\n    findAllMatchingRulesWithPseudo: function findAllMatchingRules(element, pseudo) {\n      pseudo = pseudo ? ('' + pseudo).toLowerCase() : pseudo\n\n      // let's look for new results if needed...\n      var results = []\n\n      // walk the whole stylesheet...\n      var visit = function(rules) {\n        try {\n          for (var r = rules.length; r--; ) {\n            var rule = rules[r]\n\n            // media queries hook\n            if (rule.disabled) continue\n\n            if (rule instanceof cssSyntax.StyleRule) {\n              // consider each selector independently\n              var subrules = rule.subRules || cssCascade.splitRule(rule)\n              for (var sr = subrules.length; sr--; ) {\n                var selector = subrules[sr].selector\n                  .toCSSString()\n                  .replace(/ *(\\/\\*\\*\\/|  ) */g, ' ')\n                  .trim()\n                if (pseudo) {\n                  // WE ONLY ACCEPT SELECTORS ENDING WITH THE PSEUDO\n                  var selectorLow = selector.toLowerCase()\n                  var newLength = selector.length - pseudo.length - 1\n                  if (newLength <= 0) continue\n\n                  if (selectorLow.lastIndexOf('::' + pseudo) == newLength - 1) {\n                    selector = selector.substr(0, newLength - 1)\n                  } else if (selectorLow.lastIndexOf(':' + pseudo) == newLength) {\n                    selector = selector.substr(0, newLength)\n                  } else {\n                    continue\n                  }\n\n                  // fix selectors like \"#element > :first-child ~ ::before\"\n                  if (selector.trim().length == 0) {\n                    selector = '*'\n                  } else if (selector[selector.length - 1] == ' ') {\n                    selector += '*'\n                  } else if (selector[selector.length - 1] == '+') {\n                    selector += '*'\n                  } else if (selector[selector.length - 1] == '>') {\n                    selector += '*'\n                  } else if (selector[selector.length - 1] == '~') {\n                    selector += '*'\n                  }\n                }\n\n                // look if the selector matches\n                var isMatching = false\n                try {\n                  if (element.matches) isMatching = element.matches(selector)\n                  else if (element.matchesSelector) isMatching = element.matchesSelector(selector)\n                  else if (element.oMatchesSelector) isMatching = element.oMatchesSelector(selector)\n                  else if (element.msMatchesSelector)\n                    isMatching = element.msMatchesSelector(selector)\n                  else if (element.mozMatchesSelector)\n                    isMatching = element.mozMatchesSelector(selector)\n                  else if (element.webkitMatchesSelector)\n                    isMatching = element.webkitMatchesSelector(selector)\n                  else {\n                    throw new Error('no element.matches?')\n                  }\n                } catch (ex) {\n                  // debugger\n                  // setImmediate(function() {\n                  //   throw ex\n                  // })\n                }\n\n                // if yes, add it to the list of matched selectors\n                if (isMatching) {\n                  results.push(subrules[sr])\n                }\n              }\n            } else if (rule instanceof cssSyntax.AtRule && rule.name == 'media') {\n              // visit them\n              visit(rule.toStylesheet().value)\n            }\n          }\n        } catch (ex) {\n          // setImmediate(function() {\n          //   throw ex\n          // })\n        }\n      }\n\n      for (var s = cssCascade.stylesheets.length; s--; ) {\n        var rules = cssCascade.stylesheets[s]\n        visit(rules)\n      }\n\n      return results\n    },\n\n    //\n    // a list of all properties supported by the current browser\n    //\n    allCSSProperties: null,\n    getAllCSSProperties: function getAllCSSProperties() {\n      if (this.allCSSProperties) return this.allCSSProperties\n\n      // get all claimed properties\n      var s = getComputedStyle(document.documentElement)\n      var ps = new Array(s.length)\n      for (var i = s.length; i--; ) {\n        ps[i] = s[i]\n      }\n\n      // FIX A BUG WHERE WEBKIT DOESN'T REPORT ALL PROPERTIES\n      if (ps.indexOf('content') == -1) {\n        ps.push('content')\n      }\n      if (ps.indexOf('counter-reset') == -1) {\n        ps.push('counter-reset')\n        ps.push('counter-increment')\n\n        // FIX A BUG WHERE WEBKIT RETURNS SHIT FOR THE COMPUTED VALUE OF COUNTER-RESET\n        cssCascade.computationUnsafeProperties['counter-reset'] = true\n      }\n\n      // save in a cache for faster access the next times\n      return (this.allCSSProperties = ps)\n    },\n\n    //\n    // those properties are not safe for computation->specified round-tripping\n    //\n    computationUnsafeProperties: {\n      bottom: true,\n      direction: true,\n      display: true,\n      'font-size': true,\n      height: true,\n      left: true,\n      'line-height': true,\n      'margin-left': true,\n      'margin-right': true,\n      'margin-bottom': true,\n      'margin-top': true,\n      'max-height': true,\n      'max-width': true,\n      'min-height': true,\n      'min-width': true,\n      'padding-left': true,\n      'padding-right': true,\n      'padding-bottom': true,\n      'padding-top': true,\n      right: true,\n      'text-align': true,\n      'text-align-last': true,\n      top: true,\n      width: true,\n      __proto__: null\n    },\n\n    //\n    // a list of property we should inherit...\n    //\n    inheritingProperties: {\n      'border-collapse': true,\n      'border-spacing': true,\n      'caption-side': true,\n      color: true,\n      cursor: true,\n      direction: true,\n      'empty-cells': true,\n      'font-family': true,\n      'font-size': true,\n      'font-style': true,\n      'font-variant': true,\n      'font-weight': true,\n      font: true,\n      'letter-spacing': true,\n      'line-height': true,\n      'list-style-image': true,\n      'list-style-position': true,\n      'list-style-type': true,\n      'list-style': true,\n      orphans: true,\n      quotes: true,\n      'text-align': true,\n      'text-indent': true,\n      'text-transform': true,\n      visibility: true,\n      'white-space': true,\n      widows: true,\n      'word-break': true,\n      'word-spacing': true,\n      'word-wrap': true,\n      __proto__: null\n    },\n\n    //\n    // returns the default style for a tag\n    //\n    defaultStylesForTag: Object.create ? Object.create(null) : {},\n    getDefaultStyleForTag: function getDefaultStyleForTag(tagName) {\n      // get result from cache\n      var result = this.defaultStylesForTag[tagName]\n      if (result) return result\n\n      // create dummy virtual element\n      var element = document.createElement(tagName)\n      var style = (this.defaultStylesForTag[tagName] = getComputedStyle(element))\n      if (style.display) return style\n\n      // webkit fix: insert the dummy element anywhere (head -> display:none)\n      document.head.insertBefore(element, document.head.firstChild)\n      return style\n    },\n\n    //\n    // returns the specified style of an element.\n    // REMARK: may or may not unwrap \"inherit\" and \"initial\" depending on implementation\n    // REMARK: giving \"matchedRules\" as a parameter allow you to mutualize the \"findAllMatching\" rules calls\n    //\n    getSpecifiedStyle: function getSpecifiedStyle(element, cssPropertyName, matchedRules) {\n      // hook for css regions\n      var fragmentSource\n      if ((fragmentSource = element.getAttribute('data-css-regions-fragment-of'))) {\n        fragmentSource = document.querySelector(\n          '[data-css-regions-fragment-source=\"' + fragmentSource + '\"]'\n        )\n        if (fragmentSource) return cssCascade.getSpecifiedStyle(fragmentSource, cssPropertyName)\n      }\n\n      // give IE a thumbs up for this!\n      if (element.currentStyle && !window.opera) {\n        // ask IE to manage the style himself...\n        var bestValue =\n          element.myStyle[cssPropertyName] || element.currentStyle[cssPropertyName] || ''\n\n        // return a parsed representation of the value\n        return cssSyntax.parseAListOfComponentValues(bestValue)\n      } else {\n        // TODO: support the \"initial\" and \"inherit\" things?\n\n        // first, let's try inline style as it's fast and generally accurate\n        // TODO: what if important rules override that?\n        try {\n          if (\n            (bestValue =\n              element.style.getPropertyValue(cssPropertyName) || element.myStyle[cssPropertyName])\n          ) {\n            return cssSyntax.parseAListOfComponentValues(bestValue)\n          }\n        } catch (ex) {}\n\n        // find all relevant style rules\n        var isBestImportant = false\n        var bestPriority = 0\n        var bestValue = new cssSyntax.TokenList()\n        var rules =\n          matchedRules ||\n          (cssPropertyName in cssCascade.monitoredProperties\n            ? element.myMatchedRules || []\n            : cssCascade.findAllMatchingRules(element))\n\n        var visit = function(rules) {\n          for (var i = rules.length; i--; ) {\n            // media queries hook\n            if (rules[i].disabled) continue\n\n            // find a relevant declaration\n            if (rules[i] instanceof cssSyntax.StyleRule) {\n              var decls = rules[i].getDeclarations()\n              for (var j = decls.length - 1; j >= 0; j--) {\n                if (decls[j].type == 'DECLARATION') {\n                  if (decls[j].name == cssPropertyName) {\n                    // only works if selectors containing a \",\" are deduplicated\n                    var currentPriority = cssCascade.computeSelectorPriorityOf(rules[i].selector)\n\n                    if (isBestImportant) {\n                      // only an important declaration can beat another important declaration\n                      if (decls[j].important) {\n                        if (currentPriority >= bestPriority) {\n                          bestPriority = currentPriority\n                          bestValue = decls[j].value\n                        }\n                      }\n                    } else {\n                      // an important declaration beats any non-important declaration\n                      if (decls[j].important) {\n                        isBestImportant = true\n                        bestPriority = currentPriority\n                        bestValue = decls[j].value\n                      } else {\n                        // the selector priority has to be higher otherwise\n                        if (currentPriority >= bestPriority) {\n                          bestPriority = currentPriority\n                          bestValue = decls[j].value\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            } else if (rules[i] instanceof cssSyntax.AtRule && rules[i].name == 'media') {\n              // visit them\n              visit(rules[i].toStylesheet())\n            }\n          }\n        }\n        visit(rules)\n\n        // return our best guess...\n        return bestValue || null\n      }\n    },\n\n    //\n    // start monitoring a new stylesheet\n    // (should usually not be used because stylesheets load automatically)\n    //\n    stylesheets: [],\n    loadStyleSheet: function loadStyleSheet(cssText, i) {\n      // load in order\n\n      // parse the stylesheet content\n      var rules = cssSyntax.parse(cssText).value\n\n      // add the stylesheet into the object model\n      if (typeof i !== 'undefined') {\n        cssCascade.stylesheets[i] = rules\n      } else {\n        i = cssCascade.stylesheets.push(rules)\n      }\n\n      // make sure to monitor the required rules\n      cssCascade.startMonitoringStylesheet(rules)\n    },\n\n    //\n    // start monitoring a new stylesheet\n    // (should usually not be used because stylesheets load automatically)\n    //\n    loadStyleSheetTag: function loadStyleSheetTag(stylesheet, i) {\n      if (stylesheet.hasAttribute('data-css-polyfilled')) {\n        return\n      }\n\n      if (stylesheet.tagName == 'LINK') {\n        // oh, no, we have to download it...\n        try {\n          // dummy value in-between\n          cssCascade.stylesheets[i] = new cssSyntax.TokenList()\n\n          //\n          var xhr = new XMLHttpRequest()\n          xhr.href = stylesheet.href\n          xhr.open('GET', stylesheet.href, true)\n          xhr.ruleIndex = i\n          xhr.onreadystatechange = function() {\n            if (this.readyState == 4) {\n              // status 0 is a webkit bug for local files\n              if (this.status == 200 || this.status == 0) {\n                cssCascade.loadStyleSheet(this.responseText, this.ruleIndex)\n              } else {\n                cssConsole.log('css-cascade polyfill failled to load: ' + this.href)\n              }\n            }\n          }\n          xhr.send()\n        } catch (ex) {\n          cssConsole.log('css-cascade polyfill failled to load: ' + stylesheet.href)\n        }\n      } else {\n        // oh, cool, we just have to parse the content!\n        cssCascade.loadStyleSheet(stylesheet.textContent, i)\n      }\n\n      // mark the stylesheet as ok\n      stylesheet.setAttribute('data-css-polyfilled', true)\n    },\n\n    //\n    // calling this function will load all currently existing stylesheets in the document\n    // (should usually not be used because stylesheets load automatically)\n    //\n    selectorForStylesheets:\n      'style:not([data-no-css-polyfill]):not([data-css-polyfilled]), link[rel=stylesheet]:not([data-no-css-polyfill]):not([data-css-polyfilled])',\n    loadAllStyleSheets: function loadAllStyleSheets() {\n      // for all stylesheets in the <head> tag...\n      var head = document.head || document.documentElement\n      var stylesheets = head.querySelectorAll(cssCascade.selectorForStylesheets)\n\n      var intialLength = this.stylesheets.length\n      this.stylesheets.length += stylesheets.length\n\n      // for all of them...\n      for (var i = stylesheets.length; i--; ) {\n        //\n        // load the stylesheet\n        //\n        var stylesheet = stylesheets[i]\n        cssCascade.loadStyleSheetTag(stylesheet, intialLength + i)\n      }\n    },\n\n    //\n    // this is where we store event handlers for monitored properties\n    //\n    monitoredProperties: Object.create ? Object.create(null) : {},\n    monitoredPropertiesHandler: {\n      onupdate: function(element, rule) {\n        // we need to find all regexps that matches\n        var mps = cssCascade.monitoredProperties\n        var decls = rule.getDeclarations()\n        for (var j = decls.length - 1; j >= 0; j--) {\n          if (decls[j].type == 'DECLARATION') {\n            if (decls[j].name in mps) {\n              // call all handlers waiting for this\n              var hs = mps[decls[j].name]\n              for (var hi = hs.length; hi--; ) {\n                hs[hi].onupdate(element, rule)\n              }\n\n              // don't call twice\n              break\n            }\n          }\n        }\n      }\n    },\n\n    //\n    // add an handler to some properties (aka fire when their value *MAY* be affected)\n    // REMARK: because this event does not promise the value changed, you may want to figure it out before relayouting\n    //\n    startMonitoringProperties: function startMonitoringProperties(properties, handler) {\n      for (var i = properties.length; i--; ) {\n        var property = properties[i]\n        var handlers =\n          cssCascade.monitoredProperties[property] ||\n          (cssCascade.monitoredProperties[property] = [])\n        handlers.push(handler)\n      }\n\n      for (var s = 0; s < cssCascade.stylesheets.length; s++) {\n        var currentStylesheet = cssCascade.stylesheets[s]\n        cssCascade.startMonitoringStylesheet(currentStylesheet)\n      }\n    },\n\n    //\n    // calling this function will detect monitored rules in the stylesheet\n    // (should usually not be used because stylesheets load automatically)\n    //\n    startMonitoringStylesheet: function startMonitoringStylesheet(rules) {\n      for (var i = 0; i < rules.length; i++) {\n        // only consider style rules\n        if (rules[i] instanceof cssSyntax.StyleRule) {\n          // try to see if the current rule is worth monitoring\n          if (rules[i].isMonitored) continue\n\n          // for that, let's see if we can find a declaration we should watch\n          var decls = rules[i].getDeclarations()\n          for (var j = decls.length - 1; j >= 0; j--) {\n            if (decls[j].type == 'DECLARATION') {\n              if (decls[j].name in cssCascade.monitoredProperties) {\n                // if we found some, start monitoring\n                cssCascade.startMonitoringRule(rules[i])\n                break\n              }\n            }\n          }\n        } else if (rules[i] instanceof cssSyntax.AtRule) {\n          // handle @media\n          if (rules[i].name == 'media' && window.matchMedia) {\n            cssCascade.startMonitoringMedia(rules[i])\n          }\n        }\n      }\n    },\n\n    //\n    // calling this function will detect media query updates and fire events accordingly\n    // (should usually not be used because stylesheets load automatically)\n    //\n    startMonitoringMedia: function startMonitoringMedia(atrule) {\n      // try {\n      //   var media = window.matchMedia(atrule.prelude.toCSSString())\n      //   // update all the rules when needed\n      //   var rules = atrule.toStylesheet().value\n      //   cssCascade.updateMedia(rules, !media.matches, false)\n      //   media.addListener(function(newMedia) {\n      //     cssCascade.updateMedia(rules, !newMedia.matches, true)\n      //   })\n      //   // it seems I like taking risks...\n      //   cssCascade.startMonitoringStylesheet(rules)\n      // } catch (ex) {\n      //   setImmediate(function() {\n      //     throw ex\n      //   })\n      // }\n    },\n\n    //\n    // define what happens when a media query status changes\n    //\n    updateMedia: function(rules, disabled, update) {\n      for (var i = rules.length; i--; ) {\n        rules[i].disabled = disabled\n        // TODO: should probably get handled by a setter on the rule...\n        var sr = rules[i].subRules\n        if (sr) {\n          for (var j = sr.length; j--; ) {\n            sr[j].disabled = disabled\n          }\n        }\n      }\n\n      // in case of update, all elements matching the selector went potentially updated...\n      if (update) {\n        for (var i = rules.length; i--; ) {\n          var els = document.querySelectorAll(rules[i].selector.toCSSString())\n          for (var j = els.length; j--; ) {\n            cssCascade.monitoredPropertiesHandler.onupdate(els[j], rules[i])\n          }\n        }\n      }\n    },\n\n    //\n    // splits a rule if it has multiple selectors\n    //\n    splitRule: function splitRule(rule) {\n      // create an array for all the subrules\n      var rules = []\n\n      // fill the array\n      var currentRule = new cssSyntax.StyleRule()\n      currentRule.disabled = rule.disabled\n      for (var i = 0; i < rule.selector.length; i++) {\n        if (rule.selector[i] instanceof cssSyntax.DelimToken && rule.selector[i].value == ',') {\n          currentRule.value = rule.value\n          rules.push(currentRule)\n          currentRule = new cssSyntax.StyleRule()\n          currentRule.disabled = rule.disabled\n        } else {\n          currentRule.selector.push(rule.selector[i])\n        }\n      }\n      currentRule.value = rule.value\n      rules.push(currentRule)\n\n      // save the result of the split as subrules\n      return (rule.subRules = rules)\n    },\n\n    //\n    // ask the css-selector implementation to notify changes for the rules\n    //\n    startMonitoringRule: function startMonitoringRule(rule) {\n      // avoid monitoring rules twice\n      if (!rule.isMonitored) {\n        rule.isMonitored = true\n      } else {\n        return\n      }\n\n      // split the rule if it has multiple selectors\n      var rules = rule.subRules || cssCascade.splitRule(rule)\n\n      // monitor the rules\n      for (var i = 0; i < rules.length; i++) {\n        rule = rules[i]\n        querySelectorLive(rule.selector.toCSSString(), {\n          onadded: function(e) {\n            // add the rule to the matching list of this element\n            ;(e.myMatchedRules = e.myMatchedRules || []).unshift(rule) // TODO: does not respect priority order\n\n            // generate an update event\n            cssCascade.monitoredPropertiesHandler.onupdate(e, rule)\n          },\n          onremoved: function(e) {\n            // remove the rule from the matching list of this element\n            if (e.myMatchedRules) e.myMatchedRules.splice(e.myMatchedRules.indexOf(rule), 1)\n\n            // generate an update event\n            cssCascade.monitoredPropertiesHandler.onupdate(e, rule)\n          }\n        })\n      }\n    },\n\n    //\n    // converts a css property name to a javascript name\n    //\n    toCamelCase: function toCamelCase(variable) {\n      return variable.replace(/-([a-z])/g, function(str, letter) {\n        return letter.toUpperCase()\n      })\n    },\n\n    //\n    // add some magic code to support properties on the style interface\n    //\n    polyfillStyleInterface: function(cssPropertyName) {\n      var prop = {\n        get: function() {\n          // check we know which element we work on\n          try {\n            if (!this.parentElement)\n              throw new Error(\n                'Please use the anHTMLElement.myStyle property to get polyfilled properties'\n              )\n          } catch (ex) {\n            setImmediate(function() {\n              throw ex\n            })\n            return ''\n          }\n\n          try {\n            // non-computed style: return the local style of the element\n            this.clip = this.clip === undefined ? '' : this.clip\n            return this.parentElement.getAttribute('data-style-' + cssPropertyName)\n          } catch (ex) {\n            // computed style: return the specified style of the element\n            var value = cssCascade.getSpecifiedStyle(\n              this.parentElement,\n              cssPropertyName,\n              undefined,\n              true\n            )\n            return value && value.length > 0 ? value.toCSSString() : ''\n          }\n        },\n\n        set: function(v) {\n          // check that the style is writable\n          this.clip = this.clip === undefined ? '' : this.clip\n\n          // check we know which element we work on\n          try {\n            if (!this.parentElement)\n              throw new Error(\n                'Please use the anHTMLElement.myStyle property to set polyfilled properties'\n              )\n          } catch (ex) {\n            setImmediate(function() {\n              throw ex\n            })\n            return\n          }\n\n          // modify the local style of the element\n          if (this.parentElement.getAttribute('data-style-' + cssPropertyName) != v) {\n            this.parentElement.setAttribute('data-style-' + cssPropertyName, v)\n          }\n        }\n      }\n\n      var styleProtos = []\n      try {\n        styleProtos.push(\n          Object.getPrototypeOf(document.documentElement.style) || CSSStyleDeclaration\n        )\n      } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(getComputedStyle(document.documentElement))); } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(document.documentElement.currentStyle)); } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(document.documentElement.runtimeStyle)); } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(document.documentElement.specifiedStyle)); } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(document.documentElement.cascadedStyle)); } catch (ex) {}\n      //try { styleProtos.push(Object.getPrototypeOf(document.documentElement.usedStyle)); } catch (ex) {}\n\n      for (var i = styleProtos.length; i--; ) {\n        var styleProto = styleProtos[i]\n        Object.defineProperty(styleProto, cssPropertyName, prop)\n        Object.defineProperty(styleProto, cssCascade.toCamelCase(cssPropertyName), prop)\n      }\n      cssCascade.startMonitoringRule(\n        cssSyntax.parse('[style*=\"' + cssPropertyName + '\"]{' + cssPropertyName + ':attr(style)}')\n          .value[0]\n      )\n      cssCascade.startMonitoringRule(\n        cssSyntax.parse('[data-style-' + cssPropertyName + ']{' + cssPropertyName + ':attr(style)}')\n          .value[0]\n      )\n\n      // add to the list of polyfilled properties...\n      cssCascade.getAllCSSProperties().push(cssPropertyName)\n      cssCascade.computationUnsafeProperties[cssPropertyName] = true\n    }\n  }\n\n  //\n  // polyfill for browsers not support CSSStyleDeclaration.parentElement (all of them right now)\n  //\n  domEvents.EventTarget.implementsIn(cssCascade)\n  Object.defineProperty(Element.prototype, 'myStyle', {\n    get: function() {\n      var style = this.style\n      if (!style.parentElement) style.parentElement = this\n      return style\n    }\n  })\n\n  //\n  // load all stylesheets at the time the script is loaded\n  // then do it again when all stylesheets are downloaded\n  // and again if some style tag is added to the DOM\n  //\n  if (!('no_auto_stylesheet_detection' in window)) {\n    cssCascade.loadAllStyleSheets()\n    document.addEventListener('DOMContentLoaded', function() {\n      cssCascade.loadAllStyleSheets()\n      querySelectorLive(cssCascade.selectorForStylesheets, {\n        onadded: function(e) {\n          // TODO: respect DOM order?\n          cssCascade.loadStyleSheetTag(e)\n          cssCascade.dispatchEvent('stylesheetadded')\n        }\n      })\n    })\n  }\n\n  return cssCascade\n})(window, document)\n\nrequire.define('src/core/css-cascade.js');","module.exports = (function(window, document) { \"use strict\"; \n\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\t\n\tvar cssBreak = {\n\n\t\t//\n\t\t// returns true if an element is replaced \n\t\t// (can't be broken because considered as an image in css layout)\n\t\t// \n\t\tisReplacedElement: function isReplacedElement(element) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tvar replacedElementTags = /^(SVG|MATH|IMG|VIDEO|PICTURE|OBJECT|EMBED|IFRAME|TEXTAREA|BUTTON|INPUT)$/; // TODO: more\n\t\t\treturn replacedElementTags.test(element.tagName);\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if an element has a scrollbar or act on overflowing content\n\t\t// \n\t\tisScrollable: function isScrollable(element, elementOverflow) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).overflow;\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementOverflow !== \"visible\"\n\t\t\t\t&& elementOverflow !== \"hidden\"\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is part of an inline flow\n\t\t// TextNodes definitely qualify, but also inline-block elements\n\t\t// \n\t\tisSingleLineOfTextComponent: function(element, elementStyle, elementDisplay, elementPosition, isReplaced) {\n\t\t\tif(!(element instanceof Element)) return true;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\n\t\t\tif(typeof(isReplaced)==\"undefined\") isReplaced = this.isReplacedElement(element);\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementDisplay === \"inline-block\"\n\t\t\t\t|| elementDisplay === \"inline-table\"\n\t\t\t\t|| elementDisplay === \"inline-flex\"\n\t\t\t\t|| elementDisplay === \"inline-grid\"\n\t\t\t\t// TODO: more\n\t\t\t) && (\n\t\t\t\telementPosition === \"static\"\n\t\t\t\t|| elementPosition === \"relative\"\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is part of an inline flow\n\t\t// TextNodes definitely qualify, but also inline-block elements\n\t\t// \n\t\thasAnyInlineFlow: function(element) {\n\t\t\t\n\t\t\tfunction countAsInline(element) {\n\t\t\t\tif(!(element instanceof Element)) return !(/^\\s*$/.test(element.nodeValue));\n\t\t\t\treturn !cssBreak.isOutOfFlowElement(element) && cssBreak.isSingleLineOfTextComponent(element);\n\t\t\t}\n\t\t\t\n\t\t\t// try to find any inline element\n\t\t\tvar current = element.firstChild;\n\t\t\twhile(current) {\n\t\t\t\tif(countAsInline(current)) return true;\n\t\t\t\tcurrent = current.nextSibling;\n\t\t\t}\n\t\t\t\n\t\t\t// no inline element\n\t\t\treturn false;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLineBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\t\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position;\n\t\t\t\n\t\t\treturn (\n\t\t\t\t(\n\t\t\t\t\t// in-flow bock elements\n\t\t\t\t\t(elementDisplay === \"block\")\n\t\t\t\t\t&& !this.isOutOfFlowElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t\t\t\n\t\t\t\t) || (\n\t\t\t\t\t\n\t\t\t\t\t// displayed <br> elements\n\t\t\t\t\telement.tagName===\"BR\" && elementDisplay!==\"none\"\n\t\t\t\t\t\n\t\t\t\t)\n\t\t\t);\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow before him\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLinePreBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\tif(!(element instanceof Element)) return false;\n\n\t\t\tvar breakBefore = cssCascade.getSpecifiedStyle(element,'break-before').toCSSString();\n\t\t\treturn (\n\t\t\t\t(breakBefore==\"region\"||breakBefore==\"all\") \n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element breaks the inline flow after him\n\t\t// (the case of block elements, mostly)\n\t\t// \n\t\tisLinePostBreakingElement: function(element, elementStyle, elementDisplay, elementPosition) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\t\n\t\t\tvar breakAfter = cssCascade.getSpecifiedStyle(element,'break-after').toCSSString();\n\t\t\treturn (\n\t\t\t\t(breakAfter==\"region\"||breakAfter==\"all\") \n\t\t\t\t|| cssBreak.isLineBreakingElement(element, elementStyle, elementDisplay, elementPosition)\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if the element is outside any block/inline flow\n\t\t// (this the case of absolutely positioned elements, and floats)\n\t\t// \n\t\tisOutOfFlowElement: function(element, elementStyle, elementDisplay, elementPosition, elementFloat) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\t\t\tif(typeof(elementDisplay)==\"undefined\") elementDisplay = elementStyle.display;\n\t\t\tif(typeof(elementPosition)==\"undefined\") elementPosition = elementStyle.position; \n\t\t\tif(typeof(elementFloat)==\"undefined\") elementFloat = elementStyle.float || elementStyle.styleFloat || elementStyle.cssFloat;\n\t\t\t\n\t\t\treturn (\n\t\t\t\t\n\t\t\t\t// positioned elements are out of the flow\n\t\t\t\t(elementPosition===\"absolute\"||elementPosition===\"fixed\")\n\t\t\t\t\n\t\t\t\t// floated elements as well\n\t\t\t\t|| (elementFloat!==\"none\") \n\t\t\t\t\n\t\t\t\t// not sure but let's say hidden elements as well\n\t\t\t\t|| (elementDisplay===\"none\")\n\t\t\t\t\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if two sibling elements are in the same text line\n\t\t// (this function is not perfect, work with it with care)\n\t\t// \n\t\tareInSameSingleLine: function areInSameSingleLine(element1, element2) {\n\t\t\t\n\t\t\t//\n\t\t\t// look for obvious reasons why it wouldn't be the case\n\t\t\t//\n\t\t\t\n\t\t\t// if the element are not direct sibling, we must use their inner siblings as well\n\t\t\tif(element1.nextSibling != element2) { \n\t\t\t\tif(element2.nextSibling != element1) throw \"I gave up!\"; \n\t\t\t\tvar t = element1; element1=element2; element2=t;\n\t\t\t}\n\t\t\t \n\t\t\t// a block element is never on the same line as another element\n\t\t\tif(this.isLinePostBreakingElement(element1)) return false;\n\t\t\tif(this.isLinePreBreakingElement(element2)) return false;\n\t\t\t\n\t\t\t// if the previous element is out of flow, we may consider it as being part of the current line\n\t\t\tif(this.isOutOfFlowElement(element1)) return true;\n\t\t\t\n\t\t\t// if the current object is not a single line component, return false\n\t\t\tif(!this.isSingleLineOfTextComponent(element1)) return false;\n\t\t\t\n\t\t\t// \n\t\t\t// compute the in-flow bounding rect of the two elements\n\t\t\t// \n\t\t\tvar element1box = Node.getBoundingClientRect(element1);\n\t\t\tvar element2box = Node.getBoundingClientRect(element2);\n\t\t\tfunction shift(box,shiftX,shiftY) {\n\t\t\t\treturn {\n\t\t\t\t\ttop: box.top+shiftY,\n\t\t\t\t\tbottom: box.bottom+shiftY,\n\t\t\t\t\tleft: box.left+shiftX,\n\t\t\t\t\tright: box.right+shiftX\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// we only need to shift elements\n\t\t\tif(element1 instanceof Element) {\n\t\t\t\tvar element1Style = getComputedStyle(element1);\n\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.marginLeft), parseFloat(element1Style.marginTop))\n\t\t\t\tif(element1Style.position==\"relative\") {\n\t\t\t\t\telement1box = shift(element1box, parseFloat(element1Style.left), parseFloat(element1Style.top))\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// we only need to shift elements\n\t\t\tif(element2 instanceof Element) {\n\t\t\t\tvar element2Style = getComputedStyle(element2);\n\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.marginLeft), parseFloat(element2Style.marginTop))\n\t\t\t\tif(element2Style.position==\"relative\") {\n\t\t\t\t\telement2box = shift(element2box, parseFloat(element2Style.left), parseFloat(element2Style.top))\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// order the nodes so that they are in left-to-right order\n\t\t\t// (this means invert their order in the case of right-to-left flow)\n\t\t\tvar firstElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element2box : element1box;\n\t\t\tvar secondElement = getComputedStyle(element1.parentNode).direction==\"rtl\" ? element1box : element2box;\n\t\t\t\n\t\t\t// return true if both elements are have non-overlapping\n\t\t\t// margin- and position-corrected in-flow bounding rect\n\t\t\t// and if their relative position is the one of the current\n\t\t\t// flow (either rtl or ltr)\n\t\t\treturn firstElement.right <= secondElement.left;\n\t\t\t\n\t\t\t// TODO: what about left-to-right + right-aligned text?\n\t\t\t// I should probably takes care of vertical position in this case to solve ambiguities\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element has \"overflow: hidden\" set on it, and actually overflows\n\t\t//\n\t\tisHiddenOverflowing: function isHiddenOverflowing(element, elementOverflow) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementOverflow)==\"undefined\") elementOverflow = getComputedStyle(element).display;\n\t\t\t\n\t\t\treturn (\n\t\t\t\telementOverflow == \"hidden\" \n\t\t\t\t&& element.offsetHeight != element.scrollHeight // trust me that works\n\t\t\t);\n\t\t\t\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element has a border-radius that impacts his layout\n\t\t//\n\t\thasBigRadius: function(element, elementStyle) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\tif(typeof(elementStyle)==\"undefined\") elementStyle = getComputedStyle(element);\n\n\t\t\t// if the browser supports radiuses {f### prefixes}\n\t\t\tif(\"borderTopLeftRadius\" in elementStyle) {\n\t\t\t\t\n\t\t\t\tvar tlRadius = parseFloat(elementStyle.borderTopLeftRadius);\n\t\t\t\tvar trRadius = parseFloat(elementStyle.borderTopRightRadius);\n\t\t\t\tvar blRadius = parseFloat(elementStyle.borderBottomLeftRadius);\n\t\t\t\tvar brRadius = parseFloat(elementStyle.borderBottomRightRadius);\n\t\t\t\t\n\t\t\t\t// tiny radiuses (<15px) are tolerated anyway\n\t\t\t\tif(tlRadius < 15 && trRadius < 15 && blRadius < 15 && brRadius < 15) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar tWidth = parseFloat(elementStyle.borderTopWidth);\n\t\t\t\tvar bWidth = parseFloat(elementStyle.borderBottomWidth);\n\t\t\t\tvar lWidth = parseFloat(elementStyle.borderLeftWidth);\n\t\t\t\tvar rWidth = parseFloat(elementStyle.borderRightWidth);\n\t\t\t\t\n\t\t\t\t// make sure the radius itself is contained into the border\n\t\t\t\t\n\t\t\t\tif(tlRadius > tWidth) return true;\n\t\t\t\tif(tlRadius > lWidth) return true;\n\t\t\t\t\n\t\t\t\tif(trRadius > tWidth) return true;\n\t\t\t\tif(trRadius > rWidth) return true;\n\t\t\t\t\n\t\t\t\tif(blRadius > bWidth) return true;\n\t\t\t\tif(blRadius > lWidth) return true;\n\t\t\t\t\n\t\t\t\tif(brRadius > bWidth) return true;\n\t\t\t\tif(brRadius > rWidth) return true;\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// all conditions were met\n\t\t\treturn false;\n\t\t},\n\t\t\n\t\t//\n\t\t// return trus if the break-inside property is 'avoid' or 'avoid-region'\n\t\t//\n\t\tisBreakInsideAvoid: function isBreakInsideAvoid(element, elementStyle) {\n\t\t\tvar breakInside = cssCascade.getSpecifiedStyle(element, 'break-inside', undefined, true).toCSSString().trim().toLowerCase(); \n\t\t\treturn (breakInside == \"avoid\" || breakInside == \"avoid-region\");\n\t\t},\n\t\t\n\t\t//\n\t\t// returns true if the element is unbreakable according to the spec\n\t\t// (and some of the expected limitations of HTML/CSS)\n\t\t//\n\t\tisMonolithic: function isMonolithic(element) {\n\t\t\tif(!(element instanceof Element)) return false;\n\t\t\t\n\t\t\tvar elementStyle = getComputedStyle(element);\n\t\t\tvar elementOverflow = elementStyle.overflow;\n\t\t\tvar elementDisplay = elementStyle.display;\n\t\t\t\n\t\t\t// Some content is not fragmentable, for example:\n\t\t\t// - many types of replaced elements (such as images or video)\n\t\t\t\n\t\t\tvar isReplaced = this.isReplacedElement(element);\n\t\t\t\n\t\t\t// - scrollable elements\n\t\t\t\n\t\t\tvar isScrollable = this.isScrollable(element, elementOverflow);\n\t\t\t\n\t\t\t// - a single line of text content. \n\t\t\t\n\t\t\tvar isSingleLineOfText = this.isSingleLineOfTextComponent(element, elementStyle, elementDisplay, undefined, isReplaced);\n\t\t\t\n\t\t\t// Such content is considered monolithic: it contains no\n\t\t\t// possible break points. \n\t\t\t\n\t\t\t// In addition to any content which is not fragmentable, \n\t\t\t// UAs may consider as monolithic:\n\t\t\t// - any elements with ‘overflow’ set to ‘auto’ or ‘scroll’ \n\t\t\t// - any elements with ‘overflow: hidden’ and a non-‘auto’ logical height (and no specified maximum logical height).\n\t\t\t\n\t\t\tvar isHiddenOverflowing = this.isHiddenOverflowing(element, elementOverflow);\n\t\t\t\n\t\t\t// ADDITION TO THE SPEC:\n\t\t\t// I don't want to handle the case where \n\t\t\t// an element has a border-radius that is bigger\n\t\t\t// than the border-width to which it belongs\n\t\t\tvar hasBigRadius = this.hasBigRadius(element, elementStyle);\n\t\t\t\n\t\t\t// ADDITION TO THE SPEC:\n\t\t\t// Someone proposed to support \"break-inside: avoid\" here\n\t\t\tvar isBreakInsideAvoid = this.isBreakInsideAvoid(element, elementStyle);\n\t\t\t\n\t\t\t// all of them are monolithic\n\t\t\treturn isReplaced || isScrollable || isSingleLineOfText || isHiddenOverflowing || hasBigRadius || isBreakInsideAvoid;\n\t\t\t\n\t\t},\n\t\t\n\t\t// \n\t\t// returns true if \"r\" is a collapsed range located at a possible break point for \"region\"\n\t\t// (this function does all the magic for you, but you may want to avoid using it too much)\n\t\t// \n\t\tisPossibleBreakPoint: function isPossibleBreakPoint(r, region) {\n\t\t\t\n\t\t\t// r has to be a range, and be collapsed\n\t\t\tif(!(r instanceof Range)) return false;\n\t\t\tif(!(r.collapsed)) return false;\n\t\t\t\n\t\t\t// no ancestor up to the region has to be monolithic\n\t\t\tvar ancestor = r.startContainer;\n\t\t\twhile(ancestor && ancestor !== region) {\n\t\t\t\tif(cssBreak.isMonolithic(ancestor)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t// we also have to check that we're not between two single-line-of-text elements\n\t\t\t// that are actually on the same line (in which case you can't break)\n\t\t\tvar ancestor = r.startContainer; \n\t\t\tvar lastAncestor = r.startContainer.childNodes[r.startOffset];\n\t\t\twhile(ancestor && lastAncestor !== region) {\n\t\t\t\tif(lastAncestor && lastAncestor.previousSibling) {\n\t\t\t\t\t\n\t\t\t\t\tif(this.areInSameSingleLine(lastAncestor, lastAncestor.previousSibling)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlastAncestor = ancestor;\n\t\t\t\tancestor = ancestor.parentNode;\n\t\t\t}\n\t\t\t\n\t\t\t// there are some very specific conditions for breaking\n\t\t\t// at the edge of an element:\n\t\t\t\n\t\t\tif(r.startOffset==0) {\n\t\t\t\t\n\t\t\t\t// Class 3 breaking point:\n\t\t\t\t// ========================\n\t\t\t\t// Between the content edge of a block container box \n\t\t\t\t// and the outer edges of its child content (margin \n\t\t\t\t// edges of block-level children or line box edges \n\t\t\t\t// for inline-level children) if there is a (non-zero)\n\t\t\t\t// gap between them.\n\t\t\t\t\n\t\t\t\tvar firstChild = r.startContainer.childNodes[0];\n\t\t\t\tif(firstChild) {\n\t\t\t\t\t\n\t\t\t\t\tvar firstChildBox = (\n\t\t\t\t\t\tNode.getBoundingClientRect(firstChild)\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tvar parentBox = (\n\t\t\t\t\t\tr.startContainer.getBoundingClientRect()\n\t\t\t\t\t);\n\t\t\t\t\t\n\t\t\t\t\tif(firstChildBox.top == parentBox.top) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t// all conditions are met!\n\t\t\treturn true;\n\t\t\t\n\t\t}\n\t\t\n\t};\n\t\n\treturn cssBreak;\n\t\n})(window, document);\nrequire.define('src/core/css-break.js');","\"use strict\";\n\n//\n// start by polyfilling caretRangeFromPoint\n//\n\nif(!document.caretRangeFromPoint) {\n    if (document.caretPositionFromPoint) {\n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\n            var r = document.createRange();\n            var p = document.caretPositionFromPoint(x,y); \n            if(p.offsetNode) {\n                r.setStart(p.offsetNode, p.offset);\n                r.setEnd(p.offsetNode, p.offset);\n            }\n            return r;\n        }\n    } else if((document.body||document.createElement('body')).createTextRange) {\n        \n        //\n        // we may want to convert TextRange to Range\n        //\n        \n        var TextRangeUtils = {\n            convertToDOMRange: function (textRange, document) {\n                var adoptBoundary = function(domRange, textRangeInner, bStart) {\n                    // iterate backwards through parent element to find anchor location\n                    var cursorNode = document.createElement('a'), cursor = textRangeInner.duplicate();\n                    cursor.collapse(bStart);\n                    var parent = cursor.parentElement();\n                    do {\n                            parent.insertBefore(cursorNode, cursorNode.previousSibling);\n                            cursor.moveToElementText(cursorNode);\n                    } while (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) > 0 && cursorNode.previousSibling);\n                    \n                    // when we exceed or meet the cursor, we've found the node\n                    if (cursor.compareEndPoints(bStart ? 'StartToStart' : 'StartToEnd', textRangeInner) == -1 && cursorNode.nextSibling) {\n                            // data node\n                            cursor.setEndPoint(bStart ? 'EndToStart' : 'EndToEnd', textRangeInner);\n                            domRange[bStart ? 'setStart' : 'setEnd'](cursorNode.nextSibling, cursor.text.length);\n                    } else {\n                            // element\n                            domRange[bStart ? 'setStartBefore' : 'setEndBefore'](cursorNode);\n                    }\n                    cursorNode.parentNode.removeChild(cursorNode);\n                }\n                \n                // validate arguments\n                if(!document) { document=window.document; }\n                \n                // return a DOM range\n                var domRange = document.createRange();\n                adoptBoundary(domRange, textRange, true);\n                adoptBoundary(domRange, textRange, false);\n                return domRange;\n            },\n\n            convertFromDOMRange: function (domRange) {\n                var adoptEndPoint = function(textRange, domRangeInner, bStart) {\n                    // find anchor node and offset\n                    var container = domRangeInner[bStart ? 'startContainer' : 'endContainer'];\n                    var offset = domRangeInner[bStart ? 'startOffset' : 'endOffset'], textOffset = 0;\n                    var anchorNode = DOMUtils.isDataNode(container) ? container : container.childNodes[offset];\n                    var anchorParent = DOMUtils.isDataNode(container) ? container.parentNode : container;\n                    // visible data nodes need a text offset\n                    if (container.nodeType == 3 || container.nodeType == 4)\n                        textOffset = offset;\n                    \n                    // create a cursor element node to position range (since we can't select text nodes)\n                    var cursorNode = domRangeInner._document.createElement('a');\n                    anchorParent.insertBefore(cursorNode, anchorNode);\n                    var cursor = domRangeInner._document.body.createTextRange();\n                    cursor.moveToElementText(cursorNode);\n                    cursorNode.parentNode.removeChild(cursorNode);\n                    // move range\n                    textRange.setEndPoint(bStart ? 'StartToStart' : 'EndToStart', cursor);\n                    textRange[bStart ? 'moveStart' : 'moveEnd']('character', textOffset);\n                }\n               \n                // return an IE text range\n                var textRange = domRange._document.body.createTextRange();\n                adoptEndPoint(textRange, domRange, true);\n                adoptEndPoint(textRange, domRange, false);\n                return textRange;\n            }\n        };\n\n        \n        document.caretRangeFromPoint = function caretRangeFromPoint(x,y) {\n            \n            // the accepted number of vertical backtracking, in CSS pixels\n            var IYDepth = 40;\n            \n            // try to create a text range at the specified location\n            var r = document.body.createTextRange();\n            for(var iy=IYDepth; iy; iy=iy-4) {\n                var ix = x; if(true) {\n                    try {\n                        r.moveToPoint(ix,iy+y-IYDepth); \n                        return TextRangeUtils.convertToDOMRange(r);\n                    } catch(ex) {}\n                }\n            }\n            \n            // if that fails, return the location just after the element located there\n            try {\n                \n                var elem = document.elementFromPoint(x-1,y-1);\n                var r = document.createRange();\n                r.setStartAfter(elem);\n                return r;\n                \n            } catch(ex) {\n                \n                return null;\n                \n            }\n        }\n    }\n}\n\n\n///\n/// helper function for moving ranges char by char\n///\n\nRange.prototype.myMoveOneCharLeft = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    if(r.endOffset > 0) {\n        \n        // if we can enter into the previous sibling\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\n        if(previousSibling && previousSibling.lastChild) {\n            \n            // enter the previous sibling from its end\n            r.setEndAfter(previousSibling.lastChild);\n            \n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the previous text node from its end\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset-1);\n            \n        }\n        \n    } else {\n        r.setEndBefore(r.endContainer);\n    }\n    \n}\n\nRange.prototype.myMoveOneCharRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var max = (r.startContainer.nodeType==r.startContainer.TEXT_NODE ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\n    if(r.startOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setStartBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setStart(nextSibling, 0);\n            \n        } else {\n            \n            // else move before that element\n            r.setStart(r.startContainer, r.startOffset+1);\n            \n        }\n        \n    } else {\n        r.setStartAfter(r.endContainer);\n    }\n    \n    // shouldn't be needed but who knows...\n    r.setEnd(r.startContainer, r.startOffset);\n    \n}\n\n\n///\n/// This functions is optimized to not yield inside a word in a text node\n///\nRange.prototype.myMoveTowardRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var isTextNode = r.startContainer.nodeType==r.startContainer.TEXT_NODE;\n    var max = (isTextNode ? r.startContainer.nodeValue.length : r.startContainer.childNodes.length)\n    if(r.startOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setStartBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE && nextSibling.nodeValue!='') { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setStart(nextSibling, 0);\n            \n        } else if(isTextNode) {\n            \n            // move to the next non a-zA-Z symbol\n            var currentText = r.startContainer.nodeValue;\n            var currentOffset = r.startOffset;\n            var currentLetter = currentText[currentOffset++];\n            while(currentOffset < max && /^\\w$/.test(currentLetter)) {\n                currentLetter = currentText[currentOffset++];\n            }\n            r.setStart(r.startContainer, currentOffset);\n            \n        } else {\n            \n            // else move after that element\n            r.setStart(r.startContainer, r.startOffset+1);\n            \n        }\n        \n    } else {\n        r.setStartAfter(r.endContainer);\n    }\n    \n    // shouldn't be needed but who knows...\n    r.setEnd(r.startContainer, r.startOffset);\n    \n}\n\n\nRange.prototype.myMoveEndOneCharLeft = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    if(r.endOffset > 0) {\n        \n        // if we can enter into the previous sibling\n        var previousSibling = r.endContainer.childNodes[r.endOffset-1];\n        if(previousSibling && previousSibling.lastChild) {\n            \n            // enter the previous sibling from its end\n            r.setEndAfter(previousSibling.lastChild);\n            \n        } else if(previousSibling && previousSibling.nodeType==previousSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the previous text node from its end\n            r.setEnd(previousSibling, previousSibling.nodeValue.length);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset-1);\n            \n        }\n        \n    } else {\n        r.setEndBefore(r.endContainer);\n    }\n    \n}\n\nRange.prototype.myMoveEndOneCharRight = function() {\n    var r = this;\n    \n    // move to the previous cursor location\n    var max = (r.endContainer.nodeType==r.endContainer.TEXT_NODE ? r.endContainer.nodeValue.length : r.endContainer.childNodes.length)\n    if(r.endOffset < max) {\n        \n        // if we can enter into the next sibling\n        var nextSibling = r.endContainer.childNodes[r.endOffset];\n        if(nextSibling && nextSibling.firstChild) {\n            \n            // enter the next sibling from its start\n            r.setEndBefore(nextSibling.firstChild);\n            \n        } else if(nextSibling && nextSibling.nodeType==nextSibling.TEXT_NODE) { // todo: lookup value\n            \n            // enter the next text node from its start\n            r.setEnd(nextSibling, 0);\n            \n        } else {\n            \n            // else move before that element\n            r.setEnd(r.endContainer, r.endOffset+1);\n            \n        }\n        \n    } else {\n        r.setEndAfter(r.endContainer);\n    }\n    \n}\n\n//\n// Get the *real* bounding client rect of the range\n// { therefore we need to fix some browser bugs... }\n//\nRange.prototype.myGetSelectionRect = function() {\n    \n    // get the browser's claimed rect\n    var rect = this.getBoundingClientRect();\n\t\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\n\tif(!rect) { \n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \n\t}\n    \n    // if the value seems wrong... (some browsers don't like collapsed selections)\n    if(this.collapsed && rect.top===0 && rect.bottom===0) {\n        \n        // select one char and infer location\n        var clone = this.cloneRange(); var collapseToLeft=false; clone.collapse(false); \n        \n        // the case where no char before is tricky...\n        if(clone.startOffset==0) {\n            \n            // let's move on char to the right\n            clone.myMoveTowardRight();\n            collapseToLeft=true;\n\n            // note: some browsers don't like selections\n            // that spans multiple containers, so we will\n            // iterate this process until we have one true\n            // char selected\n            clone.setStart(clone.endContainer, 0); \n            \n        } else {\n            \n            // else, just select the char before\n            clone.setStart(this.startContainer, this.startOffset-1);\n            collapseToLeft=false;\n            \n        }\n        \n        // get some real rect\n        var rect = clone.myGetSelectionRect();\n        \n        // compute final value\n        if(collapseToLeft) {\n            return {\n                \n                left: rect.left,\n                right: rect.left,\n                width: 0,\n                \n                top: rect.top,\n                bottom: rect.bottom,\n                height: rect.height\n                \n            }\n        } else {\n            return {\n                \n                left: rect.right,\n                right: rect.right,\n                width: 0,\n                \n                top: rect.top,\n                bottom: rect.bottom,\n                height: rect.height\n                \n            }\n        }\n        \n    } else {\n        return rect;\n    }\n    \n}\n\n// not sure it's needed but still\nif(!window.Element) window.Element=window.HTMLElement;\nif(!window.Node) window.Node = {};\n\n// make getBCR working on text nodes & stuff\nNode.getBoundingClientRect = function getBoundingClientRect(element) {\n    if (element.getBoundingClientRect) {\n        \n        var rect = element.getBoundingClientRect();\n        \n    } else {\n        \n        var range = document.createRange();\n        range.selectNode(element);\n        \n        var rect = range.getBoundingClientRect();\n        \n    }\n\t\n\t// HACK FOR ANDROID BROWSER AND OLD WEBKIT\n\tif(!rect) { \n\t\trect={top:0,right:0,bottom:0,left:0,width:0,height:0}; \n\t}\n\t\n\treturn rect;\n};\n\n\n// make getCR working on text nodes & stuff\nNode.getClientRects = function getClientRects(firstChild) {\n    if (firstChild.getBoundingClientRect) {\n        \n        return firstChild.getClientRects();\n        \n    } else {\n        \n        var range = document.createRange();\n        range.selectNode(firstChild);\n        \n        return range.getClientRects();\n        \n    }\n};\n\n// fix for IE (contains fails for text nodes...)\nNode.contains = function contains(parentNode,node) {\n    if(node.nodeType != 1) {\n        if(!node.parentNode) return false;\n        return node.parentNode==parentNode || parentNode.contains(node.parentNode);\n    } else {\n        return parentNode.contains(node);\n    }\n}\n\n//\n// get the bounding rect of the selection, including the bottom padding/marging of the previous element if required\n// { this is a special version for breaking algorithms that do not want to miss the previous element real size }\n//\nRange.prototype.myGetExtensionRect = function() {\n    \n    // this function returns the selection rect\n    // but does take care of taking in account \n    // the bottom-{padding/border} of the previous\n    // sibling element, to detect overflow points\n    // more accurately\n    \n    var rect = this.myGetSelectionRect();\n    var previousSibling = this.endContainer.childNodes[this.endOffset-1];\n    if(previousSibling) {\n        \n        // correct with the new take\n        var prevSibRect = Node.getBoundingClientRect(previousSibling);\n        var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\n        if(adjustedBottom == rect.bottom) return rect;\n        return {\n            \n            left: rect.left,\n            right: rect.right,\n            width: rect.width,\n            \n            top: rect.top,\n            bottom: adjustedBottom,\n            height: adjustedBottom - rect.top\n            \n        };\n        \n    } else if(rect.bottom==0 && this.endContainer.nodeType === 3) {\n        \n        // note that if we are in a text node, \n        // we may want to cover all the previous\n        // text in the node to avoid whitespace\n        // related bugs\n        \n        var onlyWhiteSpaceBefore = /^(\\s|\\n)*$/.test(this.endContainer.nodeValue.substr(0,this.endOffset));\n        if(onlyWhiteSpaceBefore) {\n            \n            // if we are in the fucking whitespace land, return first line\n            var prevSibRect = Node.getClientRects(this.endContainer)[0];\n            return prevSibRect;\n            \n        } else {\n            \n            // otherwhise, let's rely on previous chars\n            var auxiliaryRange = this.cloneRange();\n            auxiliaryRange.setStart(this.endContainer,0);\n            \n            // correct with the new take\n            var prevSibRect = auxiliaryRange.getBoundingClientRect();\n            var adjustedBottom = Math.max(rect.bottom,prevSibRect.bottom);\n            return {\n                \n                left: rect.left,\n                right: rect.right,\n                width: rect.width,\n                \n                top: rect.top,\n                bottom: adjustedBottom,\n                height: adjustedBottom - rect.top\n                \n            };\n            \n        }\n        \n    } else {\n        \n        return rect;\n        \n    }\n}\nrequire.define('src/css-regions/lib/range-extensions.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  var domEvents = require('src/core/dom-events.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n  var cssBreak = require('src/core/css-break.js')\n\n  var cssRegionsHelpers = (window.cssRegionsHelpers = {\n    //\n    // returns the previous sibling of the element\n    // or the previous sibling of its nearest ancestor that has one\n    //\n    getAllLevelPreviousSibling: function(e, region) {\n      if (!e || e == region) return null\n\n      // find the nearest ancestor that has a previous sibling\n      while (!e.previousSibling) {\n        // but bubble to the next avail ancestor\n        e = e.parentNode\n\n        // dont get over the bar\n        if (!e || e == region) return null\n      }\n\n      // return that sibling\n      return e.previousSibling\n    },\n\n    //\n    // prepares the element to become a css region\n    //\n    markNodesAsRegion: function(nodes, fast) {\n      nodes.forEach(function(node) {\n        node.regionOverset = 'empty'\n        node.setAttribute('data-css-region', node.cssRegionsLastFlowFromName)\n        cssRegionsHelpers.hideTextNodesFromFragmentSource([node])\n        node.cssRegionsWrapper =\n          node.cssRegionsWrapper || node.appendChild(document.createElement('cssregion'))\n      })\n    },\n\n    //\n    // prepares the element to return to its normal css life\n    //\n    unmarkNodesAsRegion: function(nodes, fast) {\n      nodes.forEach(function(node) {\n        // restore regionOverset to its natural value\n        node.regionOverset = 'fit'\n\n        // remove the current <cssregion> tag\n        try {\n          node.cssRegionsWrapper && node.removeChild(node.cssRegionsWrapper)\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n        node.cssRegionsWrapper = undefined\n        delete node.cssRegionsWrapper\n\n        // restore top-level texts that may have been hidden\n        cssRegionsHelpers.unhideTextNodesFromFragmentSource([node])\n\n        // unmark as a region\n        node.removeAttribute('data-css-region')\n      })\n    },\n\n    //\n    // prepares the element for cloning (mainly give them an ID)\n    //\n    fragmentSourceIndex: 0,\n    markNodesAsFragmentSource: function(nodes, ignoreRoot) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            if (typeof k == 'undefined' || !ignoreRoot) {\n              // mark as fragment source\n              var id = node.getAttributeNode('data-css-regions-fragment-source')\n              if (!id) {\n                node.setAttribute(\n                  'data-css-regions-fragment-source',\n                  cssRegionsHelpers.fragmentSourceIndex++\n                )\n              }\n            }\n\n            node.setAttribute('data-css-regions-cloning', true)\n\n            // expand list values\n            if (node.tagName == 'OL') cssRegionsHelpers.expandListValues(node)\n            if (typeof k != 'undefined' && node.tagName == 'LI')\n              cssRegionsHelpers.expandListValues(node.parentNode)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // computes the \"value\" attribute of every LI element out there\n    //\n    expandListValues: function(OL) {\n      if (OL.getAttribute('data-css-li-value-expanded')) return\n      OL.setAttribute('data-css-li-value-expanded', true)\n\n      if (OL.hasAttribute('reversed')) {\n        var currentValue = OL.getAttribute('start')\n          ? parseInt(OL.getAttribute('start'))\n          : OL.childElementCount\n        var increment = -1\n      } else {\n        var currentValue = OL.getAttribute('start') ? parseInt(OL.getAttribute('start')) : 1\n        var increment = +1\n      }\n\n      var LI = OL.firstElementChild\n      var LIV = null\n      while (LI) {\n        if (LI.tagName === 'LI') {\n          if ((LIV = LI.getAttributeNode('value'))) {\n            currentValue = parseInt(LIV.nodeValue)\n            LI.setAttribute('data-css-old-value', currentValue)\n          } else {\n            LI.setAttribute('value', currentValue)\n          }\n          currentValue = currentValue + increment\n        }\n        LI = LI.nextElementSibling\n      }\n    },\n\n    //\n    // reverts to automatic computation of the value of LI elements\n    //\n    unexpandListValues: function(OL) {\n      if (!OL.hasAttribute('data-css-li-value-expanded')) return\n      OL.removeAttribute('data-css-li-value-expanded')\n      var LI = OL.firstElementChild\n      var LIV = null\n      while (LI) {\n        if (LI.tagName === 'LI') {\n          if ((LIV = LI.getAttributeNode('data-css-old-value'))) {\n            LI.removeAttributeNode(LIV)\n          } else {\n            LI.removeAttribute('value')\n          }\n        }\n        LI = LI.nextElementSibling\n      }\n    },\n\n    //\n    // makes empty text nodes which cannot get \"display: none\" applied to them\n    //\n    listOfTextNodesForIE: [],\n    hideTextNodesFromFragmentSource: function(nodes) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            if (!node.parentNode.getAttribute('data-css-regions-fragment-source')) {\n              // we have to remove their content the hard way...\n              node.cssRegionsSavedNodeValue = node.nodeValue\n              node.nodeValue = ''\n\n              // HACK: OTHERWISE IE WILL GC THE TEXTNODE AND RETURNS YOU\n              // A FRESH TEXTNODE THE NEXT TIME WHERE YOUR EXPANDO\n              // IS NOWHERE TO BE SEEN!\n              if (\n                navigator.userAgent.indexOf('MSIE') > 0 ||\n                navigator.userAgent.indexOf('Trident') > 0\n              ) {\n                if (cssRegionsHelpers.listOfTextNodesForIE.indexOf(node) == -1) {\n                  cssRegionsHelpers.listOfTextNodesForIE.push(node)\n                }\n              }\n            }\n\n            break\n\n          case 1: // Element node\n            if (node.hasAttribute('data-css-regions-cloning')) {\n              node.removeAttribute('data-css-regions-cloning')\n              node.setAttribute('data-css-regions-cloned', true)\n              if (node.currentStyle) node.currentStyle.display.toString() // IEFIX FOR BAD STYLE RECALC\n            }\n            if (typeof k == 'undefined') return\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // makes emptied text nodes visible again\n    //\n    unhideTextNodesFromFragmentSource: function(nodes) {\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we have to remove their content the hard way...\n            if ('cssRegionsSavedNodeValue' in node) {\n              node.nodeValue = node.cssRegionsSavedNodeValue\n              delete node.cssRegionsSavedNodeValue\n            }\n\n            break\n\n          case 1: // Element node\n            if (typeof k == 'undefined') return\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // prepares the content elements to return to ther normal css life\n    //\n    unmarkNodesAsFragmentSource: function(nodes) {\n      function visit(node, k) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we have to reinstall their content the hard way...\n            if ('cssRegionsSavedNodeValue' in node) {\n              node.nodeValue = node.cssRegionsSavedNodeValue\n              delete node.cssRegionsSavedNodeValue\n            }\n\n            break\n          case 1: // Element node\n            node.removeAttribute('data-css-regions-cloned')\n            node.removeAttribute('data-css-regions-fragment-source')\n            if (node.currentStyle) node.currentStyle.display.toString() // IEFIX FOR BAD STYLE RECALC\n            if (node.tagName == 'OL') cssRegionsHelpers.unexpandListValues(node)\n            if (typeof k != 'undefined' && node.tagName == 'LI')\n              cssRegionsHelpers.unexpandListValues(node.parentNode)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // marks cloned content as fragment instead of as fragment source (basically)\n    //\n    transformFragmentSourceToFragments: function(nodes) {\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            var id = node.getAttribute('data-css-regions-fragment-source')\n            node.removeAttribute('data-css-regions-fragment-source')\n            node.removeAttribute('data-css-regions-cloning')\n            node.removeAttribute('data-css-regions-cloned')\n            node.setAttribute('data-css-regions-fragment-of', id)\n            if (node.id) node.id += '--fragment'\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      nodes.forEach(visit)\n    },\n\n    //\n    // removes some invisible text nodes from the tree\n    // (useful if you don't want to face browser bugs when dealing with them)\n    //\n    embedTrailingWhiteSpaceNodes: function(fragment) {\n      var onlyWhiteSpace = /^\\s*$/\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 3: // Text node\n            // we only remove nodes at the edges\n            if (!node.previousSibling) {\n              // we only remove nodes if their parent doesn't preserve whitespace\n              if (getComputedStyle(node.parentNode).whiteSpace.substring(0, 3) !== 'pre') {\n                // only remove pure whitespace nodes\n                if (onlyWhiteSpace.test(node.nodeValue)) {\n                  node.parentNode.setAttribute('data-whitespace-before', node.nodeValue)\n                  node.parentNode.removeChild(node)\n                }\n              }\n\n              break\n            }\n\n            // we only remove nodes at the edges\n            if (!node.nextSibling) {\n              // we only remove nodes if their parent doesn't preserve whitespace\n              if (getComputedStyle(node.parentNode).whiteSpace.substring(0, 3) !== 'pre') {\n                // only remove pure whitespace nodes\n                if (onlyWhiteSpace.test(node.nodeValue)) {\n                  node.parentNode.setAttribute('data-whitespace-after', node.nodeValue)\n                  node.parentNode.removeChild(node)\n                }\n              }\n\n              break\n            }\n\n            break\n          case 1: // Element node\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      visit(fragment)\n    },\n\n    //\n    // recover the previously removed invisible text nodes\n    //\n    unembedTrailingWhiteSpaceNodes: function(fragment) {\n      var onlyWhiteSpace = /^\\s*$/\n      function visit(node) {\n        var child, next\n        switch (node.nodeType) {\n          case 1: // Element node\n            var txt = ''\n            if ((txt = node.getAttribute('data-whitespace-before'))) {\n              if (\n                node.getAttribute('data-starting-fragment') == '' &&\n                node.getAttribute('data-special-starting-fragment', '')\n              ) {\n                node.insertBefore(document.createTextNode(txt), node.firstChild)\n              }\n            }\n            node.removeAttribute('data-whitespace-before')\n            if ((txt = node.getAttribute('data-whitespace-after'))) {\n              if (\n                node.getAttribute('data-continued-fragment') == '' &&\n                node.getAttribute('data-special-continued-fragment', '')\n              ) {\n                node.insertAfter(document.createTextNode(txt), node.lastChild)\n              }\n            }\n            node.removeAttribute('data-whitespace-after')\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child = node.firstChild\n            while (child) {\n              next = child.nextSibling\n              visit(child)\n              child = next\n            }\n            break\n        }\n      }\n\n      visit(fragment)\n    },\n\n    ///\n    /// walk the two trees the same way, and copy all the styles\n    /// BEWARE: if the DOMs are different, funny things will happen\n    /// NOTE: this function will also remove elements put in another flow\n    ///\n    copyStyle: function(root1, root2) {\n      function visit(node1, node2, isRoot) {\n        var child1, next1, child2, next2\n        switch (node1.nodeType) {\n          case 1: // Element node\n            // // firstly, setup a cache of all css properties on the element\n            // var matchedRules = (node1.currentStyle && !window.opera) ? undefined : cssCascade.findAllMatchingRules(node1)\n\n            // // and compute the value of all css properties\n            // var properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\n            // for(var p=properties.length; p--; ) {\n\n            // \t// if the property is computation-safe, use the computed value\n            // \tif(!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-') {\n            // \t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\n            // \t\tvar defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\n            // \t\tif(style != defaultStyle) node2.style.setProperty(properties[p], style)\n            // \t\tcontinue;\n            // \t}\n\n            // \t// otherwise, get the element's specified value\n            // \tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\n            // \tif(cssValue && cssValue.length) {\n\n            // \t\t// if we have a specified value, let's use it\n            // \t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\n\n            // \t} else if(isRoot && node1.parentNode && properties[p][0] != '-') {\n\n            // \t\t// NOTE: the root will be detached from its parent\n            // \t\t// Therefore, we have to inherit styles from it (oh no!)\n\n            // \t\t// TODO: create a list of inherited properties\n            // \t\tif(!(properties[p] in cssCascade.inheritingProperties)) continue;\n\n            // \t\t// if the property is computation-safe, use the computed value\n            // \t\tif((properties[p]==\"font-size\") || (!(properties[p] in cssCascade.computationUnsafeProperties) && properties[p][0]!='-')) {\n            // \t\t\tvar style = getComputedStyle(node1).getPropertyValue(properties[p]);\n            // \t\t\tnode2.style.setProperty(properties[p], style);\n            // \t\t\t//var parentStyle = style; try { parentStyle = getComputedStyle(node1.parentNode).getPropertyValue(properties[p]) } catch(ex){}\n            // \t\t\t//var defaultStyle = cssCascade.getDefaultStyleForTag(node1.tagName).getPropertyValue(properties[p]);\n\n            // \t\t\t//if(style === parentStyle) {\n            // \t\t\t//  node2.style.setProperty(properties[p], style)\n            // \t\t\t//}\n            // \t\t\tcontinue;\n            // \t\t}\n\n            // \t\t// otherwise, get the parent's specified value\n            // \t\tvar cssValue = cssCascade.getSpecifiedStyle(node1, properties[p], matchedRules);\n            // \t\tif(cssValue && cssValue.length) {\n\n            // \t\t\t// if we have a specified value, let's use it\n            // \t\t\tnode2.style.setProperty(properties[p], cssValue.toCSSString());\n\n            // \t\t}\n\n            // \t}\n\n            // }\n\n            // // now, let's work on ::after and ::before\n            // var importPseudo = function(node1,node2,pseudo) {\n\n            // \t//\n            // \t// we'll need to use getSpecifiedStyle here as the pseudo thing is slow\n            // \t//\n            // \tvar mayExist = !!cssCascade.findAllMatchingRulesWithPseudo(node1,pseudo.substr(1)).length;\n            // \tif(!mayExist) return;\n\n            // \tvar pseudoStyle = getComputedStyle(node1,pseudo);\n            // \tif(pseudoStyle.content!='none'){\n\n            // \t\t// let's create a stylesheet for the element\n            // \t\tvar stylesheet = document.createElement('style');\n            // \t\tstylesheet.setAttribute('data-no-css-polyfill',true);\n\n            // \t\t// compute the value of all css properties\n            // \t\tvar node2style = \"\";\n            // \t\tvar properties = cssCascade.allCSSProperties || cssCascade.getAllCSSProperties();\n            // \t\tfor(var p=properties.length; p--; ) {\n\n            // \t\t\t// we always use the computed value, because we don't have better\n            // \t\t\tvar style = pseudoStyle.getPropertyValue(properties[p]);\n            // \t\t\tnode2style += properties[p]+\":\"+style+\";\";\n\n            // \t\t}\n\n            // \t\tstylesheet.textContent = (\n            // \t\t\t'[data-css-regions-fragment-of=\"' + node1.getAttribute('data-css-regions-fragment-source') + '\"]'\n            // \t\t\t+':not([data-css-regions-starting-fragment]):not([data-css-regions-special-starting-fragment])'\n            // \t\t\t+':'+pseudo+'{'\n            // \t\t\t+node2style\n            // \t\t\t+\"}\"\n            // \t\t);\n\n            // \t\tnode2.parentNode.insertBefore(stylesheet, node2);\n\n            // \t}\n            // }\n            // importPseudo(node1,node2,\":before\");\n            // importPseudo(node1,node2,\":after\");\n\n            // retarget events\n            cssRegionsHelpers.retargetEvents(node1, node2)\n\n          case 9: // Document node\n          case 11: // Document fragment node\n            child1 = node1.firstChild\n            child2 = node2.firstChild\n            while (child1) {\n              next1 = child1.nextSibling\n              next2 = child2.nextSibling\n\n              // decide between process style or hide\n              if (\n                child1.cssRegionsLastFlowIntoName &&\n                child1.cssRegionsLastFlowIntoType === 'element'\n              ) {\n                node2.removeChild(child2)\n              } else {\n                visit(child1, child2)\n              }\n\n              child1 = next1\n              child2 = next2\n            }\n            break\n        }\n      }\n\n      visit(root1, root2, true)\n    },\n\n    //\n    // make sure the most critical events still fire in the fragment source\n    // even if the browser initially fire them on the fragments\n    //\n    retargetEvents: function retargetEvents(node1, node2) {\n      var retargetEvent = 'cssRegionsHelpers.retargetEvent(this,event)'\n      node2.setAttribute('onclick', retargetEvent)\n      node2.setAttribute('ondblclick', retargetEvent)\n      node2.setAttribute('onmousedown', retargetEvent)\n      node2.setAttribute('onmouseup', retargetEvent)\n      node2.setAttribute('onmousein', retargetEvent)\n      node2.setAttribute('onmouseout', retargetEvent)\n      node2.setAttribute('onmouseenter', retargetEvent)\n      node2.setAttribute('onmouseleave', retargetEvent)\n    },\n\n    //\n    // single hub for event retargeting operations.\n    //\n    retargetEvent: function retargeEvent(node2, e) {\n      // get the node we should fire the event on\n      var node1 =\n        node2.cssRegionsFragmentSource ||\n        (node2.cssRegionsFragmentSource = document.querySelector(\n          '[data-css-regions-fragment-source=\"' +\n            node2.getAttribute('data-css-regions-fragment-of') +\n            '\"]'\n        ))\n\n      if (node1) {\n        // dispatch the event on the real node\n        var ne = domEvents.cloneEvent(e)\n        node1.dispatchEvent(ne)\n\n        // prevent the event to fire on the region\n        e.stopImmediatePropagation ? e.stopImmediatePropagation() : e.stopPropagation()\n\n        // make sure to cancel the event if required\n        if (ne.isDefaultPrevented || ne.defaultPrevented) {\n          e.preventDefault()\n          return false\n        }\n      }\n    }\n  })\n\n  return cssRegionsHelpers\n})(window, document)\n\nrequire.define('src/css-regions/lib/helpers.js');","//\n// this module holds the front-facing features of the polyfill\n//\nmodule.exports = (function(window, document, cssRegions) { \"use strict\";\n\n\tvar domEvents = require('src/core/dom-events.js');\n\tvar cssSyntax = require('src/core/css-syntax.js');\n\tvar cssCascade = require('src/core/css-cascade.js');\n\tvar cssBreak = require('src/core/css-break.js');\n\tvar cssRegionsHelpers = require('src/css-regions/lib/helpers.js');\n\tvar ES = require('src/core/dom-experimental-event-streams.js');\n\n\t// \n\t// this class contains flow-relative data field\n\t// \n\tcssRegions.Flow = function NamedFlow(name) {\n\t\t\n\t\t// TODO: force immediate relayout if someone ask the overset properties\n\t\t// and the layout has been deemed wrong (still isn't a proof of correctness but okay)\n\t\t\n\t\t// define the flow name\n\t\tthis.name = name; Object.defineProperty(this, \"name\", {get: function() { return name; }});\n\t\t\n\t\t// define the overset status\n\t\tthis.overset = false;\n\t\t\n\t\t// define the first empty region\n\t\tthis.firstEmptyRegionIndex = -1;\n\t\t\n\t\t// elements poured into the flow\n\t\tthis.content = []; this.lastContent = [];\n\t\t\n\t\t// elements that consume this flow\n\t\tthis.regions = []; this.lastRegions = [];\n\t\t\n\t\t// event handlers\n\t\tthis.eventListeners = {\n\t\t\t\"regionfragmentchange\": [],\n\t\t\t\"regionoversetchange\": [],\n\t\t};\n\t\t\n\t\t// this function is used to work with dom event streams\n\t\tvar This=this; This.update = function(stream) {\n\t\t\tstream.schedule(This.update); This.relayout();\n\t\t};\n\t\t\n\t\t// register to style changes already\n\t\tThis.lastStylesheetAdded = 0;\n\t\tcssCascade.addEventListener('stylesheetadded', function() {\n\t\t\tif(This.lastStylesheetAdded - Date() > 100) {\n\t\t\t\tThis.lastStylesheetAdded = +Date();\n\t\t\t\tThis.relayout();\n\t\t\t} else {\n\t\t\t\tcssConsole.warn(\"Please don't add stylesheets as a response to region events. Operation cancelled.\")\n\t\t\t}\n\t\t});\n\t\t\n\t\t// a small counter to avoid enter retry loops\n\t\tThis.failedLayoutCount = 0;\n\t\t\n\t\t// some other fields\n\t\tThis.lastEventRAF = 0;\n\t\tThis.restartLayout = false;\n\t}\n\t\t\n\tcssRegions.Flow.prototype.removeFromContent = function(element) {\n\t\t\n\t\t// clean up stuff\n\t\tthis.removeEventListenersOf(element);\n\t\t\n\t\t// remove reference\n\t\tvar index = this.content.indexOf(element);\n\t\tif(index>=0) { this.content.splice(index,1); }\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.removeFromRegions = function(element) {\n\t\t\n\t\t// clean up stuff\n\t\tthis.removeEventListenersOf(element);\n\t\t\n\t\t// remove reference\n\t\tvar index = this.regions.indexOf(element);\n\t\tif(index>=0) { this.regions.splice(index,1); }\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.addToContent = function(element) {\n\t\t\n\t\t// handle trivial cases real quick\n\t\tvar content = this.content; \n\t\tif(content.length==0 || content[content.length-1].nextSibling === element) {\n\t\t\tcontent.push(element);\n\t\t\treturn;\n\t\t}\n\t\tif(content[0].previousSibling === element) {\n\t\t\tcontent.unshift(element);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// walk the tree to find an element inside the content chain\n\t\tvar currentNodeIndex = -1;\n\t\tvar treeWalker = document.createTreeWalker(\n\t\t\tdocument.documentElement,\n\t\t\tNodeFilter.SHOW_ELEMENT,\n\t\t\tfunction(node) { \n\t\t\t\treturn (currentNodeIndex = content.indexOf(node)) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP; \n\t\t\t},\n\t\t\tfalse\n\t\t); \n\t\t\n\t\t// which by the way has to be after the considered element\n\t\ttreeWalker.currentNode = element;\n\t\t\n\t\t// if we find such node\n\t\tif(treeWalker.nextNode()) {\n\t\t\t\n\t\t\t// insert the element at his current location\n\t\t\tcontent.splice(currentNodeIndex,0,element);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// add the new element to the end of the array\n\t\t\tcontent.push(element);\n\t\t\t\n\t\t}\n\n\t};\n\n\tcssRegions.Flow.prototype.addToRegions = function(element) {\n\t\t\n\t\t// walk the tree to find an element inside the region chain\n\t\tvar regions = this.regions;\n\t\tvar treeWalker = document.createTreeWalker(\n\t\t\tdocument.documentElement,\n\t\t\tNodeFilter.SHOW_ELEMENT,\n\t\t\tfunction(node) { \n\t\t\t\treturn regions.indexOf(node) >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT; \n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t\t\n\t\t// which by the way has to be after the considered element\n\t\ttreeWalker.currentNode = element;\n\t\t\n\t\t// if we find such node\n\t\tif(treeWalker.nextNode()) {\n\t\t\t\n\t\t\t// insert the element at his current location\n\t\t\tregions.splice(this.regions.indexOf(treeWalker.currentNode),0,element);\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\t// add the new element to the end of the array\n\t\t\tregions.push(element);\n\t\t}\n\t\t\n\t};\n\n\tcssRegions.Flow.prototype.generateContentFragment = function() {\n\t\tvar fragment = document.createDocumentFragment(); var This=this;\n\n\t\t// add copies of all due content\n\t\tfor(var i=0; i<this.content.length; i++) {\n\t\t\tvar element = this.content[i];\n\t\t\t\n\t\t\t// \n\t\t\t// STEP 1: IDENTIFY FRAGMENT SOURCES AS SUCH\n\t\t\t//\n\t\t\tcssRegionsHelpers.markNodesAsFragmentSource([element], element.cssRegionsLastFlowIntoType==\"content\");\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 2: CLONE THE FRAGMENT SOURCES\n\t\t\t// \n\t\t\t\n\t\t\t// depending on the requested behavior\n\t\t\tif(element.cssRegionsLastFlowIntoType==\"element\") {\n\t\t\t\t\n\t\t\t\t\t// add the element\n\t\t\t\t\tvar el = element;\n\t\t\t\t\tvar elClone = el.cloneNode(true);\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\n\t\t\t\t\t\telToInsert.appendChild(elClone);\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild(elToInsert);\n\t\t\t\t\t\n\t\t\t\t\t// clone the style\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t\n\t\t\t\t// add current children\n\t\t\t\tvar el = element.firstChild; while(el) {\n\t\t\t\t\t\n\t\t\t\t\t// add the element\n\t\t\t\t\tvar elClone = el.cloneNode(true);\n\t\t\t\t\tvar elToInsert = elClone; if(elToInsert.tagName==\"LI\") {\n\t\t\t\t\t\telToInsert = document.createElement(el.parentNode.tagName);\n\t\t\t\t\t\telToInsert.style.margin=\"0\";\n\t\t\t\t\t\telToInsert.style.padding=\"0\";\n\t\t\t\t\t\telToInsert.appendChild(elClone);\n\t\t\t\t\t}\n\t\t\t\t\tfragment.appendChild(elToInsert);\n\t\t\t\t\t\n\t\t\t\t\t// clone the style\n\t\t\t\t\tcssRegionsHelpers.copyStyle(el, elClone);\n\t\t\t\t\t\n\t\t\t\t\tel = el.nextSibling;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// STEP 3: HIDE TEXT NODES IN FRAGMENT SOURCES\n\t\t//\n\t\tcssRegionsHelpers.hideTextNodesFromFragmentSource(this.content);\n\t\t\n\t\t//\n\t\t// STEP 4: CONVERT CLONED FRAGMENT SOURCES INTO TRUE FRAGMENTS\n\t\t//\n\t\tcssRegionsHelpers.transformFragmentSourceToFragments(\n\t\t\tArray.prototype.slice.call(fragment.childNodes,0)\n\t\t)\n\t\t\n\t\t\n\t\t//\n\t\t// CLONED CONTENT IS READY!\n\t\t//\n\t\treturn fragment;\n\t}\n\n\tcssRegions.Flow.prototype.relayout = function() {\n\t\tvar This = this;\n\t\t\n\t\t// prevent previous relayouts from eventing\n\t\tcancelAnimationFrame(This.lastEventRAF);\n\t\t\n\t\t// batch relayout queries\n\t\tif(This.relayoutScheduled) { return; }\n\t\tif(This.relayoutInProgress) { This.restartLayout=true; return; }\n\t\tThis.relayoutScheduled = true;\n\t\trequestAnimationFrame(function() { This._relayout() });\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype._relayout = function(data){\n\t\tvar This=this;\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\t//\n\t\t\t// note: it is recommended to look at the beautiful \n\t\t\t// drawings I made before attempting to understand\n\t\t\t// this stuff. If you don't have them, ask me.\n\t\t\t//\n\t\t\tcssConsole.log(\"starting a new relayout for \"+This.name);\n\t\t\tThis.relayoutInProgress=true; This.relayoutScheduled=false;\n\t\t\tThis.lastRelayout = +new Date();\n\t\t\t//debugger;\n\t\t\t\n\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\tvar docElmScrollTop = data && data.docElmScrollTop ? data.docElmScrollTop : document.documentElement.scrollTop;\n\t\t\tvar docBdyScrollTop = data && data.docBdyScrollTop ? data.docBdyScrollTop : document.body.scrollTop;\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 1: REMOVE PREVIOUS EVENT LISTENERS\n\t\t\t//\n\t\t\t\n\t\t\t// remove the listeners from everything\n\t\t\tThis.removeEventListenersOf(This.lastRegions);\n\t\t\tThis.removeEventListenersOf(This.lastContent);\n\t\t\tcancelAnimationFrame(This.lastEventRAF);\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 2: RESTORE CONTENT/REGIONS TO A CLEAN STATE\n\t\t\t//\n\t\t\t\n\t\t\t// detect elements being removed of the document\n\t\t\tThis.regions = This.regions.filter(function(e) { return document.documentElement.contains(e); })\n\t\t\tThis.content = This.content.filter(function(e) { return document.documentElement.contains(e); })\n\t\t\t\n\t\t\t// cleanup previous layout\n\t\t\tcssRegionsHelpers.unmarkNodesAsRegion(This.lastRegions); This.lastRegions = This.regions.slice(0);\n\t\t\tcssRegionsHelpers.unmarkNodesAsFragmentSource(This.lastContent); This.lastContent = This.content.slice(0);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 3: EMPTY ALL REGIONS\n\t\t\t// ADD WRAPPER FOR FLOW CONTENT\n\t\t\t// PREPARE FOR CONTENT CLONING\n\t\t\t//\n\t\t\t\n\t\t\t// empty all the regions\n\t\t\tcssRegionsHelpers.markNodesAsRegion(This.regions);\n\t\t\t\n\t\t\t// create a fresh list of the regions\n\t\t\tvar regionStack = This.regions.slice(0).reverse();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 4: CLONE THE CONTENT\n\t\t\t// ADD METADATA TO CLONED CONTENT\n\t\t\t// HIDE FLOW CONTENT AT INITIAL POSITION\n\t\t\t//\n\t\t\t\n\t\t\t// create a fresh list of the content\n\t\t\t// compute the style of all source elements\n\t\t\t// generate stylesheets for those rules\n\t\t\tvar contentFragment = This.generateContentFragment();\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t//\n\t\t\t// STEP 5: POUR CONTENT INTO THE REGIONS\n\t\t\t//\n\t\t\t\n\t\t\t// layout this stuff\n\t\t\tcssRegions.layoutContent(regionStack, contentFragment, {\n\t\t\t\tonprogress: function(continueLayout) {\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: if the current layout goes nowhere, start a new one already\n\t\t\t\t\tif(This.restartLayout) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tThis.relayoutInProgress = false;\n\t\t\t\t\t\tThis.failedLayoutCount = 0;\n\t\t\t\t\t\tThis.restartLayout = false;\n\t\t\t\t\t\tThis._relayout({\n\t\t\t\t\t\t\tdocElmScrollTop: docElmScrollTop,\n\t\t\t\t\t\t\tdocBdyScrollTop: docBdyScrollTop\n\t\t\t\t\t\t});\n\t\t\t\t\t\t\n\t\t\t\t\t} else {\n\t\t\t\t\t\t\n\t\t\t\t\t\tsetImmediate(continueLayout);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t},\n\t\t\t\tondone: function onLayoutDone(overset) {\n\t\t\t\t\n\t\t\t\t\tThis.overset = overset;\n\t\t\t\t\tThis.firstEmptyRegionIndex = This.regions.length-1; while(This.regions[This.firstEmptyRegionIndex]) {\n\t\t\t\t\t\n\t\t\t\t\t\t// tell whether the region is empty\n\t\t\t\t\t\tvar isEmpty = false;\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper;\n\t\t\t\t\t\tisEmpty = isEmpty || !This.regions[This.firstEmptyRegionIndex].cssRegionsWrapper.firstChild;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// if the region is not empty\n\t\t\t\t\t\tif(!isEmpty) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// the first empty region if the next one, if it exists\n\t\t\t\t\t\t\tif((++This.firstEmptyRegionIndex)==This.regions.length) {\n\t\t\t\t\t\t\t\tThis.firstEmptyRegionIndex = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t\t// else, let's try the previous region\n\t\t\t\t\t\t\tThis.firstEmptyRegionIndex--; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// STEP 6: REGISTER TO UPDATE EVENTS\n\t\t\t\t\t//\n\t\t\t\t\t\n\t\t\t\t\t// make sure regions update are taken in consideration\n\t\t\t\t\tif(window.MutationObserver) {\n\t\t\t\t\t\tThis.addEventListenersTo(This.content);\n\t\t\t\t\t\tThis.addEventListenersTo(This.regions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// the other browsers don't get this as acurately\n\t\t\t\t\t\t// but that shouldn't be that of an issue for 99% of the cases\n\t\t\t\t\t\tsetImmediate(function() {\n\t\t\t\t\t\t\tThis.addEventListenersTo(This.content);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t//\n\t\t\t\t\t// STEP 7: FIRE SOME EVENTS\n\t\t\t\t\t//\n\t\t\t\t\tif(This.regions.length > 0 && !This.restartLayout) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t// before doing anything, let's check our stuff is consistent\n\t\t\t\t\t\tvar isBuggy = false;\n\t\t\t\t\t\tisBuggy = isBuggy || This.regions.some(function(e) { return !document.documentElement.contains(e); })\n\t\t\t\t\t\tisBuggy = isBuggy || This.content.some(function(e) { return !document.documentElement.contains(e); })\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(isBuggy) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if we found any bug, we will need to restart a layout\n\t\t\t\t\t\t\tcssConsole.warn(\"Buggy css regions layout: the page changed; we need to restart.\");\n\t\t\t\t\t\t\tThis.restartLayout = true; \n\t\t\t\t\t\t\t\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if it was okay, let's fire some event\n\t\t\t\t\t\t\tThis.lastEventRAF = requestAnimationFrame(function() {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// TODO: only fire when necessary but...\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionfragmentchange');\n\t\t\t\t\t\t\t\tThis.dispatchEvent('regionoversetchange');\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\t// NOTE: we recover the scroll position in case the browser mess it up\n\t\t\t\t\tdocument.documentElement.scrollTop = docElmScrollTop;\n\t\t\t\t\tdocument.body.scrollTop = docBdyScrollTop;\n\t\t\t\t\t\n\t\t\t\t\t// mark layout has being done\n\t\t\t\t\tThis.relayoutInProgress = false;\n\t\t\t\t\tThis.failedLayoutCount = 0;\n\t\t\t\t\t\n\t\t\t\t\t// restart a layout if a request was queued during the current one\n\t\t\t\t\tif(This.restartLayout) {\n\t\t\t\t\t\tThis.restartLayout = false;\n\t\t\t\t\t\tThis.relayout();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t} catch(ex) {\n\t\t\t\n\t\t\t// sometimes IE fails for no valid reason \n\t\t\t// (other than the page is still loading)\n\t\t\tsetImmediate(function() { throw ex; });\n\t\t\t\n\t\t\t// but we cannot accept to fail, so we need to try again\n\t\t\t// until we finish a complete layout pass...\n\t\t\tThis.failedLayoutCount++;\n\t\t\tif(This.failedLayoutCount<7) {requestAnimationFrame(function() { This._relayout() });}\n\t\t\telse {This.failedLayoutCount=0; This.relayoutScheduled=false; This.relayoutInProgress=false; This.restartLayout=false; }\n\t\t\t\n\t\t}\n\t}\n\n\tcssRegions.Flow.prototype.relayoutIfSizeChanged = function() {\n\t\t\n\t\t// go through all regions\n\t\t// and see if any did change of size\n\t\tvar rs = this.regions;     \n\t\tfor(var i=rs.length; i--; ) {\n\t\t\tif(\n\t\t\t\trs[i].offsetHeight !== rs[i].cssRegionsLastOffsetHeight\n\t\t\t\t|| rs[i].offsetWidth !== rs[i].cssRegionsLastOffsetWidth\n\t\t\t) {\n\t\t\t\tthis.relayout(); return;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype.addEventListenersTo = function(nodes) {\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\n\t\t\n\t\tnodes.forEach(function(element) {\n\t\t\tif(!element.cssRegionsEventStream) {\n\t\t\t\telement.cssRegionsEventStream = new ES.DOMUpdateEventStream({target: element});\n\t\t\t\telement.cssRegionsEventStream.schedule(This.update);\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\n\tcssRegions.Flow.prototype.removeEventListenersOf = function(nodes) {\n\t\tvar This=this; if(nodes instanceof Element) { nodes=[nodes] }\n\t\t\n\t\tnodes.forEach(function(element) {\n\t\t\tif(element.cssRegionsEventStream) {\n\t\t\t\telement.cssRegionsEventStream.dispose();\n\t\t\t\tdelete element.cssRegionsEventStream;\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\n\t// alias\n\tcssRegions.NamedFlow = cssRegions.Flow;\n\n\t// return a disconnected array of the content of a NamedFlow\n\tcssRegions.NamedFlow.prototype.getContent = function getContent() {\n\t\treturn this.content.slice(0)\n\t}\n\n\t// return a disconnected array of the regions of a NamedFlow\n\tcssRegions.NamedFlow.prototype.getRegions = function getRegions() {\n\t\treturn this.regions.slice(0)\n\t}\n\n\tcssRegions.NamedFlow.prototype.getRegionsByContent = function getRegionsByContent(node) {\n\t\tvar regions = [];\n\t\tvar fragments = document.querySelectorAll('[data-css-regions-fragment-of=\"'+node.getAttribute('data-css-regions-fragment-source')+'\"]');\n\t\tfor (var i=0; i<fragments.length; i++) {\n\t\t\t\n\t\t\tvar current=fragments[i]; do {\n\t\t\t\t\n\t\t\t\tif(current.getAttribute('data-css-region')) {\n\t\t\t\t\tregions.push(current); break;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} while(current=current.parentNode);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn regions;\n\t}\n\n\tdomEvents.EventTarget.implementsIn(cssRegions.Flow);\n\n\t//\n\t// this class is a collection of named flows (not an array, sadly)\n\t//\n\tcssRegions.NamedFlowCollection = function NamedFlowCollection() {\n\t\t\n\t\tthis.length = 0;\n\t\t\n\t}\n\n\tcssRegions.NamedFlowCollection.prototype.namedItem = function(k) {\n\t\treturn cssRegions.flows[k] || (cssRegions.flows[k]=new cssRegions.Flow(k));\n\t}\n\n\n\t//\n\t// this helper creates the required methods on top of the DOM {ie: public exports}\n\t//\n\tcssRegions.enablePolyfillObjectModel = function() {\n\t\t\n\t\t//\n\t\t// DOCUMENT INTERFACE\n\t\t//\n\t\t\n\t\t//\n\t\t// returns a static list of active named flows\n\t\t//\n\t\tdocument.getNamedFlows = function() {\n\t\t\t\t\n\t\t\tvar c = new cssRegions.NamedFlowCollection(); var flows = cssRegions.flows;\n\t\t\tfor(var flowName in cssRegions.flows) {\n\t\t\t\t\n\t\t\t\tif(Object.prototype.hasOwnProperty.call(flows, flowName)) {\n\t\t\t\t\t\n\t\t\t\t\t// only active flows can be included\n\t\t\t\t\tif(flows[flowName].content.length!=0 || flows[flowName].regions.length!=0) {\n\t\t\t\t\t\tc[c.length++] = c[flowName] = flows[flowName];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\treturn c;\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// returns a live object for any named flow\n\t\t//\n\t\tdocument.getNamedFlow = function(flowName) {\n\t\t\t\t\n\t\t\tvar flows = cssRegions.flows;\n\t\t\treturn (flows[flowName] || (flows[flowName]=new cssRegions.NamedFlow(flowName)));\n\t\t\t\n\t\t}\n\t\t\n\t\t//\n\t\t// ELEMENT INTERFACE\n\t\t//    \n\t\tObject.defineProperties(\n\t\t\tElement.prototype,\n\t\t\t{\n\t\t\t\t\"regionOverset\": {\n\t\t\t\t\tget: function() {\n\t\t\t\t\t\treturn this._regionOverset || 'fit';\n\t\t\t\t\t},\n\t\t\t\t\tset: function(value) {\n\t\t\t\t\t\tthis._regionOverset = value;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"getRegionFlowRanges\": {\n\t\t\t\t\tvalue: function getRegionFlowRanges() {\n\t\t\t\t\t\treturn null; // TODO: can we implement that? I think we can't (properly).\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t\"getComputedRegionStyle\": {\n\t\t\t\t\tvalue: function getComputedRegionStyle(element,pseudo) {\n\t\t\t\t\t\t// TODO: only works while we don't relayout\n\t\t\t\t\t\t// TODO: only works properly for elements actually in the region\n\t\t\t\t\t\tvar fragment = document.querySelector('[data-css-regions-fragment-of=\"'+element.getAttribute('data-css-regions-fragment-source')+'\"]');\n\t\t\t\t\t\tif(pseudo) {\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element, pseudo);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn getComputedStyle(fragment||element);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t)\n\t\t\n\t\t\n\t\t//\n\t\t// CSSStyleDeclaration interface\n\t\t//\n\t\tcssCascade.polyfillStyleInterface('flow-into');\n\t\tcssCascade.polyfillStyleInterface('flow-from');\n\t\tcssCascade.polyfillStyleInterface('region-fragment');\n\t\tcssCascade.polyfillStyleInterface('break-before');\n\t\tcssCascade.polyfillStyleInterface('break-after');\n\n\t}\n\n\t// load the polyfill immediately if not especially told otherwise\n\tif(!(\"cssRegionsManualTrigger\" in window)) { cssRegions.enablePolyfill(); }\n\t\n});\nrequire.define('src/css-regions/lib/objectmodel.js');","//\n// this module holds the big-picture actions of the polyfill\n//\nmodule.exports = (function(window, document) {\n  'use strict'\n\n  var domEvents = require('src/core/dom-events.js')\n  var cssSyntax = require('src/core/css-syntax.js')\n  var cssCascade = require('src/core/css-cascade.js')\n  var cssBreak = require('src/core/css-break.js')\n\n  require('src/css-regions/lib/range-extensions.js')\n  var cssRegionsHelpers = require('src/css-regions/lib/helpers.js')\n  var enableObjectModel = require('src/css-regions/lib/objectmodel.js')\n\n  var CSS_STYLE =\n    \"cssregion,[data-css-region]>*,[data-css-regions-fragment-source]:not([data-css-regions-cloning]),[data-css-regions-fragment-source][data-css-regions-cloned]{display:none!important}[data-css-region]>cssregion:last-of-type{display:inline!important}[data-css-region]{content:normal!important}[data-css-special-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]{counter-reset:none!important;counter-increment:none!important;margin-bottom:0!important;padding-bottom:0!important;border-bottom:none!important;border-bottom-left-radius:0!important;border-bottom-right-radius:0!important}[data-css-continued-fragment]::after{content:none!important;display:none!important}[data-css-special-starting-fragment]{text-indent:0!important;margin-top:0!important}[data-css-starting-fragment]{text-indent:0!important;margin-top:0!important;padding-top:0!important;border-top:none!important;border-top-left-radius:0!important;border-top-right-radius:0!important}[data-css-starting-fragment]::before{content:none!important;display:none!important}[data-css-continued-block-fragment][data-css-continued-fragment]:not(:empty)::after{content:''!important;display:inline-block!important;width:100%!important;height:0!important;font-size:0!important;line-height:0!important;margin:0!important;padding:0!important;border:0!important}\"\n\n  var cssRegions = {\n    //\n    // this function is at the heart of the region polyfill\n    // it will iteratively fill a list of regions until no\n    // content or no region is left\n    //\n    // the before-overflow size of a region is determined by\n    // adding all content to it and comparing his offsetHeight\n    // and his scrollHeight\n    //\n    // when this is done, we use dom ranges to detect the point\n    // where the content exceed this box and we split the fragment\n    // at that point.\n    //\n    // when splitting inside an element, the borders, paddings and\n    // generated content must be tied to the right fragments which\n    // require some code\n    //\n    // this functions returns whether some content was still remaining\n    // when the flow when the last region was filled. please not this\n    // can only happen if this last region has \"region-fragment\" set\n    // to break, otherwhise all the content will automatically overflow\n    // this last region.\n    //\n    layoutContent: function(regions, remainingContent, callback, startTime) {\n      //\n      // this function will iteratively fill all the regions\n      // when we reach the last region, we return the overset status\n      //\n\n      // validate args\n      if (!regions) return callback.ondone(!!remainingContent.hasChildNodes())\n      if (!regions.length) return callback.ondone(!!remainingContent.hasChildNodes())\n      if (!startTime) startTime = Date.now()\n\n      // get the next region\n      var region = regions.pop()\n\n      // NOTE: while we don't monitor that, and it can therefore become inaccurate\n      // I'm going to follow the spec and refuse to mark as region inline/none elements]\n      while (true) {\n        var regionDisplay = getComputedStyle(region).display\n        if (regionDisplay == 'none' || regionDisplay.indexOf('inline') !== -1) {\n          if ((region = regions.pop())) {\n            continue\n          } else {\n            return callback.ondone(!!remainingContent.hasChildNodes())\n          }\n        } else {\n          break\n        }\n      }\n\n      // the polyfill actually use a <cssregion> wrapper\n      // we need to link this wrapper and the actual region\n      if (region.cssRegionsWrapper) {\n        region.cssRegionsWrapper.cssRegionHost = region\n        region = region.cssRegionsWrapper\n      } else {\n        region.cssRegionHost = region\n      }\n\n      // empty the region\n      region.innerHTML = ''\n\n      // avoid doing the layout of empty regions\n      if (!remainingContent.hasChildNodes()) {\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        region.cssRegionHost.regionOverset = 'empty'\n\n        var dummyCallback = {\n          ondone: function() {},\n          onprogress: function(f) {\n            f()\n          }\n        }\n        cssRegions.layoutContent(regions, remainingContent, dummyCallback, startTime)\n\n        return callback.ondone(false)\n      }\n\n      // append the remaining content to the region\n      region.appendChild(remainingContent)\n\n      // check if we have more regions to process\n      if (regions.length !== 0) {\n        return this.layoutContentInNextRegionsWhenReady(\n          region,\n          regions,\n          remainingContent,\n          callback,\n          startTime\n        )\n      } else {\n        return this.layoutContentInLastRegionWhenReady(\n          region,\n          regions,\n          remainingContent,\n          callback,\n          startTime\n        )\n      }\n    },\n\n    layoutContentInNextRegionsWhenReady: function(\n      region,\n      regions,\n      remainingContent,\n      callback,\n      startTime\n    ) {\n      // delays until all images are loaded\n      // var imgs = region.getElementsByTagName('img');\n      // for(var imgs_index=imgs.length; imgs_index--; ) {\n      // \tif(!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n      // \t\treturn setTimeout(\n      // \t\t\tfunction() {\n      // \t\t\t\tthis.layoutContentInNextRegionsWhenReady(region, regions, remainingContent, callback, startTime+32);\n      // \t\t\t}.bind(this),\n      // \t\t\t16\n      // \t\t);\n      // \t}\n      // }\n\n      // check if there was an overflow or some break-before/after instruction\n      var regionDidOverflow = region.cssRegionHost.scrollHeight != region.cssRegionHost.offsetHeight\n      var shouldSegmentContent = regionDidOverflow\n      if (!shouldSegmentContent) {\n        var first = region.firstElementChild\n        var last = region.lastElementChild\n        var current = first\n        while (current) {\n          if (current != first) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-before', undefined, true).toCSSString()\n              )\n            ) {\n              shouldSegmentContent = true\n              break\n            }\n          }\n\n          if (current != last) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-after', undefined, true).toCSSString()\n              )\n            ) {\n              current = current.nextElementSibling\n              shouldSegmentContent = true\n              break\n            }\n          }\n\n          current = current.nextElementSibling\n        }\n      }\n\n      if (shouldSegmentContent) {\n        // the remaining content is what was overflowing\n        remainingContent = this.extractOverflowingContent(region)\n      } else {\n        // there's nothing more to insert\n        remainingContent = document.createDocumentFragment()\n      }\n\n      // if any content didn't fit\n      if (remainingContent.hasChildNodes()) {\n        region.cssRegionHost.regionOverset = 'overset'\n      } else {\n        region.cssRegionHost.regionOverset = 'fit'\n      }\n\n      // update flags\n      region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n      region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n      // layout the next regions\n      // WE LET THE NEXT REGION DECIDE WHAT TO RETURN\n      if (startTime + 200 > Date.now()) {\n        return cssRegions.layoutContent(regions, remainingContent, callback, startTime)\n      } else {\n        return callback.onprogress(function() {\n          cssRegions.layoutContent(regions, remainingContent, callback)\n        })\n      }\n    },\n\n    layoutContentInLastRegionWhenReady: function(\n      region,\n      regions,\n      remainingContent,\n      callback,\n      startTime\n    ) {\n      // delays until all images are loaded\n      // var imgs = region.getElementsByTagName('img')\n      // for (var imgs_index = imgs.length; imgs_index--; ) {\n      //   if (!imgs[imgs_index].complete && !imgs[imgs_index].hasAttribute('height')) {\n      //     return setTimeout(\n      //       function() {\n      //         this.layoutContentInLastRegionWhenReady(\n      //           region,\n      //           regions,\n      //           remainingContent,\n      //           callback,\n      //           startTime + 32\n      //         )\n      //       }.bind(this),\n      //       32\n      //     )\n      //   }\n      // }\n\n      // support region-fragment: break\n      if (\n        cssCascade\n          .getSpecifiedStyle(region.cssRegionHost, 'region-fragment', undefined, true)\n          .toCSSString()\n          .trim()\n          .toLowerCase() == 'break'\n      ) {\n        // WE RETURN TRUE IF WE DID OVERFLOW\n        var didOverflow = this.extractOverflowingContent(region).hasChildNodes()\n\n        // update flags\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        return callback.ondone(didOverflow)\n      } else {\n        // update flags\n        region.cssRegionHost.cssRegionsLastOffsetHeight = region.cssRegionHost.offsetHeight\n        region.cssRegionHost.cssRegionsLastOffsetWidth = region.cssRegionHost.offsetWidth\n\n        // WE RETURN FALSE IF WE DIDN'T OVERFLOW\n        return callback.ondone(\n          region.cssRegionHost.offsetHeight != region.cssRegionHost.scrollHeight\n        )\n      }\n    },\n\n    //\n    // this function returns a document fragment containing the content\n    // that didn't fit in a particular <cssregion> element.\n    //\n    // in the simplest cases, we can just use hit-targeting to get very\n    // close the the natural breaking point. for mostly textual flows,\n    // this works perfectly, for the others, we may need some tweaks.\n    //\n    // there's a code detecting whether this hit-target optimization\n    // did possibly fail, in which case we return to a setup where we\n    // start from scratch.\n    //\n    extractOverflowingContent: function(region, dontOptimize) {\n      // make sure empty nodes don't make our life more difficult\n      cssRegionsHelpers.embedTrailingWhiteSpaceNodes(region)\n\n      // get the region layout\n      var sizingH = region.cssRegionHost.offsetHeight // avail size (max-height)\n      var sizingW = region.cssRegionHost.offsetWidth // avail size (max-width)\n      var pos = region.cssRegionHost.getBoundingClientRect() // avail size?\n      pos = { top: pos.top, bottom: pos.bottom, left: pos.left, right: pos.right }\n\n      // substract from the bottom any border/padding of the region\n      var lostHeight = parseInt(getComputedStyle(region.cssRegionHost).paddingBottom)\n      lostHeight += parseInt(getComputedStyle(region.cssRegionHost).borderBottomWidth)\n      pos.bottom -= lostHeight\n      sizingH -= lostHeight\n\n      //\n      // note: let's use hit targeting to find a dom range\n      // which is close to the location where we will need to\n      // break the content into fragments\n      //\n\n      // get the caret range for the bottom-right of that location\n      try {\n        var r = dontOptimize\n          ? document.createRange()\n          : document.caretRangeFromPoint(pos.left + sizingW - 1, pos.top + sizingH - 1)\n      } catch (ex) {\n        try {\n          cssConsole.error(ex.message)\n          cssConsole.dir(ex)\n        } catch (ex) {}\n      }\n\n      // helper for logging info\n      /*cssConsole.log(\"extracting overflow\")\n\t\t\tcssConsole.log(pos.bottom)*/\n      var debug = function() {\n        /*cssConsole.dir({\n\t\t\t\t\tstartContainer: r.startContainer,\n\t\t\t\t\tstartOffset: r.startOffset,\n\t\t\t\t\tbrowserBCR: r.getBoundingClientRect(),\n\t\t\t\t\tcomputedBCR: rect\n\t\t\t\t});*/\n      }\n\n      var fixNullRect = function() {\n        if (rect.bottom == 0 && rect.top == 0 && rect.left == 0 && rect.right == 0) {\n          var scrollTop = -(document.documentElement.scrollTop || document.body.scrollTop)\n          var scrollLeft = -(document.documentElement.scrollLeft || document.body.scrollLeft)\n\n          rect = {\n            width: 0,\n            heigth: 0,\n            top: scrollTop,\n            bottom: scrollTop,\n            left: scrollLeft,\n            right: scrollLeft\n          }\n        }\n      }\n\n      // if the caret is outside the region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        // if the caret is after the region wrapper but inside the host...\n        if (\n          r &&\n          r.endContainer === region.cssRegionHost &&\n          r.endOffset == r.endContainer.childNodes.length\n        ) {\n          // move back at the end of the region, actually\n          r.setStart(region, region.childNodes.length)\n          r.setEnd(region, region.childNodes.length)\n        } else {\n          // move back into the region\n          r = r || document.createRange()\n          r.setStart(region, 0)\n          r.setEnd(region, 0)\n          dontOptimize = true\n        }\n      }\n\n      // start finding the natural breaking point\n      do {\n        // store the current selection rect for fast access\n        var rect = r.myGetExtensionRect()\n        fixNullRect()\n        debug()\n\n        //\n        // note: maybe the text is right-to-left\n        // in this case, we can go further than the caret\n        //\n\n        // move the end point char by char until it's completely in the region\n        while (\n          !(r.endContainer == region && r.endOffset == r.endContainer.childNodes.length) &&\n          rect.bottom <= pos.top + sizingH\n        ) {\n          debug()\n\n          // look if we can optimize by moving fast forward\n          var nextSibling = r.endContainer.childNodes[r.endOffset]\n          var nextSiblingRect = !nextSibling || Node.getBoundingClientRect(nextSibling)\n          if (nextSibling && nextSiblingRect.bottom <= pos.top + sizingH) {\n            // if yes, move element by element\n            r.setStartAfter(nextSibling)\n            r.setEndAfter(nextSibling)\n            rect = nextSiblingRect\n            fixNullRect()\n          } else {\n            // otherwise, go char-by-char\n            r.myMoveTowardRight()\n            rect = r.myGetExtensionRect()\n            fixNullRect()\n          }\n        }\n\n        //\n        // note: maybe the text is one line too big\n        // in this case, we have to backtrack a little\n        //\n\n        // move the end point char by char until it's completely in the region\n        while (!(r.endContainer == region && r.endOffset == 0) && rect.bottom > pos.top + sizingH) {\n          debug()\n          r.myMoveOneCharLeft()\n          rect = r.myGetExtensionRect()\n          fixNullRect()\n        }\n\n        debug()\n\n        //\n        // note: if we optimized via hit-testing, this may be wrong\n        // if next condition does not hold, we're fine.\n        // otherwhise we must restart without optimization...\n        //\n\n        // if the selected content is possibly off-target\n        var optimizationFailled = false\n        if (!dontOptimize) {\n          var current = r.endContainer\n          while ((current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region))) {\n            if (Node.getBoundingClientRect(current).bottom > pos.top + sizingH) {\n              r.setStart(region, 0)\n              r.setEnd(region, 0)\n              optimizationFailled = true\n              dontOptimize = true\n              break\n            }\n          }\n        }\n      } while (optimizationFailled)\n\n      //\n      // note: we should not break the content inside monolithic content\n      // if we do, we need to change the selection to avoid that\n      //\n\n      // move the selection before the monolithic ancestors\n      var current = r.endContainer\n      while (current !== region) {\n        if (cssBreak.isMonolithic(current)) {\n          r.setEndBefore(current)\n        }\n        current = current.parentNode\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      //\n      // note: we don't want to break inside a line.\n      // backtrack to end of previous line...\n      //\n      var first = r.startContainer.childNodes[r.startOffset],\n        current = first\n      if (cssBreak.hasAnyInlineFlow(r.startContainer)) {\n        while (current && (current = current.previousSibling)) {\n          if (cssBreak.areInSameSingleLine(current, first)) {\n            // optimization: first and current are on the same line\n            // so if next and current are not the same line, it will still be\n            // the same line the \"first\" element is in\n            first = current\n\n            if (current instanceof Element) {\n              // we don't want to break inside text lines\n              r.setEndBefore(current)\n            } else {\n              // get last line via client rects\n              var lines = Node.getClientRects(current)\n\n              // if the text node did wrap into multiple lines\n              if (lines.length > 1) {\n                // move back from the end until we get into previous line\n                var previousLineBottom = lines[lines.length - 2].bottom\n                r.setEnd(current, current.nodeValue.length)\n                while (rect.bottom > previousLineBottom) {\n                  r.myMoveOneCharLeft()\n                  rect = r.myGetExtensionRect()\n                  fixNullRect()\n                }\n\n                // make sure we didn't exit the text node by mistake\n                if (r.endContainer !== current) {\n                  // if we did, there's something wrong about the text node\n                  // but we can consider the text node as an element instead\n                  r.setEndBefore(current) // debugger;\n                }\n              } else {\n                // we can consider the text node as an element\n                r.setEndBefore(current)\n              }\n            }\n          } else {\n            // if the two elements are not on the same line,\n            // then we just found a line break!\n            break\n          }\n        }\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      //\n      // note: the css-break spec says that a region should not be emtpy\n      //\n\n      // if we end up with nothing being selected, add the first block anyway\n      if (\n        r.endContainer === region &&\n        r.endOffset === 0 &&\n        r.endOffset !== region.childNodes.length\n      ) {\n        // find the first allowed break point\n        do {\n          //cssConsole.dir(r.cloneRange());\n\n          // move the position char-by-char\n          r.myMoveTowardRight()\n\n          // but skip long islands of monolithic elements\n          // since we know we cannot break inside them anyway\n          var current = r.endContainer\n          while (current && current !== region) {\n            if (cssBreak.isMonolithic(current)) {\n              r.setStartAfter(current)\n              r.setEndAfter(current)\n            }\n            current = current.parentNode\n          }\n        } while (\n          // do that until we reach a possible break point, or the end of the element\n          !cssBreak.isPossibleBreakPoint(r, region) &&\n          !(r.endContainer === region && r.endOffset === region.childNodes.length)\n        )\n      }\n\n      // if the selection is not in the region anymore, add the whole region\n      if (!r || (region !== r.endContainer && !Node.contains(region, r.endContainer))) {\n        cssConsole.dir(r.cloneRange())\n        debugger\n        r.setStart(region, region.childNodes.length)\n        r.setEnd(region, region.childNodes.length)\n      }\n\n      // now, let's try to find a break-before/break-after element before the splitting point\n      var current = r.endContainer\n      if (current.hasChildNodes()) {\n        if (r.endOffset > 0) {\n          current = current.childNodes[r.endOffset - 1]\n        }\n      }\n      var first = r.endContainer.firstChild\n      do {\n        if (current.style) {\n          if (current != first) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-before', undefined, true).toCSSString()\n              )\n            ) {\n              r.setStartBefore(current)\n              r.setEndBefore(current)\n              dontOptimize = true // no algo involved in breaking, after all\n            }\n          }\n\n          if (current !== region) {\n            if (\n              /(region|all|always)/i.test(\n                cssCascade.getSpecifiedStyle(current, 'break-after', undefined, true).toCSSString()\n              )\n            ) {\n              r.setStartAfter(current)\n              r.setEndAfter(current)\n              dontOptimize = true // no algo involved in breaking, after all\n            }\n          }\n        }\n      } while ((current = cssRegionsHelpers.getAllLevelPreviousSibling(current, region)))\n\n      // we're almost done! now, let's collect the ancestors to make some splitting postprocessing\n      var current = r.endContainer\n      var allAncestors = []\n      if (current.nodeType !== current.ELEMENT_NODE) current = current.parentNode\n      while (current !== region) {\n        allAncestors.push(current)\n        current = current.parentNode\n      }\n\n      //\n      // note: if we're about to split after the last child of\n      // an element which has bottom-{padding/border/margin},\n      // we need to figure how how much of that p/b/m we can\n      // actually keep in the first fragment\n      //\n      // TODO: avoid top & bottom p/b/m cuttings to use the\n      // same variables names, it's ugly\n      //\n\n      // split bottom-{margin/border/padding} correctly\n      if (r.endOffset == r.endContainer.childNodes.length && r.endContainer !== region) {\n        // compute how much of the bottom border can actually fit\n        var box = r.endContainer.getBoundingClientRect()\n        var excessHeight = box.bottom - (pos.top + sizingH)\n        var endContainerStyle = getComputedStyle(r.endContainer)\n        var availBorderHeight = parseFloat(endContainerStyle.borderBottomWidth)\n        var availPaddingHeight = parseFloat(endContainerStyle.paddingBottom)\n\n        // start by cutting into the border\n        var borderCut = excessHeight\n        if (excessHeight > availBorderHeight) {\n          borderCut = availBorderHeight\n          excessHeight -= borderCut\n\n          // continue by cutting into the padding\n          var paddingCut = excessHeight\n          if (paddingCut > availPaddingHeight) {\n            paddingCut = availPaddingHeight\n            excessHeight -= paddingCut\n          } else {\n            excessHeight = 0\n          }\n        } else {\n          excessHeight = 0\n        }\n\n        // we don't cut borders with radiuses\n        // TODO: accept to cut the content not affected by the radius\n        if (typeof borderCut === 'number' && borderCut !== 0) {\n          // check the presence of a radius:\n          var hasBottomRadius =\n            parseInt(endContainerStyle.borderBottomLeftRadius) > 0 ||\n            parseInt(endContainerStyle.borderBottomRightRadius) > 0\n\n          if (hasBottomRadius) {\n            // break before the whole border:\n            borderCut = availBorderHeight\n          }\n        }\n      }\n\n      // split top-{margin/border/padding} correctly\n      if (r.endOffset == 0 && r.endContainer !== region) {\n        // note: the only possibility here is that we\n        // did split after a padding or a border.\n        //\n        // it can only happen if the border/padding is\n        // too big to fit the region but is actually\n        // the first break we could find!\n\n        // compute how much of the top border can actually fit\n        var box = r.endContainer.getBoundingClientRect()\n        var availHeight = pos.top + sizingH - pos.top\n        var endContainerStyle = getComputedStyle(r.endContainer)\n        var availBorderHeight = parseFloat(endContainerStyle.borderTopWidth)\n        var availPaddingHeight = parseFloat(endContainerStyle.paddingTop)\n        var excessHeight = availBorderHeight + availPaddingHeight - availHeight\n\n        if (excessHeight > 0) {\n          // start by cutting into the padding\n          var topPaddingCut = excessHeight\n          if (excessHeight > availPaddingHeight) {\n            topPaddingCut = availPaddingHeight\n            excessHeight -= topPaddingCut\n\n            // continue by cutting into the border\n            var topBorderCut = excessHeight\n            if (topBorderCut > availBorderHeight) {\n              topBorderCut = availBorderHeight\n              excessHeight -= topBorderCut\n            } else {\n              excessHeight = 0\n            }\n          } else {\n            excessHeight = 0\n          }\n        }\n      }\n\n      // remove bottom-{pbm} from all ancestors involved in the cut\n      for (var i = allAncestors.length - 1; i >= 0; i--) {\n        allAncestors[i].setAttribute('data-css-continued-fragment', true)\n        if (getComputedStyle(allAncestors[i]).display.indexOf('block') >= 0) {\n          allAncestors[i].setAttribute('data-css-continued-block-fragment', true)\n        }\n      }\n      if (typeof borderCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.borderBottomWidth = availBorderHeight - borderCut + 'px'\n      }\n      if (typeof paddingCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.paddingBottom = availPaddingHeight - paddingCut + 'px'\n      }\n      if (typeof topBorderCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-continued-fragment', true)\n        allAncestors[0].style.borderTopWidth = availBorderHeight - topBorderCut + 'px'\n      }\n      if (typeof topPaddingCut === 'number') {\n        allAncestors[0].removeAttribute('data-css-continued-fragment')\n        allAncestors[0].setAttribute('data-css-special-continued-fragment', true)\n        allAncestors[0].style.paddingTop = availPaddingHeight - topPaddingCut + 'px'\n      }\n\n      //\n      // note: at this point we have a collapsed range\n      // located at the split point\n      //\n\n      // select the overflowing content\n      r.setEnd(region, region.childNodes.length)\n\n      // extract it from the current region\n      var overflowingContent = r.extractContents()\n\n      // remove trailing whitespace from the cut element\n      var tmp = allAncestors[0]\n      if (tmp && (tmp = tmp.lastChild) && !tmp.tagName && tmp.nodeValue) {\n        var nodeValue = tmp.nodeValue.replace(/(\\s|\\r|\\n)*$/, '')\n        if (nodeValue) {\n          // if the last cut was just after a &shy; (soft hyphen), we need to append a dash\n          if (/\\u00AD$/.test(nodeValue)) {\n            nodeValue = nodeValue.replace(/\\u00AD$/, '-')\n          } else if (overflowingContent && overflowingContent.textContent[0] == '\\u00AD') {\n            nodeValue = nodeValue + '-'\n          }\n          tmp.nodeValue = nodeValue\n        } else {\n          tmp.parentNode.removeChild(tmp)\n        }\n      }\n\n      //\n      // note: now we have to cancel out the artifacts of\n      // the fragments cloning algorithm...\n      //\n\n      // do not forget to remove any top p/b/m on cut elements\n      var newFragments = overflowingContent.querySelectorAll('[data-css-continued-fragment]')\n      for (var i = newFragments.length; i--; ) {\n        // TODO: optimize by using while loop and a simple matchesSelector.\n        newFragments[i].removeAttribute('data-css-continued-fragment')\n        newFragments[i].setAttribute('data-css-starting-fragment', true)\n      }\n\n      // deduct any already-used bottom p/b/m\n      var specialNewFragment = overflowingContent.querySelector(\n        '[data-css-special-continued-fragment]'\n      )\n      if (specialNewFragment) {\n        specialNewFragment.removeAttribute('data-css-special-continued-fragment')\n        specialNewFragment.setAttribute('data-css-starting-fragment', true)\n\n        if (typeof borderCut === 'number') {\n          specialNewFragment.style.borderBottomWidth = borderCut + 'px'\n        }\n        if (typeof paddingCut === 'number') {\n          specialNewFragment.style.paddingBottom = paddingCut\n        } else {\n          specialNewFragment.style.paddingBottom = '0px'\n        }\n\n        if (typeof topBorderCut === 'number') {\n          specialNewFragment.removeAttribute('data-css-starting-fragment')\n          specialNewFragment.setAttribute('data-css-special-starting-fragment', true)\n          specialNewFragment.style.borderTopWidth = topBorderCut + 'px'\n        }\n        if (typeof topPaddingCut === 'number') {\n          specialNewFragment.removeAttribute('data-css-starting-fragment')\n          specialNewFragment.setAttribute('data-css-special-starting-fragment', true)\n          specialNewFragment.style.paddingTop = topPaddingCut + 'px'\n          specialNewFragment.style.paddingBottom = '0px'\n          specialNewFragment.style.borderBottomWidth = '0px'\n        }\n      } else if (typeof borderCut === 'number') {\n        // hum... there's an element missing here... {never happens anymore}\n        try {\n          throw new Error()\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n      } else if (typeof topPaddingCut === 'number') {\n        // hum... there's an element missing here... {never happens anymore}\n        try {\n          throw new Error()\n        } catch (ex) {\n          setImmediate(function() {\n            throw ex\n          })\n        }\n      }\n\n      // make sure empty nodes are reintroduced\n      cssRegionsHelpers.unembedTrailingWhiteSpaceNodes(region)\n      cssRegionsHelpers.unembedTrailingWhiteSpaceNodes(overflowingContent)\n\n      // we're ready to return our result!\n      return overflowingContent\n    },\n\n    enablePolyfill: function enablePolyfill() {\n      //\n      // [0] insert necessary css\n      //\n      var s = document.createElement('style')\n      s.setAttribute('data-css-no-polyfill', true)\n      s.textContent = CSS_STYLE\n      var head = document.head || document.getElementsByTagName('head')[0]\n      head.appendChild(s)\n\n      //\n      // [1] when any update happens:\n      // construct new content and region flow pairs\n      // restart the region layout algorithm for the modified pairs\n      //\n      cssCascade.startMonitoringProperties(['flow-into', 'flow-from', 'region-fragment'], {\n        onupdate: function onupdate(element, rule) {\n          // let's just ignore fragments\n          if (element.getAttributeNode('data-css-regions-fragment-of')) return\n\n          // log some message in the console for debug\n          cssConsole.dir({\n            message: 'onupdate',\n            element: element,\n            selector: rule.selector.toCSSString(),\n            rule: rule\n          })\n          var temp = null\n\n          //\n          // compute the value of region properties\n          //\n          var flowInto = cssCascade.getSpecifiedStyle(element, 'flow-into').filter(function(t) {\n            return t instanceof cssSyntax.IdentifierToken\n          })\n\n          var flowIntoName = flowInto[0] ? flowInto[0].toCSSString().toLowerCase() : ''\n          if (\n            flowIntoName == 'none' ||\n            flowIntoName == 'initial' ||\n            flowIntoName == 'inherit' ||\n            flowIntoName == 'default'\n          ) {\n            flowIntoName = ''\n          }\n          var flowIntoType = flowInto[1] ? flowInto[1].toCSSString().toLowerCase() : ''\n          if (flowIntoType != 'content') {\n            flowIntoType = 'element'\n          }\n          var flowInto = flowIntoName ? flowIntoName + ' ' + flowIntoType : ''\n\n          var flowFrom = cssCascade.getSpecifiedStyle(element, 'flow-from').filter(function(t) {\n            return t instanceof cssSyntax.IdentifierToken\n          })\n\n          var flowFromName = flowFrom[0] ? flowFrom[0].toCSSString().toLowerCase() : ''\n          if (\n            flowFromName == 'none' ||\n            flowFromName == 'initial' ||\n            flowFromName == 'inherit' ||\n            flowFromName == 'default'\n          ) {\n            flowFromName = ''\n          }\n          var flowFrom = flowFromName\n\n          //\n          // if the value of any property did change...\n          //\n          if (\n            element.cssRegionsLastFlowInto != flowInto ||\n            element.cssRegionsLastFlowFrom != flowFrom\n          ) {\n            // remove the element from previous regions\n            var regionOverset = element.regionOverset\n            var lastFlowFrom = cssRegions.flows[element.cssRegionsLastFlowFromName]\n            var lastFlowInto = cssRegions.flows[element.cssRegionsLastFlowIntoName]\n            lastFlowFrom && lastFlowFrom.removeFromRegions(element)\n            lastFlowInto && lastFlowInto.removeFromContent(element)\n\n            // relayout those regions\n            // (it's async so it will wait for us\n            // to add the element back if needed)\n            lastFlowFrom && regionOverset != 'empty' && lastFlowFrom.relayout()\n            lastFlowInto && lastFlowInto.relayout()\n\n            // save some property values for later\n            element.cssRegionsLastFlowInto = flowInto\n            element.cssRegionsLastFlowFrom = flowFrom\n            element.cssRegionsLastFlowIntoName = flowIntoName\n            element.cssRegionsLastFlowFromName = flowFromName\n            element.cssRegionsLastFlowIntoType = flowIntoType\n\n            // add the element to new regions\n            // and relayout those regions, if deemed necessary\n            if (flowFromName) {\n              var lastFlowFrom = (cssRegions.flows[flowFromName] =\n                cssRegions.flows[flowFromName] || new cssRegions.Flow(flowFromName))\n              lastFlowFrom && lastFlowFrom.addToRegions(element)\n              lastFlowFrom && lastFlowFrom.relayout()\n            }\n            if (flowIntoName) {\n              var lastFlowInto = (cssRegions.flows[flowIntoName] =\n                cssRegions.flows[flowIntoName] || new cssRegions.Flow(flowIntoName))\n              lastFlowInto && lastFlowInto.addToContent(element)\n              lastFlowInto && lastFlowInto.relayout()\n            }\n          }\n        }\n      })\n      cssCascade.startMonitoringProperties(['break-before', 'break-after'], {\n        onupdate: function(element) {\n          // avoid fragments triggering update loops\n          if (element.getAttribute('data-css-regions-fragment-of')) {\n            return\n          }\n\n          // update parent regions\n          while (element) {\n            if (element.cssRegionsLastFlowIntoName) {\n              cssRegions.flows[element.cssRegionsLastFlowIntoName].relayout()\n              return\n            }\n            element = element.parentNode\n          }\n        }\n      })\n\n      //\n      // [2] perform the OM exports\n      //\n      cssRegions.enablePolyfillObjectModel()\n\n      //\n      // [3] make sure to update the region layout when all images loaded\n      //\n      window.addEventListener('load', function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          flows[i].relayout()\n        }\n      })\n\n      //\n      // [4] make sure we react to window resizes\n      //\n      //\n      var lastWindowResize = 0\n      var relayoutModifiedFlows = function() {\n        // specify the function did run\n        relayoutModifiedFlows.timeout = 0\n\n        // rerun the layout\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            flows[i].relayout()\n          } else {\n            flows[i].relayoutIfSizeChanged()\n          }\n        }\n      }\n      var hasOngoingLayouts = function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            return true\n          }\n        }\n\n        return false\n      }\n      var restartOngoingLayouts = function() {\n        var flows = document.getNamedFlows()\n        for (var i = 0; i < flows.length; i++) {\n          if (flows[i].lastRelayout > lastWindowResize) continue\n          if (flows[i].relayoutInProgress) {\n            flows[i].relayout()\n          }\n        }\n      }\n      window.addEventListener('resize', function() {\n        // update the last layout flag\n        lastWindowResize = +new Date()\n\n        // if we aren't planning a resfresh already\n        if (!relayoutModifiedFlows.timeout) {\n          // if we are already busy\n          if (hasOngoingLayouts()) {\n            // restart all layouts now\n            setTimeout(restartOngoingLayouts, 16)\n\n            // wait half a second before restarting them from now\n            relayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 500)\n          } else {\n            // debounce by running the resize code every 200ms\n            relayoutModifiedFlows.timeout = setTimeout(relayoutModifiedFlows, 200)\n          }\n        }\n      })\n    },\n\n    // this dictionary is supposed to contains all the currently existing flows\n    flows: Object.create ? Object.create(null) : {}\n  }\n\n  enableObjectModel(window, document, cssRegions)\n\n  return cssRegions\n})(window, document)\n\nrequire.define('src/css-regions/polyfill.js');","//require('core:polyfill-dom-matchMedia');\n//require('core:polyfill-dom-classList');\n//require('css-grid:polyfill');\nrequire('src/css-regions/polyfill.js');\nrequire.define('src/requirements.js');"]}